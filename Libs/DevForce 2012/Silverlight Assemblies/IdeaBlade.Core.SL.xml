<?xml version="1.0"?>
<doc>
    <assembly>
        <name>IdeaBlade.Core.SL</name>
    </assembly>
    <members>
        <member name="T:IdeaBlade.Core.AssertionException">
            <summary>
            Any Debug.Assert or Trace.Assert errors encountered will raise this exception type
            </summary>
        </member>
        <member name="T:IdeaBlade.Core.IdeaBladeException">
            <summary>
            Base class for exception types within the IdeaBlade DevForce framework.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.IdeaBladeException.#ctor">
            <summary>
            Initializes a new instance of the IdeaBladeException class.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.IdeaBladeException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the IdeaBladeException class.
            </summary>
            <param name="pMessage">A message added to describe the exception</param>
        </member>
        <member name="M:IdeaBlade.Core.IdeaBladeException.#ctor(System.String,System.Object[])">
            <summary>
            Initializes a new instance of the IdeaBladeException class.
            </summary>
            <param name="pMessage">A message added to describe the exception containing 0 or more format specifications. 
            See <see cref="M:System.String.Format(System.String,System.Object)"/></param>
            <param name="pMessageArgs">An Object array containing zero or more objects to be formatted.</param>
        </member>
        <member name="M:IdeaBlade.Core.IdeaBladeException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the IdeaBladeException class.
            </summary>
            <param name="pInnerException">An instance of Exception that describes the error that caused this exception</param>
            <param name="pMessage">A message added to describe the exception</param>
        </member>
        <member name="M:IdeaBlade.Core.AssertionException.#ctor">
            <summary>
            Initializes a new instance of the AssertionException class
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.AssertionException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the AssertionException class. See <see cref="T:IdeaBlade.Core.IdeaBladeException"/>
            </summary>
            <param name="pMessage"></param>
        </member>
        <member name="M:IdeaBlade.Core.AssertionException.#ctor(System.String,System.Exception)">
            <summary>
            
            </summary>
            <param name="pMessage"></param>
            <param name="pException"></param>
        </member>
        <member name="M:IdeaBlade.Core.AssertionException.#ctor(System.String,System.Object[])">
            <summary>
            Initializes a new instance of the AssertionException class. See <see cref="T:IdeaBlade.Core.IdeaBladeException"/>
            </summary>
            <param name="pMessage"></param>
            <param name="pMessageArgs"></param>
        </member>
        <member name="P:IdeaBlade.Core.AuthorizationRight.Description">
            <summary>
            
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.AuthorizationRight.AuthorizationCode">
            <summary>
            
            </summary>
        </member>
        <member name="T:IdeaBlade.Core.AuthorizationCode">
            <summary>
            For internal use only - may not exceed 3 bytes.
            </summary>
        </member>
        <member name="F:IdeaBlade.Core.AuthorizationCode.Error">
            <summary/>
        </member>
        <member name="T:IdeaBlade.Core.AuthHelper">
            <summary>
            Summary description for AuthHelper.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.AuthHelper.LoadRuntimeLicense(System.Boolean,System.Action{System.String,System.Exception})">
            <summary>
            Called by IdeaBladeConfig during initialization.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.AuthHelper.IsAuthorizedFor(IdeaBlade.Core.AuthorizationRight)">
            <summary>
            
            </summary>
            <param name="authorizationRight"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.AuthHelper.WarnIfNotAuthorizedFor(IdeaBlade.Core.AuthorizationRight)">
            <summary>
            returns true if authorized / false if not
            </summary>
            <param name="authorizationRight"></param>
        </member>
        <member name="M:IdeaBlade.Core.AuthHelper.SetErrorRegistration">
            <summary>
            
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.AuthHelper.ProductKeyInfo">
            <summary>
            
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.ProductKeyInfo.IsAuthorized(IdeaBlade.Core.AuthorizationRight)">
            <summary>
            
            </summary>
            <param name="authorizationRight"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.ProductKeyInfo.IsRevokedProductKey(System.String)">
            <summary>
            Returns true if product key has been revoked; false otherwise.
            </summary>
            <param name="productKey"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.ProductKeyInfo.XorGuid(System.Guid,System.Guid)">
            <summary>
            For internal use only.
            </summary>
            <param name="source"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.ProductKeyInfo.InterleaveBits(System.Byte[],System.Byte[])">
            <summary>
            For internal use only
            </summary>
            <param name="baseBytes"></param>
            <param name="injectBytes"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.ProductKeyInfo.ExtractInterleavedBits(System.Byte[],System.Int32,System.Boolean)">
            <summary>
            For internal use only.
            </summary>
            <param name="baseBytes"></param>
            <param name="numberOfBytes"></param>
            <param name="useOddBits"></param>
            <returns></returns>
        </member>
        <member name="P:IdeaBlade.Core.ProductKeyInfo.RevokedProductKeys">
            <summary>
            Gets a list of revoked product keys.
            </summary>
        </member>
        <member name="T:IdeaBlade.Core.IdeaBladeLicenseAttribute">
            <summary>
            An <see cref="T:System.Attribute"/> used by DevForce to mark your domain model 
            assemblies with license information.  
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.IdeaBladeLicenseAttribute.#ctor(System.String)">
            <summary>
            
            </summary>
            <param name="licenseKey"></param>
        </member>
        <member name="P:IdeaBlade.Core.IdeaBladeLicenseAttribute.LicenseKey">
            <summary>
            
            </summary>
        </member>
        <member name="T:IdeaBlade.Core.IdeaBladeGuidAttribute">
            <summary>
            An <see cref="T:System.Attribute"/> used by DevForce to mark your domain model 
            assemblies with license information.  
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.IdeaBladeGuidAttribute.#ctor(System.String)">
            <summary>
            Creates an instance of this class.
            </summary>
            <param name="guid"></param>
        </member>
        <member name="M:IdeaBlade.Core.IdeaBladeGuidAttribute.#ctor(System.String,System.String)">
            <summary>
            Creates an instance of this class.
            </summary>
            <param name="guid"></param>
            <param name="templateVersion"></param>
        </member>
        <member name="M:IdeaBlade.Core.IdeaBladeGuidAttribute.CheckTemplateVersion">
            <summary>
            Internal use only.
            </summary>
            <returns></returns>
            <remarks>
            If there is a mismatch between the template version obtained from your model and the current
            DevForce template version an exception will be thrown when using the EntityManager.
            </remarks>
        </member>
        <member name="F:IdeaBlade.Core.IdeaBladeGuidAttribute.IgnoreTemplateVersion">
            <summary>
            Can be used to bypass template version checking.
            </summary>
        </member>
        <member name="F:IdeaBlade.Core.IdeaBladeGuidAttribute.CurrentTemplateVersion">
            <summary>
            The current template version.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.IdeaBladeGuidAttribute.Guid">
            <summary>
            The Guid provided to this attribute.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.IdeaBladeGuidAttribute.TemplateVersion">
            <summary>
            The template version in use when the model was generated. 
            </summary>
        </member>
        <member name="T:IdeaBlade.Core.IdeaBladeLicenseException">
            <summary>
            Exception used for violation of product license.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.IdeaBladeLicenseException.#ctor">
            <summary>
            Initializes a new instance of the LicenseException class.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.IdeaBladeLicenseException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the LicenseException class.
            </summary>
            <param name="pMessage">A message added to describe the exception</param>
        </member>
        <member name="M:IdeaBlade.Core.IdeaBladeLicenseException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the LicenseException class.
            </summary>
            <param name="pMessage">A message added to describe the exception</param>
            <param name="pInnerException">An instance of Exception that describes the error that caused this exception</param>
        </member>
        <member name="T:IdeaBlade.Core.DomainServices.AuthorizationAttribute">
            <summary>
            Base class for authorization attributes.
            </summary>
            <remarks>
            This class may be extended to create custom authorization attributes.
            </remarks>
        </member>
        <member name="M:IdeaBlade.Core.DomainServices.AuthorizationAttribute.#ctor">
            <summary>
            Initializes a new instance of the class.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.DomainServices.AuthorizationAttribute.Authorize(System.Security.Principal.IPrincipal)">
            <summary>
            Perform authorization.
            </summary>
            <param name="principal"></param>
            <returns></returns>
        </member>
        <member name="T:IdeaBlade.Core.DomainServices.RequiresAuthenticationAttribute">
            <summary>
            Attribute used to decorate a method or class to indicate that the current user must
            be authenticated.
            </summary>
            <remarks>
            When the <b>RequiresAuthentication</b> attribute is applied to your entities the appropriate query or save <b>interceptor</b> will check the attribute 
            during authorization.  
            <para>
            The attribute can also be applied to methods., such as remote service methods, named query methods, and all POCO methods.
            </para>
            <para>
            If the user does not pass the authorization check, a <b>PersistenceSecurityException</b>
            is received on the client.
            </para>
            </remarks>  
        </member>
        <member name="M:IdeaBlade.Core.DomainServices.RequiresAuthenticationAttribute.Authorize(System.Security.Principal.IPrincipal)">
            <summary>
            Called prior to method invocation to determine if the user is authorized.
            </summary>
            <param name="principal"></param>
            <returns></returns>
        </member>
        <member name="T:IdeaBlade.Core.DomainServices.RequiresRolesAttribute">
            <summary>
            Attribute used to decorate a method or class to indicate that the current user must
            be in all of the indicated roles.
            </summary>
            <remarks>
            When the <b>RequiresRoles</b> attribute is applied to your entities the appropriate query or save <b>interceptor</b> will check the attribute 
            during authorization.  
            <para>
            The attribute can also be applied to methods., such as remote service methods, named query methods, and all POCO methods.
            </para>
            <para>
            If the user does not pass the authorization check, a <b>PersistenceSecurityException</b>
            is received on the client.
            </para>
            </remarks>
        </member>
        <member name="M:IdeaBlade.Core.DomainServices.RequiresRolesAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the class.
            </summary>
            <param name="role"></param>
        </member>
        <member name="M:IdeaBlade.Core.DomainServices.RequiresRolesAttribute.#ctor(System.String[])">
            <summary>
            Initializes a new instance of the class.
            </summary>
            <param name="roles"></param>
        </member>
        <member name="M:IdeaBlade.Core.DomainServices.RequiresRolesAttribute.Authorize(System.Security.Principal.IPrincipal)">
            <summary>
            Called prior to method invocation to determine if the user is authorized.
            </summary>
            <param name="principal"></param>
            <returns></returns>
        </member>
        <member name="P:IdeaBlade.Core.DomainServices.RequiresRolesAttribute.Roles">
            <summary>
            One or more roles in which the user must belong.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.DomainServices.AuthorizationHelperFns.GetAuthorizeType(System.Type)">
            <summary>
            Returns the appropriate authorization action for the method.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.DomainServices.AuthorizationHelperFns.GetAuthorizeFunction(System.Reflection.MethodInfo)">
            <summary>
            Returns the appropriate authorization action for the method.
            </summary>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="T:IdeaBlade.Core.BitList">
            <summary>
            Replacement for BitArray which in not available in SilverLight.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.BitList.#ctor(System.Int32)">
            <summary>
            Constructor.
            </summary>
            <param name="length"></param>
        </member>
        <member name="M:IdeaBlade.Core.BitList.#ctor(System.Collections.Generic.IEnumerable{System.Byte})">
            <summary>
            Constructor.
            </summary>
            <param name="bytes"></param>
        </member>
        <member name="M:IdeaBlade.Core.BitList.#ctor(System.Collections.Generic.IEnumerable{System.Boolean})">
            <summary>
            Constructor using a boolean for each bit.
            </summary>
            <param name="bools"></param>
        </member>
        <member name="M:IdeaBlade.Core.BitList.ToBytes">
            <summary>
            Convert to a byte array.
            </summary>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.BitList.BitsToByte(System.Collections.Generic.List{System.Boolean})">
            <summary>
            bits is an 8 element list of booleans
            </summary>
            <param name="bits"></param>
            <returns></returns>
        </member>
        <member name="T:IdeaBlade.Core.Cardinality">
             <summary>
             The number of elements in a set or the relationship between two sets.
            
            </summary>
        </member>
        <member name="F:IdeaBlade.Core.Cardinality.Zero">
             <summary>
             Zero elements.
            
            </summary>
        </member>
        <member name="F:IdeaBlade.Core.Cardinality.One">
             <summary>
             One element.
            
            </summary>
        </member>
        <member name="F:IdeaBlade.Core.Cardinality.MoreThanOne">
             <summary>
             More than one element.
            
            </summary>
        </member>
        <member name="F:IdeaBlade.Core.Cardinality.ZeroOrOne">
             <summary>
             Zero or one elements.
            
            </summary>
        </member>
        <member name="F:IdeaBlade.Core.Cardinality.ZeroOrMore">
             <summary>
             Zero or more elements.
            
            </summary>
        </member>
        <member name="F:IdeaBlade.Core.Cardinality.OneOrMore">
             <summary>
             One or more elements.
            
            </summary>
        </member>
        <member name="T:IdeaBlade.Core.ClientApplicationType">
            <summary>
            Indicates the type of client applications supported by the EntityServer.
            </summary>
        </member>
        <member name="F:IdeaBlade.Core.ClientApplicationType.UseLicense">
            <summary>
            Use a setting appropriate to the license.
            </summary>
        </member>
        <member name="F:IdeaBlade.Core.ClientApplicationType.WinClient">
            <summary>
            Standard .NET client applications.
            </summary>
        </member>
        <member name="F:IdeaBlade.Core.ClientApplicationType.Silverlight">
            <summary>
            Silverlight client applications.
            </summary>
        </member>
        <member name="F:IdeaBlade.Core.ClientApplicationType.Metro">
            <summary>
            Metro client applications.
            </summary>
        </member>
        <member name="F:IdeaBlade.Core.ClientApplicationType.All">
            <summary>
            All client applications.
            </summary>
        </member>
        <member name="T:IdeaBlade.Core.ClientApplicationTypeExtensions">
            <summary>
            Static extension methods for the <see cref="T:IdeaBlade.Core.ClientApplicationType"/> enumeration.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.ClientApplicationTypeExtensions.SupportsSilverlight(IdeaBlade.Core.ClientApplicationType)">
            <summary>
            Returns whether Silverlight applications are supported.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.ClientApplicationTypeExtensions.SupportsMetro(IdeaBlade.Core.ClientApplicationType)">
            <summary>
            Returns whether Metro applications are supported.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.ClientApplicationTypeExtensions.SupportsStandard(IdeaBlade.Core.ClientApplicationType)">
            <summary>
            Returns whether standard WinClient and ASP.NET applications are supported.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="T:IdeaBlade.Core.CodingFns">
            <summary>
            Helper class containing encoding / decoding and bitstream functions.
            </summary>
        </member>
        <member name="F:IdeaBlade.Core.CodingFns.PaddingChar">
            <summary>
            
            </summary>
        </member>
        <member name="F:IdeaBlade.Core.CodingFns.EncodingTable">
            <summary>
            
            </summary>
        </member>
        <member name="F:IdeaBlade.Core.CodingFns.NonBase64Char">
            <summary>
            
            </summary>
        </member>
        <member name="F:IdeaBlade.Core.CodingFns.EOF">
            <summary>
            
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.CodingFns.EncodeBase64(System.Byte[])">
            <summary>
            Encodes a byte array as a string.
            </summary>
            <param name="bytes">A byte array</param>
            <returns>The encoded string</returns>
        </member>
        <member name="M:IdeaBlade.Core.CodingFns.DecodeBase64(System.String)">
            <summary>
            Decodes a string back into a byte array.
            </summary>
            <param name="chars">The string to decode</param>
            <returns>The decoded byte array</returns>
        </member>
        <member name="M:IdeaBlade.Core.CodingFns.GetOctets(System.Int32,System.Byte[],System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            
            </summary>
            <param name="pIndex"></param>
            <param name="pBytes"></param>
            <param name="pX"></param>
            <param name="pY"></param>
            <param name="pZ"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.CodingFns.ConvertOctets(System.Int32,System.Int32,System.Int32,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            
            </summary>
            <param name="pX"></param>
            <param name="pY"></param>
            <param name="pZ"></param>
            <param name="pA"></param>
            <param name="pB"></param>
            <param name="pC"></param>
            <param name="pD"></param>
        </member>
        <member name="M:IdeaBlade.Core.CodingFns.GetSextets(System.Int32,System.String,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            
            </summary>
            <param name="pIndex"></param>
            <param name="pChars"></param>
            <param name="pA"></param>
            <param name="pB"></param>
            <param name="pC"></param>
            <param name="pD"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.CodingFns.GetSextet(System.Int32@,System.String)">
            <summary>
            
            </summary>
            <param name="pIndex"></param>
            <param name="pChars"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.CodingFns.ConvertSextets(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            
            </summary>
            <param name="pA"></param>
            <param name="pB"></param>
            <param name="pC"></param>
            <param name="pD"></param>
            <param name="pX"></param>
            <param name="pY"></param>
            <param name="pZ"></param>
        </member>
        <member name="M:IdeaBlade.Core.CodingFns.CalcDecodingTable(System.String)">
            <summary>
            
            </summary>
            <param name="pEncodingTable"></param>
            <returns></returns>
        </member>
        <member name="F:IdeaBlade.Core.CodingFns.DecodingTable">
            <summary>
            
            </summary>
        </member>
        <member name="T:IdeaBlade.Core.Composition.BaseCompositionContextResolver">
            <summary>
            Abstract <see cref="T:IdeaBlade.Core.Composition.ICompositionContextResolver"/> that automatically registers any statically defined 
            <see cref="T:IdeaBlade.Core.Composition.CompositionContext">CompositionContexts</see> found within the class. 
            </summary>
            <remarks>
            If you subclass the <b>BaseCompositionContextResolver</b> and provide static field definitions for your custom
            <see cref="T:IdeaBlade.Core.Composition.CompositionContext">CompositionContexts</see>, DevForce will automatically find and register these
            contexts as needed, and you will not need to implement the <see cref="M:IdeaBlade.Core.Composition.BaseCompositionContextResolver.GetCompositionContext(System.String)"/> method.
            You can still use <b>GetCompositionContext</b> to dynamically construct a <see cref="T:IdeaBlade.Core.Composition.CompositionContext"/>
            for the specified name, but there is no need to do so if all of your composition contexts
            can be defined statically.  
            </remarks>
            <example>
        <code lang="C#">
           <![CDATA[
 // Sample BaseCompositionContextResolver sub-type providing static fields defining CompositionContexts.
 public class CompositionContextResolver : BaseCompositionContextResolver {
 
   public static CompositionContext Mock = new CompositionContext("MyMock", true,
     typeof(MockEntityServerSaveInterceptor), typeof(MockEntityServerQueryInterceptor));
 }
 
 // Sample class - note it is marked as not discoverable so that standard MEF
 // composition will not find it.
 [PartNotDiscoverable]
 public class MockEntityServerQueryInterceptor : EntityServerQueryInterceptor {

    protected override bool ExecuteQuery() {
       throw new InvalidOperationException();
    }
 }
 [PartNotDiscoverable]
 public class MockEntityServerSaveInterceptor : EntityServerSaveInterceptor {

    protected override bool  ExecuteSave() {
       throw new InvalidOperationException();
    }
 }
         ]]>
        
        </code>
      </example>
        </member>
        <member name="T:IdeaBlade.Core.Composition.ICompositionContextResolver">
            <summary>
            Interface to be implemented when a custom <see cref="T:IdeaBlade.Core.Composition.CompositionContext"/> is used.
            <seealso cref="T:IdeaBlade.Core.Composition.BaseCompositionContextResolver"/>
            </summary>
            <remarks>
            You can implement a custom <b>ICompositionContextResolver</b> to return your custom
            <see cref="T:IdeaBlade.Core.Composition.CompositionContext"/> implementation(s).
            </remarks>
            <example>
        <code lang="C#">

          // Sample ICompositionContextResolver used when using one or more custom contexts.
          public class CompositionContextResolver : ICompositionContextResolver {

             public static CompositionContext myMock = new CompositionContext("MyMock", true, 
               typeof(MockEntityServerSaveInterceptor), typeof(MockEntityServerQueryInterceptor));

             public CompositionContext GetCompositionContext(string compositionContextName) {

               if (compositionContextName == myMock.Name) {
                  return myMock;
               } else {
                 return null;
               }
             }
          }
          // Sample class - note it is marked as not discoverable so that standard MEF
          // composition will not find it.
          [PartNotDiscoverable]
          public class MockEntityServerQueryInterceptor : EntityServerQueryInterceptor {

             protected override bool ExecuteQuery() {
                throw new InvalidOperationException();
             }
          }
          [PartNotDiscoverable]
          public class MockEntityServerSaveInterceptor : EntityServerSaveInterceptor {

             protected override bool  ExecuteSave() {
                throw new InvalidOperationException();
             }
          }
        </code>
      </example>
        </member>
        <member name="M:IdeaBlade.Core.Composition.ICompositionContextResolver.GetCompositionContext(System.String)">
            <summary>
            Called by DevForce to retrieve a CompositionContext having the specified name.
            </summary>
            <param name="compositionContextName"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Composition.BaseCompositionContextResolver.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.Composition.BaseCompositionContextResolver.GetCompositionContext(System.String)">
            <summary>
            Called by DevForce to retrieve a <see cref="T:IdeaBlade.Core.Composition.CompositionContext"/> having the specified name.
            </summary>
            <param name="compositionContextName"></param>
            <returns></returns>
            <remarks>
            If your code will not resolve the specified context name you can allow the base implementation to try.  If the name cannot be resolved by any resolver
            then an exception will be thrown.
            <para>
            An <b>InvalidOperationException</b> will be thrown by DevForce if the name of the CompositionContext returned does not match the <paramref name="compositionContextName"/> parameter.
            If null is returned and the CompositionContext hasn't been otherwise registered then an <b>IdeaBladeException</b> is thrown.
            </para>
            </remarks>
        </member>
        <member name="T:IdeaBlade.Core.Composition.CompositionExportKey">
            <summary>
            ExportMetadata attribute key names.
            </summary>
        </member>
        <member name="F:IdeaBlade.Core.Composition.CompositionExportKey.IsFake">
            <summary>
            Defines the ExportMetadata name which indicates the exported type should be used with a fake context.
            </summary>
        </member>
        <member name="T:IdeaBlade.Core.Composition.CompositionContext">
            <summary>
            Determines a context for MEF discovery and composition.
            </summary>
            <remarks>
            The <b>CompositionContext</b> is used to set the context in which MEF composition occurs. MEF (the Managed 
            Extensibility Framework from Microsoft) is used by DevForce to provide runtime extensibility.  
            DevForce uses MEF to look for and instantiate custom implementations of the <b>IIdGenerator</b>, <b>IVerifierProvider</b>,
            <b>EntityServerQueryInterceptor</b> and all other DevForce interfaces and base classes intended
            for customization.  Using a custom composition context you can control this behavior.
            <para>
            By default the <b>Default</b> context is used, which means that no special type or metadata filtering is performed.  DevForce also provides a <b>Fake</b> context
            which is useful during testing to provide standardized fake implementations for 1) Id generation with the <b>FakeIdGenerator</b>;
            2) an in-memory database with the <b>EntityServerFakeBackingStore</b>; 3) query functionality with the <b>EdmQueryExecutorFake</b>;
            and 4) save functionality with the <b>EdmSaveExecutorFake</b>.
            </para>
            <para>
            You determine the composition context in use when you construct an <b>EntityManager</b> by optionally passing the name of the context wanted.  When using
            any context other than the <see cref="F:IdeaBlade.Core.Composition.CompositionContext.Default"/> and <see cref="F:IdeaBlade.Core.Composition.CompositionContext.Fake"/> contexts provided, you can implement a custom <see cref="T:IdeaBlade.Core.Composition.ICompositionContextResolver"/> 
            to register and return the CompositionContext instance wanted. If you do not implement a custom resolver your custom contexts can also
            be registered automatically by the <see cref="T:IdeaBlade.Core.Composition.BaseCompositionContextResolver"/>.  When using a custom context you can determine the types to be exported for MEF composition, 
            and include custom metadata filtering.
            </para>
            </remarks>
        </member>
        <member name="F:IdeaBlade.Core.Composition.CompositionContext.Fake">
            <summary>
            The "fake" composition context.
            </summary>
            <remarks>
            The <b>Fake</b> context will filter for "fake" implementations of exported types.  Any implementation which provides 
            export metadata setting "IsFake" to true will be used by the Fake context.  For example, the <b>FakeIdGenerator</b> is an
            implementation of the <b>IIdGenerator</b> interface which can be used to provide fake Id generation during testing.
            <para>
            The <b>Fake</b> context uses the <b>EntityServerFakeBackingStore</b> as its backing store, and uses fake query and save
            executors (note these are not the same thing as the EntityServerQueryInterceptor and EntityServerSaveInterceptor) 
            to perform standard DevForce query and save processing against a fake backing store.
            </para>
            </remarks>
            <example>
        <code lang="C#"> <![CDATA[
   public void SampleTestWithFakes() {

      // Sample showing use of the Fake composition context.
      // All queries and saves are processed by the EntityServerFakeBackingStore.
      var em = new DomainModelEntityManager(compositionContextName: CompositionContext.Fake.Name);

      // Create and save a new entity.
      var cust = new Customer() { CompanyName = "TestCo", Address = "123 Elm St" };
      em.AddEntity(cust);
      em.SaveChanges();

      // Clear the EM cache.
      em.Clear();

      // Now query from the "server" - in this case the EntityServerFakeBackingStore.
      var customers = em.Customers.ToList();
   }
          ]]>
        </code>
      </example>
        </member>
        <member name="F:IdeaBlade.Core.Composition.CompositionContext.Default">
            <summary>
            The default composition context.
            </summary>
            <remarks>w
            The default context performs no filtering other than to exclude types marked as fakes.  This context is used when
            a context has not been specifically requested when constructing an <b>EntityManager</b>.
            </remarks>
        </member>
        <member name="M:IdeaBlade.Core.Composition.CompositionContext.GetByName(System.String)">
            <summary>
            Returns the CompositionContext with the specified name.
            </summary>
            <param name="compositionContextName"></param>
            <returns></returns>
            <remarks>
            You can implement a custom <see cref="T:IdeaBlade.Core.Composition.ICompositionContextResolver"/> if you are not using either the fake or default contexts.
            If you have implemented multiple resolvers the first to resolve the name "wins".
            <para>
            If the <paramref name="compositionContextName"/> passed to this method is null or an empty string, the standard <see cref="F:IdeaBlade.Core.Composition.CompositionContext.Default"/> composition
            context is returned.
            </para>
            <para>
            An exception is thrown if the name cannot be resolved.
            </para>
            </remarks>
            <exception cref="T:IdeaBlade.Core.IdeaBladeException">Thrown if a CompositionContext with the specified name is not found</exception>
        </member>
        <member name="M:IdeaBlade.Core.Composition.CompositionContext.#ctor(System.String,System.Boolean,System.Type[])">
            <summary>
            Create a CompositionContext with the given name, fake filtering, and types specified.
            </summary>
            <param name="name">The name of the context</param>
            <param name="isFake">Whether the context will do fake filtering</param>
            <param name="types">The types which can be instantiated within this context</param>
            <remarks>
            The <see cref="M:IdeaBlade.Core.Composition.CompositionContext.WithGenerator(System.Type)"/> method is called for each of the types provided.
            </remarks>
        </member>
        <member name="M:IdeaBlade.Core.Composition.CompositionContext.WithName(System.String)">
            <summary>
            Creates a new CompositionContext from the current context and assigns the specified name.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Composition.CompositionContext.WithGenerator(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Creates a new CompositionContext from the current context with filtering for the types specified.
            </summary>
            <param name="types"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentException">Thrown if any type does not have a composable base type or interface</exception>
            <example>
        <code lang="C#">
          <![CDATA[
public class CompositionContextResolver : BaseCompositionContextResolver {
  // Creates a new context from the Default context, indicating that the
  // specified types should be used whenever an export
  // matching its interface/base class is requested.
  CompositionContext Mock = CompositionContext.Default
    .WithGenerator(new[] {
     typeof(MockEntityServerQueryInterceptor),
     typeof(MockEntityServerSaveInterceptor)
    })
    .WithName("Mock");
}

[PartNotDiscoverable]
public class MockEntityServerQueryInterceptor : EntityServerQueryInterceptor {

  protected override bool ExecuteQuery() {
    throw new InvalidOperationException();
  }
}
[PartNotDiscoverable]
public class MockEntityServerSaveInterceptor : EntityServerSaveInterceptor {

  protected override bool ExecuteSave() {
    throw new InvalidOperationException();
  }
}
]]>
        </code>
      </example>
        </member>
        <member name="M:IdeaBlade.Core.Composition.CompositionContext.WithGenerator(System.Type)">
            <summary>
            Creates a new CompositionContext from the current context with filtering for the type specified.
            </summary>
            <param name="type"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentException">Thrown if the type does not have a composable base type or interface</exception>
            <example>
        <code lang="C#">
          <![CDATA[
public class CompositionContextResolver : BaseCompositionContextResolver {
  // Creates a new context from the Default context, indicating that the
  // specified type should be used whenever an export
  // matching its interface/base class is requested.
  CompositionContext Mock = CompositionContext.Default
    .WithGenerator(typeof(MockEntityServerQueryInterceptor))
    .WithName("Mock");
}

[PartNotDiscoverable]
public class MockEntityServerQueryInterceptor : EntityServerQueryInterceptor {
  protected override bool ExecuteQuery() {
    throw new InvalidOperationException();
  }
}          
         ]]>
        </code>
      </example>
        </member>
        <member name="M:IdeaBlade.Core.Composition.CompositionContext.WithGenerator(System.Type,System.Func{System.Object})">
            <summary>
            Creates a new CompositionContext from the current context with filtering for the type specified.
            </summary>
            <param name="type"></param>
            <param name="generatorFunc">A func which returns an instance of the type</param>
            <returns></returns>
            <example>
        <code lang="C#">
          <![CDATA[
 public class CompositionContextResolver : BaseCompositionContextResolver {
   // Creates a new context from the Default context, indicating that when
   // an EntityServerQueryInterceptor is needed it can be constructed
   // via the action provided.  
   CompositionContext Mock = CompositionContext.Default
     .WithGenerator(typeof(EntityServerQueryInterceptor), () => new MockEntityServerQueryInterceptor())
     .WithName("Mock");
 }
 
 [PartNotDiscoverable]
 public class MockEntityServerQueryInterceptor : EntityServerQueryInterceptor {
   protected override bool ExecuteQuery() {
     throw new InvalidOperationException();
   }
 }
        ]]>
</code>
      </example>
        </member>
        <member name="M:IdeaBlade.Core.Composition.CompositionContext.WithFilter(System.Func{System.ComponentModel.Composition.Primitives.Export,System.Boolean})">
            <summary>
            Creates a new CompositionContext from the current context with the specified "global" metadata filter.
            </summary>
            <param name="exportFilter"></param>
            <returns></returns>
            <remarks>
            If you've decorated your classes with the <b>ExportMetadata</b> attribute to provide
            metadata about the exported type you can filter for these types in your CompositionContext
            by providing an export filter.  Use <see cref="M:IdeaBlade.Core.Composition.CompositionContext.BuildExportFilter(System.String,System.Object)"/> to create the filter.
            <para>
            A global filter is one which applies to discovery of all extensible types.
            </para>
            </remarks>
            <example>
        <code lang="C#">
          <![CDATA[
public class CompositionContextResolver : BaseCompositionContextResolver {

  public override CompositionContext GetCompositionContext(string compositionContextName) {

    // Creates a new context from the Default context, with global metadata filtering.
    if (compositionContextName == "Mock") {
      var filter = CompositionContext.BuildExportFilter("IsMock", true);
      return CompositionContext.Default
         .WithFilter(filter)
         .WithName("Mock");
    } else {
      return base.GetCompositionContext(compositionContextName);
    }
  }
}

[InheritedExport(typeof(EntityServerQueryInterceptor))]
[ExportMetadata("IsMock", true)]
public class MockEntityServerQueryInterceptor : EntityServerQueryInterceptor {

  protected override bool ExecuteQuery() {
    throw new InvalidOperationException();
  }
}          
          ]]>
        </code>
      </example>
        </member>
        <member name="M:IdeaBlade.Core.Composition.CompositionContext.WithTypeFilter(System.Type,System.Func{System.ComponentModel.Composition.Primitives.Export,System.Boolean})">
            <summary>
            Creates a new CompositionContext from the current context with a metadata filter for the type specified.
            </summary>
            <param name="type"></param>
            <param name="exportFilter">A filter for exported metadata</param>
            <returns></returns>
            <remarks>
            If you've decorated your classes with the <b>ExportMetadata</b> attribute to provide
            metadata about the exported type you can filter for these types in your CompositionContext
            by providing an export filter.  Use <see cref="M:IdeaBlade.Core.Composition.CompositionContext.BuildExportFilter(System.String,System.Object)"/> to create the filter.
            <para>
            You can use a type filter instead of a global filter if the metadata applies only to a specific type.
            </para>
            </remarks>
        </member>
        <member name="M:IdeaBlade.Core.Composition.CompositionContext.GetExportedInstance(System.Type)">
            <summary>
            For internal use.  Used during composition to return an exported value.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Composition.CompositionContext.GetExportedInstances(System.Type)">
            <summary>
            For internal use.  Used during composition to return exported values.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Composition.CompositionContext.GetTypeFilter(System.Type)">
            <summary>
            For internal use.  Used during composition to return the export filter for the type.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Composition.CompositionContext.BuildExportFilter(System.String,System.Object)">
            <summary>
            Adds a filter for the specified <see cref="T:System.ComponentModel.Composition.ExportMetadataAttribute">ExportMetadata</see> key and value.
            </summary>
            <param name="metadataKey"></param>
            <param name="keyValue"></param>
            <returns></returns>
            <remarks>
            If you've decorated your classes with the <b>ExportMetadata</b> attribute to provide
            metadata about the exported type you can filter for these types in your CompositionContext
            by providing an export filter.  Use <see cref="M:IdeaBlade.Core.Composition.CompositionContext.WithFilter(System.Func{System.ComponentModel.Composition.Primitives.Export,System.Boolean})"/> or <see cref="M:IdeaBlade.Core.Composition.CompositionContext.WithTypeFilter(System.Type,System.Func{System.ComponentModel.Composition.Primitives.Export,System.Boolean})"/> to add the filter to the context.
            </remarks>
        </member>
        <member name="M:IdeaBlade.Core.Composition.CompositionContext.AndFilters(System.Func{System.ComponentModel.Composition.Primitives.Export,System.Boolean},System.Func{System.ComponentModel.Composition.Primitives.Export,System.Boolean})">
            <summary>
            Ands two export filters.
            </summary>
            <param name="filter1"></param>
            <param name="filter2"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Composition.CompositionContext.GetExportedInstanceFuncs(System.Type,System.Boolean)">
            <summary>
            Internal use.  Returns the generatorFuncs defined for the type.
            </summary>
            <param name="type"></param>
            <param name="createIfNotFound"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Composition.CompositionContext.AddGenerator(System.Type)">
            <summary>
            Creates and adds a constructor function for the type to the CompositionContext.
            </summary>
            <param name="type"></param>
            <exception cref="T:System.ArgumentException">Thrown if the specified type does not have a composable base type or interface</exception>
        </member>
        <member name="M:IdeaBlade.Core.Composition.CompositionContext.AddGenerator(System.Type,System.Type,System.Func{System.Object})">
            <summary>
            Adds the specified constructor function for the type to the CompositionContext.
            </summary>
            <param name="contractType"></param>
            <param name="instanceType"></param>
            <param name="instanceFunc"></param>
        </member>
        <member name="M:IdeaBlade.Core.Composition.CompositionContext.Equals(System.Object)">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Composition.CompositionContext.GetHashCode">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:IdeaBlade.Core.Composition.CompositionContext.Name">
            <summary>
            Returns the name of the context.
            </summary>
            <exception cref="T:IdeaBlade.Core.IdeaBladeException">Thrown by the getter if the CompositionContext is unnamed.</exception>
        </member>
        <member name="P:IdeaBlade.Core.Composition.CompositionContext.IsNamed">
            <summary>
            Indicates if the CompositionContext has a name.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.Composition.CompositionContext.IsFake">
            <summary>
            Returns whether fake filtering is performed.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.Composition.CompositionContext.RegisteredContexts">
            <summary>
            Returns a list of all currently registered contexts.
            </summary>
        </member>
        <member name="T:IdeaBlade.Core.Composition.CompositionHost">
            <summary>
            Encapsulates the Managed Extensibility Framework composition container used by DevForce.
            </summary>
            <remarks>
            Use <see cref="P:IdeaBlade.Core.Composition.CompositionHost.Instance">CompositionHost.Instance</see> to reference the singleton
            used within DevForce.  The <b>CompositionHost</b> is used to manage DevForce
            extensibility via imports and exports. You do not need to use the 
            CompositionHost for MEF extensibility within your own application, although
            you can.  You will generally not need to directly call methods on the CompositionHost
            since DevForce will handle discovery as needed.
            <para>
            By default, DevForce will create a catalog using all assemblies in a folder, or for 
            Silverlight applications all assemblies in the XAP.  In Silverlight applications you can add dynamically loaded
            content using one of the <b>Add(Uri)</b> overloads.
            </para>
            <para>
            You can modify default search behaviors by modifying the <see cref="P:IdeaBlade.Core.Composition.CompositionHost.SearchPatterns"/> and <see cref="P:IdeaBlade.Core.Composition.CompositionHost.IgnorePatterns"/>, and in
            desktop application the <see cref="!:SearchFolders"/> and <see cref="T:System.IO.SearchOption"/> can be set. 
            </para>
            </remarks>
        </member>
        <member name="M:IdeaBlade.Core.Composition.CompositionHost.Add(System.ComponentModel.Composition.Primitives.ComposablePartCatalog)">
            <summary>
            Add dynamic content to the container.  
            </summary>
            <param name="catalog"></param>
            <remarks>
            This is usually used to add a <b>DeploymentCatalog</b> to the container, although
            an <b>AggregateCatalog</b> or <b>AssemblyCatalog</b> will be processed also.
            The catalog is used to recompose the internal "parts" catalog.  The <see cref="E:IdeaBlade.Core.Composition.CompositionHost.Recomposed"/>
            event is fired to indicate that dynamic content has been loaded.
            </remarks>
            <example>
        <code lang="C#"> <![CDATA[
        // If using MEF DeploymentCatalog, add to the DevForce CompositionHost after download.
        public void AddXap(string uri) {
            DeploymentCatalog catalog;
            catalog = new DeploymentCatalog(uri);
            catalog.DownloadAsync();
            catalog.DownloadCompleted += new EventHandler<System.ComponentModel.AsyncCompletedEventArgs>(catalog_DownloadCompleted);
        }

        private void catalog_DownloadCompleted(object sender, System.ComponentModel.AsyncCompletedEventArgs e) {
          IdeaBlade.Core.Composition.CompositionHost.Add(sender as DeploymentCatalog);
        }
          ]]>
        </code>
      </example>
        </member>
        <member name="M:IdeaBlade.Core.Composition.CompositionHost.Add(System.Uri)">
            <summary>
            Add dynamic content to the container.
            </summary>
            <param name="uri"></param>
            <remarks>
            A <see cref="T:IdeaBlade.Core.DynamicXap"/> is used to download the content at the URI provided.  If the XAP was already downloaded
            it will have been cached by the browser.
            The content is used to recompose the internal "parts" catalog.  The <see cref="E:IdeaBlade.Core.Composition.CompositionHost.Recomposed"/>
            event is fired to indicate that dynamic content has been loaded.
            </remarks>
            <example>
        <code lang="C#"> <![CDATA[
        <code lang="C#">
          // If using Prism, when the module downloads tell DevForce CompositionHost.
          public void Download(string moduleName) {
             this.ModuleManager.LoadModuleCompleted += this.ModuleManager_LoadModuleCompleted;
             this.ModuleManager.LoadModule(moduleName);
          }
          private void ModuleManager_LoadModuleCompleted(object sender, LoadModuleCompletedEventArgs e) {
             var uri = new Uri(e.ModuleInfo.Ref, UriKind.Relative);
             IdeaBlade.Core.Composition.CompositionHost.Add(uri);
          }        
                ]]> </code>
      </example><example>
        <code lang="C#">
          <![CDATA[
        <code lang="C#">
          // If using Prism, when the module downloads tell DevForce CompositionHost.
          public void Download(string moduleName) {
             this.ModuleManager.LoadModuleCompleted += this.ModuleManager_LoadModuleCompleted;
             this.ModuleManager.LoadModule(moduleName);
          }
          private void ModuleManager_LoadModuleCompleted(object sender, LoadModuleCompletedEventArgs e) {
             var uri = new Uri(e.ModuleInfo.Ref, UriKind.Relative);
             IdeaBlade.Core.Composition.CompositionHost.Add(uri);
          }        
                ]]>
        </code>
      </example>
        </member>
        <!-- Badly formed XML comment ignored for member "M:IdeaBlade.Core.Composition.CompositionHost.Add(IdeaBlade.Core.DynamicXap)" -->
        <member name="M:IdeaBlade.Core.Composition.CompositionHost.Refresh">
            <summary>
            Refreshes main catalog after changes to search or ignore patterns.
            </summary>
            <remarks>
            If you modify the static search or ignore properties after the CompositionHost has initialized
            you can call <b>Refresh</b> to reinitialize the catalogs.  Calling this method
            before initialization causes initialization to occur.
            <para>
            Do not call <b>Refresh</b> when adding dynamic content, as it will rebuild the internal
            "parts" catalog from non-dynamically loaded content only.
            </para>
            </remarks>
        </member>
        <member name="M:IdeaBlade.Core.Composition.CompositionHost.GetDefaultExportedFunc``1(System.String)">
            <summary>
            Return the exported function.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="contractName"></param>
            <returns></returns>
            <remarks>
            Throws if no match.
            </remarks>
        </member>
        <member name="M:IdeaBlade.Core.Composition.CompositionHost.GetExportedInstance``1(System.Boolean,System.ComponentModel.Composition.Primitives.ImportCardinality,System.ComponentModel.Composition.CreationPolicy,IdeaBlade.Core.Composition.CompositionContext)">
            <summary>
            Returns an exported instance matching the import definition for the type.
            </summary>
            <typeparam name="T">Type defining the contract</typeparam>
            <param name="acceptDefault">Whether the default DevForce implementation can be used when a custom implementation is not found.</param>
            <param name="cardinality">Required cardinality</param>
            <param name="policy">Creation policy</param>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Composition.CompositionHost.GetExportedInstance(System.Type,System.Boolean,System.ComponentModel.Composition.Primitives.ImportCardinality,System.ComponentModel.Composition.CreationPolicy,IdeaBlade.Core.Composition.CompositionContext)">
            <summary>
            Returns an exported instance matching the import definition for the type.
            </summary>
            <param name="exportedType">Type defining the contract</param>
            <param name="acceptDefault">Whether the default DevForce implementation can be used when a custom implementation is not found.</param>
            <param name="cardinality">Required cardinality</param>
            <param name="policy">Creation policy</param>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Composition.CompositionHost.GetNewExportedInstance``1(System.Boolean,IdeaBlade.Core.Composition.CompositionContext)">
            <summary>
            Returns a new exported instance matching the import definition for the type.
            </summary>
            <typeparam name="T">Type defining the contract</typeparam>
            <param name="acceptDefault">Whether the default DevForce implementation can be used when a custom implementation is not found.</param>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Composition.CompositionHost.GetDefaultInstance``1(IdeaBlade.Core.Composition.CompositionContext)">
            <summary>
            Returns the default DevForce implementation for the import definition.
            </summary>
            <typeparam name="T">Type defining the contract</typeparam>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Composition.CompositionHost.GetDefaultInstance(System.Type,IdeaBlade.Core.Composition.CompositionContext)">
            <summary>
            Returns the default DevForce implementation for the import definition.
            </summary>
            <param name="exportedType">Type defining the contract</param>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Composition.CompositionHost.GetNewDefaultInstance``1(IdeaBlade.Core.Composition.CompositionContext)">
            <summary>
            Returns a new default DevForce implementation for the import definition.
            </summary>
            <typeparam name="T">Type defining the contract</typeparam>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Composition.CompositionHost.GetNewDefaultInstance(System.Type,IdeaBlade.Core.Composition.CompositionContext)">
            <summary>
            Returns a new default DevForce implementation for the import definition.
            </summary>
            <param name="exportedType">Type defining the contract</param>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Composition.CompositionHost.GetExportedInstances``1(System.Boolean,System.ComponentModel.Composition.CreationPolicy,IdeaBlade.Core.Composition.CompositionContext)">
            <summary>
             Returns any exported instances matching the import definition for the type.
            </summary>
            <typeparam name="T">Type defining the contract</typeparam>
            <param name="acceptDefault">Whether the default DevForce implementation can be used when a custom implementation is not found.</param>
            <param name="policy">Creation policy</param>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Composition.CompositionHost.GetExportedInstances(System.Type,System.Boolean,System.ComponentModel.Composition.CreationPolicy,IdeaBlade.Core.Composition.CompositionContext)">
            <summary>
             Returns any exported instances matching the import definition for the type.
            </summary>
            <param name="exportedType">Type defining the contract</param>
            <param name="acceptDefault">Whether the default DevForce implementation can be used when a custom implementation is not found.</param>
            <param name="policy">Creation policy</param>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Composition.CompositionHost.GetNewExportedInstances``1(System.Boolean,IdeaBlade.Core.Composition.CompositionContext)">
            <summary>
             Returns any new exported instances matching the import definition for the type.
            </summary>
            <typeparam name="T">Type defining the contract</typeparam>
            <param name="acceptDefault">Whether the default DevForce implementation can be used when a custom implementation is not found.</param>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Composition.CompositionHost.GetNewExportedInstances(System.Type,System.Boolean,IdeaBlade.Core.Composition.CompositionContext)">
            <summary>
             Returns any new exported instances matching the import definition for the type.
            </summary>
            <param name="exportedType">Type defining the contract</param>
            <param name="acceptDefault">Whether the default DevForce implementation can be used when a custom implementation is not found.</param>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Composition.CompositionHost.GetImportDefSingle(System.Type,IdeaBlade.Core.Composition.CompositionHost.CheckDefault,System.ComponentModel.Composition.Primitives.ImportCardinality,System.ComponentModel.Composition.CreationPolicy,IdeaBlade.Core.Composition.CompositionContext)">
            <summary>
            does initial discovery and logging - will only get called once for any unique collection of parameters.
            Note the ImportDef returned - subsequent calls for the export will not go thru this logic.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.Composition.CompositionHost.Instance">
            <summary>
            Singleton instance.
            </summary>
        </member>
        <member name="E:IdeaBlade.Core.Composition.CompositionHost.Recomposed">
            <summary>
            Raised when the composition container is modified after initialization.
            </summary>
            <remarks>
            This event is used internally by DevForce to handle recomposition after dynamic content is added to the container,
            but your application can also listen for <b>Recomposed</b> events.
            <para>
            Raised when dynamic content is added via one of the <b>Add(Uri)</b> methods, and also after a <see cref="M:IdeaBlade.Core.Composition.CompositionHost.Refresh"/>.
            </para>
            </remarks>
        </member>
        <member name="P:IdeaBlade.Core.Composition.CompositionHost.Container">
            <summary>
            Returns the Main (developer extensions) CompositionContainer in use.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.Composition.CompositionHost.DefaultContainer">
            <summary>
            Returns the Default CompositionContainer in use.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.Composition.CompositionHost.ProbeAssemblies">
            <summary>
            Returns the assemblies which are included in the container and available for discovery.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.Composition.CompositionHost.ProbeAssemblyNames">
            <summary>
            Returns the names of all assemblies which are included in the catalog and available for discovery.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.Composition.CompositionHost.SearchPatterns">
            <summary>
            Search patterns to use when looking for assemblies for the PartsCatalog.
            </summary>
            <remarks>
            For ASP.NET and Silverlight applications the default is "*.dll"; for other applications
            the default is "*.dll" and "*.exe".
            <para>
            You may add and remove patterns from the list to suit your needs. 
            You may supply a Regex pattern or a simple wildcard pattern. If you supply a simple pattern
            it will be converted to a Regex pattern.  The conversion escapes the "." (dot) character, and 
            changes "*" (wildcard) to ".*".
            </para>
            <para>
            Use the <b>SearchPatterns</b> and <see cref="P:IdeaBlade.Core.Composition.CompositionHost.IgnorePatterns"/> to improve the startup time of your application.  The only
            assemblies which must be probed for discovery purposes are those containing your entity models, extensible components
            and known types.  If many unnecessary assemblies are probed the startup time of your application will suffer.  However,
            if assemblies which should be probed are not, your application will not work correctly.
            </para>
            <para>
            <b>SearchPatterns</b> are applied before <see cref="P:IdeaBlade.Core.Composition.CompositionHost.IgnorePatterns"/>.  
            </para>
            </remarks>
            <example>
        <code lang="C#">
          <![CDATA[
        <code lang="C#">
          // At application startup
          CompositionHost.SearchPatterns.Clear();
          CompositionHost.SearchPatterns.Add("DomainModel.dll");  //  Add whatever assemblies you need probed
                ]]>

        </code>
      </example>
        </member>
        <member name="P:IdeaBlade.Core.Composition.CompositionHost.IgnorePatterns">
            <summary>
            Patterns used to ignore assemblies when building the PartsCatalog.
            </summary>
            <remarks>
            IdeaBlade, System and Microsoft assemblies are automatically ignored, as well as assemblies from many 3rd party component suites.
            <para>
            You may add and remove patterns from the list to suit your needs. 
            You may supply a Regex pattern or a simple wildcard pattern. If you supply a simple pattern
            it will be converted to a Regex pattern.  The conversion escapes the "." (dot) character, and 
            changes "*" (wildcard) to ".*".
            </para>
            <para>
            Use the <see cref="P:IdeaBlade.Core.Composition.CompositionHost.SearchPatterns"/> and <b>IgnorePatterns</b> to improve the startup time of your application.  The only
            assemblies which must be probed for discovery purposes are those containing your entity models, extensible components
            and known types.  If many unnecessary assemblies are probed the startup time of your application will suffer.  However,
            if assemblies which should be probed are not, your application will not work correctly.  Always check the debug log to 
            see which assemblies have been probed.
            </para>
            <para>
            You should avoid clearing the <b>IgnorePatterns</b> altogether, and instead add patterns as needed.  If the "IdeaBlade.*" assemblies
            are probed your program will not work correctly, and if "System.*" and other system-related assemblies are probed performance
            will suffer.  The default <b>IgnorePatterns</b> exclude these assemblies.
            </para>
            <para>
             <see cref="P:IdeaBlade.Core.Composition.CompositionHost.SearchPatterns"/> are applied before <b>IgnorePatterns</b>.  
            </para>
            </remarks>
            <example>
        <code lang="C#">
          <![CDATA[
        <code lang="C#">
          // At application startup
          CompositionHost.SearchPatterns.Clear();
          CompositionHost.SearchPatterns.Add("DomainModel.dll");  //  Add whatever assemblies you need probed
                ]]>

        </code>
      </example>
        </member>
        <member name="T:IdeaBlade.Core.Composition.InterfaceExportAttribute">
            <summary>
            Used internally by the DevForce framework to mark a type as exported.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.Composition.InterfaceExportAttribute.#ctor(System.Type)">
            <summary>
            
            </summary>
            <param name="exportedType"></param>
        </member>
        <member name="T:IdeaBlade.Core.Composition.DefaultExportAttribute">
            <summary>
            Used internally by the DevForce framework to mark an export as a default, i.e., the default implementation to use if
            the developer has not supplied a custom implementation.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.Composition.DefaultExportAttribute.#ctor(System.Type)">
            <summary>
            
            </summary>
            <param name="exportedType"></param>
        </member>
        <member name="P:IdeaBlade.Core.Composition.DefaultExportAttribute.IsDefault">
            <summary>
            
            </summary>
        </member>
        <member name="T:IdeaBlade.Core.Composition.LazyRecomposable`1">
            <summary>
            Lazy{T} which can be recomposed.  Only the single ctor supported right now.
            Listens for CompositionHost.Recomposed events.
            </summary>
        </member>
        <member name="T:IdeaBlade.Core.Composition.PartsCatalog">
            <summary>
            An AggregateCatalog holding parts found by DevForce probing.  The PartsCatalog contains
            all application-specific exports.
            </summary>
        </member>
        <member name="T:IdeaBlade.Core.Composition.DefaultsCatalog">
            <summary>
            A parts catalog for DevForce exports used to satisfy implementation defaults.
            </summary>
        </member>
        <member name="T:IdeaBlade.Core.Composition.RecomposedEventArgs">
            <summary>
            Arguments to the <see cref="E:IdeaBlade.Core.Composition.CompositionHost.Recomposed"/> event.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.Composition.RecomposedEventArgs.#ctor(IdeaBlade.Core.Xap,System.Reflection.Assembly,System.Exception,System.Boolean)">
            <summary>
            Create an instance of this class.
            </summary>
            <param name="xap"></param>
            <param name="assembly"></param>
            <param name="error"></param>
        </member>
        <member name="P:IdeaBlade.Core.Composition.RecomposedEventArgs.XapLoaded">
            <summary>
            Returns true if a XAP download caused the recomposition.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.Composition.RecomposedEventArgs.AssemblyLoaded">
            <summary>
            Returns true if an assembly download caused the recomposition.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.Composition.RecomposedEventArgs.HasError">
            <summary>
            Returns true if the XAP download failed.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.Composition.RecomposedEventArgs.Assembly">
            <summary>
            The assembly causing the recomposition.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.Composition.RecomposedEventArgs.Xap">
            <summary>
            The XAP causing the recomposition.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.Composition.RecomposedEventArgs.XapLoadError">
            <summary>
            The XAP download error.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:IdeaBlade.Core.Composition.RecomposedEventArgs.ShouldRecompose" -->
        <member name="P:IdeaBlade.Core.AppEnv.IsSilverlightApplication">
            <summary>
            Returns true if running under Silverlight.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.AppEnv.IsWebApplication">
            <summary>
            Returns true if a web application. 
            </summary>
        </member>
        <member name="T:IdeaBlade.Core.Configuration.ClientSettingsElement">
            <summary>
            Represents client-specific configuration information.
            </summary>
            <remarks>Corresponds to the <b>clientSettings</b> element in the IdeaBlade configuration section.
            Information here is application to only the client.  By default, <see cref="P:IdeaBlade.Core.Configuration.ClientSettingsElement.IsDistributed"/> is false
            and a distributed EntityServer is not used.  Set the value to true to use a remote EntityServer, and be 
            sure to alos provide the <see cref="P:IdeaBlade.Core.Configuration.ObjectServerElement.RemoteBaseUrl"/> or client endpoint
            information in the <b>system.serviceModel</b> section to indicate the location of the EntityServer.
            </remarks>
        </member>
        <member name="M:IdeaBlade.Core.Configuration.ClientSettingsElement.#ctor">
            <summary>
            Creates a new instance of this class.  Internal use only.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.Configuration.ClientSettingsElement.Equals(System.Object)">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Configuration.ClientSettingsElement.GetHashCode">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:IdeaBlade.Core.Configuration.ClientSettingsElement.IsNullInstance">
            <summary>
            Is this a 'null' element?
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.Configuration.ClientSettingsElement.IsDistributed">
            <summary>
            Gets or sets whether a distributed Object Server should be used.
            </summary>
            <remarks>
            <para>
            When <b>true</b>, the client application will communicate with a remote EntityServer.  The EntityServer can be hosted
            by either the console or Windows service applications provided with DevForce, or under IIS or WAS.
            </para>
            </remarks>
        </member>
        <member name="T:IdeaBlade.Core.Configuration.ConfigEditorAttribute">
            <summary>
            Specifies how a property is handled by the IdeaBlade ConfigurationEditor
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.Configuration.ConfigEditorAttribute.IsPropertyVisible(System.Reflection.PropertyInfo)">
            <summary>
            Determines if a reflected property is annotated with the ConfigEditor 
            attributes specifying IsVisible = false
            </summary>
            <param name="propInfo">
            The reflected property information
            </param>
            <returns>
            False if the property has the ConfigEditor attribute with IsVisible = false
            True otherwise
            </returns>
        </member>
        <member name="M:IdeaBlade.Core.Configuration.ConfigEditorAttribute.AllowPropertyEdit(System.Reflection.PropertyInfo)">
            <summary>
            Determines if a reflected property is annotated with the ConfigEditor 
            attributes specifying AllowEdit = false
            </summary>
            <param name="propInfo">
            The reflected property information
            </param>
            <returns>
            False if the property has the ConfigEditor attribute with AllowEdit = false
            True otherwise
            </returns>
        </member>
        <member name="M:IdeaBlade.Core.Configuration.ConfigEditorAttribute.GetElementType(System.Type)">
            <summary>
            Gets the element type of a collection annotated with the
            ConfigEditor attribute
            </summary>
            <param name="type">
            The collection type whose element type is desired
            </param>
            <returns>
            The type of the elements of the collection
            Null if the collection is not annotated or the type is not set
            </returns>
        </member>
        <member name="P:IdeaBlade.Core.Configuration.ConfigEditorAttribute.IsVisible">
            <summary>
            Gets or sets a flag indicating if the property should appear
            in the item tree of the configuration editor
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.Configuration.ConfigEditorAttribute.AllowEdit">
            <summary>
            Gets or sets a flag indicating if editing of the 
            property value should be allowed
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.Configuration.ConfigEditorAttribute.ElementType">
            <summary>
            Gets the type of the elements of a collection
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.Configuration.ConfigHelper.DeserializeFromAssembly(System.Reflection.Assembly)">
            <summary>
            Used to deserialize an embedded IdeaBlade configuration file.  Internal use only.
            </summary>
            <param name="assembly">Specifies the source assembly.</param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Configuration.ConfigHelper.DeserializeFromStream(System.IO.Stream)">
            <summary>
            Used to deserialize an IO stream. Internal use only.
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Configuration.ConfigHelper.DeserializeFromString(System.String)">
            <summary>
            Deserializes a string containing an entire app/web.config into an IdeaBladeConfig instance.
            </summary>
            <param name="appConfigXml"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Configuration.ConfigHelper.DeserializeFromIbConfigString(System.String)">
            <summary>
            Deserializes a string containing just the IdeaBlade config section into an IdeaBladeConfig instance.
            </summary>
            <param name="ibConfigXml"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Configuration.ConfigHelper.DeserializeFromIbConfigElement(System.Xml.Linq.XElement)">
            <summary>
            Deserializes an XElement containing just the IdeaBlade config section into an IdeaBladeConfig instance.
            </summary>
            <param name="ibEle"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Configuration.ConfigHelper.SerializeToIbConfigString(IdeaBlade.Core.IdeaBladeConfig)">
            <summary>
            Serialize the current instance to a string.
            </summary>
            <returns></returns>
        </member>
        <member name="T:IdeaBlade.Core.Configuration.Extensions.ConfigExtensions">
            <summary>
            <see cref="T:IdeaBlade.Core.IdeaBladeConfig"/> extension methods.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.Configuration.Extensions.ConfigExtensions.SerializeToString(IdeaBlade.Core.IdeaBladeConfig)">
            <summary>
            Serialize the configuration information to a string.
            </summary>
            <param name="config"></param>
            <returns></returns>
        </member>
        <member name="T:IdeaBlade.Core.Configuration.ExtensionElement">
            <summary>
            Abstract base class for data source key elements containing a probe assemblies and options.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.Configuration.ExtensionElement.#ctor">
            <summary>
            Default ctor.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.Configuration.ExtensionElement.ShouldSerializeProbeAssemblyNameWrapper">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Configuration.ExtensionElement.ShouldSerializeOptionsWrapper">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:IdeaBlade.Core.Configuration.ExtensionElement.ProbeAssemblyNames">
            <summary>
            Names of assemblies to search for dynamically loaded types - Applicable to both Client and Server.
            </summary>
            <remarks>
            This list is used when probing for an <see cref="T:IdeaBlade.EntityModel.IIdGenerator"/> and
            <see cref="T:IdeaBlade.EntityModel.IConcurrencyStrategy"/>,
            and for WsKeys, an <see cref="T:IdeaBlade.EntityModel.WS.IWsProxyInterceptor"/>.
            </remarks>
        </member>
        <member name="P:IdeaBlade.Core.Configuration.ExtensionElement.ProbeAssemblyNameWrapper">
            <summary>
            For internal use only.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.Configuration.ExtensionElement.Options">
            <summary>
            Property bag of options available for the key - Applicable to both Client and Server.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.Configuration.ExtensionElement.OptionsWrapper">
            <summary>
            For internal use only - Use Options property instead.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.Configuration.ExtensionElement.Tag">
            <summary>
            A free-form field for developer's custom use.
            </summary>
        </member>
        <member name="T:IdeaBlade.Core.IdeaBladeConfig">
            <summary>
             Used to manage configuration properties within a DevForce application.
            </summary>
            <remarks>
            <b>IdeaBladeConfig</b> is the in-memory representation of the ideaBlade.configuration
            section in a configuration file.  Use <see cref="P:IdeaBlade.Core.IdeaBladeConfig.Instance">IdeaBladeConfig.Instance</see>
            to obtain the loaded configuration information; there is usually no need for you to construct
            an instance of this class.
            <para>
            DevForce probes for a .config file somewhat differently
            than standard .NET looks for the .config file. The probing sequence DevForce uses to find this file 
            is as follows - note that probing continues until a valid configuration is found and loaded - 
            </para>
            <para>
            1) If the <see cref="!:ConfigFileLocation"/> static property is set, this directory is searched for any file
            named or matching "*.exe.config", "web.config" or "app.config", in this order.  
            Note that any files matching *.dll.config will not be found. 
            </para>
            <para>
            2) If the <see cref="P:IdeaBlade.Core.IdeaBladeConfig.ConfigFileAssembly"/> static property is set, the assembly is probed
            for an embedded resource named "app.config".
            </para>
            <para>
            3) The <see cref="!:BaseAppDirectory"/> for a file named or matching "*.exe.config" or "web.config" or "app.config",
            in this order.  This property is readonly and determined at run time, and is usually the directory from which the 
            entry assembly was loaded.
            </para>
            <para>
            4) An embedded resource named "app.config" in the entry assembly.  
            </para>
            <para>
            If configuration information cannot be found or cannot be loaded, then your application may not run correctly.
            If your configuration cannot be loaded or you think the wrong information has
            been loaded, check the <see cref="!:LoggingElement.LogFile">logFile</see> output
            (usually named debuglog.xml) for tracing messages.  All probe attempts are written to the log file. 
            </para>
            <para>
            The .config file holding the <b>IdeaBlade</b> configuration information can also contain
            other configuration sections.  If you embed the file in an assembly .NET will be unable to find
            these other configuration sections, since embedding the app.config is a DevForce-specific feature.
            In these situations, you should instead use an appropriately named loose .config file 
            (e.g., MyApp.exe.config, web.config) so that the <see cref="!:System.Configuration.ConfigurationManager"/> 
            can load all configuration data.
            </para>
            </remarks>
        </member>
        <member name="T:IdeaBlade.Core.ICloneable">
            <summary>
            
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.ICloneable.Clone">
            <summary/>
        </member>
        <member name="F:IdeaBlade.Core.IdeaBladeConfig.CfgNamespace">
            <summary>
            Schema namespace.
            </summary>
        </member>
        <member name="F:IdeaBlade.Core.IdeaBladeConfig.BaseFileName">
            <summary>
            Filename of the properties file.  Currently <b>app.config</b>.
            </summary>
        </member>
        <member name="F:IdeaBlade.Core.IdeaBladeConfig.CurrentName">
            <summary>
            Current section name.  Currently <b>ideaBlade.configuration</b>.
            </summary>
        </member>
        <member name="F:IdeaBlade.Core.IdeaBladeConfig.CurrentVersion">
            <summary>
            Current configuration version.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.IdeaBladeConfig.#ctor">
            <summary>
            Default ctor.  Internal use only.
            </summary>
            <remarks>
            Used internally by the DevForce framework.  Applications should instead use 
            the <see cref="P:IdeaBlade.Core.IdeaBladeConfig.Instance"/> property whenever referencing the IdeaBlade configuration.
            </remarks>
        </member>
        <member name="M:IdeaBlade.Core.IdeaBladeConfig.Clone">
            <summary>
            Implements ICloneable method ( deep copy).
            </summary>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.IdeaBladeConfig.ShouldSerializeObjectServer">
            <summary>
            For internal use only.
            </summary>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.IdeaBladeConfig.ShouldSerializeVerifiers">
            <summary>
            Internal use only.
            </summary>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.IdeaBladeConfig.ShouldSerializeProbeAssemblyNameWrapper">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.IdeaBladeConfig.InitializeFromSource">
            <summary>
              Locates and parses the IdeaBlade configuration file, and initializes platform services
              such as logging.  Any reference to IdeaBladeConfig.Instance also achieves the
              same effect.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.IdeaBladeConfig.AssertNonDefaultVersion(System.Boolean)">
            <summary>
            Asserts that a non-default version of the IdeaBlade configuration file was found.
            </summary>
            <exception cref="T:IdeaBlade.Core.IdeaBladeException">File not found</exception>
        </member>
        <member name="E:IdeaBlade.Core.IdeaBladeConfig.IdeaBladeConfigInitialized">
            <summary>
            Raised when configuration initialization is complete and IdeaBladeConfig.Instance is available.
            </summary>
            <remarks>
            Intended for internal use only for bootstrapping purposes.
            </remarks>
        </member>
        <member name="P:IdeaBlade.Core.IdeaBladeConfig.Instance">
            <summary>
              Returns the singleton instance of this class for your application.
            </summary>
            <remarks>
            Automatically loads and initializes the configuration file if it has not already done so.
            </remarks>
        </member>
        <member name="P:IdeaBlade.Core.IdeaBladeConfig.Initialized">
            <summary>
              Gets whether or not the <see cref="P:IdeaBlade.Core.IdeaBladeConfig.Instance"/> has been initialized.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.IdeaBladeConfig.ConfigFileAssembly">
            <summary>
              Gets or sets the assembly that should be
              searched first for an embedded file when probing for the IdeaBlade configuration file.  
            </summary>
            <remarks>
              If the file is not found, then the standard probing behavior is followed.
            </remarks>
        </member>
        <member name="P:IdeaBlade.Core.IdeaBladeConfig.InitializationException">
            <summary>
            Contains any exception encountered when initializing this instance.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.IdeaBladeConfig.FileName">
            <summary>
            Gets or sets the configuration file name.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.IdeaBladeConfig.TryList">
            <summary>
            List of probe attempts.  Internal use only.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.IdeaBladeConfig.IsDefaultVersion">
            <summary>
            Returns whether this instance is the default fall-thru version.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.IdeaBladeConfig.LoadedFrom">
            <summary>
            Returns either the Assembly or a file name where this configuration was
            actually loaded from. 
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.IdeaBladeConfig.Version">
            <summary>
            Version of this configuration section.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.IdeaBladeConfig.ObjectServer">
            <summary>
            Object Server configuration information.
            </summary>
            <remarks>
            Settings for 2-tier and n-tier configuration of both client and server.
            </remarks>
        </member>
        <member name="P:IdeaBlade.Core.IdeaBladeConfig.Verifiers">
            <summary>
            Verifier information - Applicable to both Client and Server.
            </summary>
            <remarks>
            Each <see cref="T:IdeaBlade.Core.Configuration.VerifierElement">Verifier</see> contains information on how to verify the state of some business object.
            </remarks>
        </member>
        <member name="P:IdeaBlade.Core.IdeaBladeConfig.ProbeAssemblyNames">
            <summary>
            Names of assemblies to search for dynamically loaded types - Applicable to both Client and Server.
            </summary>
            <remarks>
            By default, at run time DevForce will probe assemblies in the exe/bin folder, or within the XAP in Silverlight
            applications.  Use this to specify <b>additional</b> assemblies not meeting the default search criteria.
            <para>
            Standard MEF probing will not be performed at design time.  If using an <b>EntityCacheState</b> to supply design-time data
            you should add the name of the domain model assembly to the <b>ProbeAssemblyNames</b>. 
            </para>
            </remarks>
        </member>
        <member name="P:IdeaBlade.Core.IdeaBladeConfig.ProbeAssemblyNameWrapper">
            <summary>
            For internal use only.
            </summary>
        </member>
        <member name="T:IdeaBlade.Core.Configuration.KeyElement">
            <summary>
            Abstract base class for data source key elements within a configuration file.
            </summary>
        </member>
        <member name="T:IdeaBlade.Core.Configuration.INamedElement">
            <summary>
            Interface for all config elements keyed by a 'Name' property.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.Configuration.INamedElement.Name">
            <summary>
            The Name.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.Configuration.KeyElement.#ctor">
            <summary>
            Default ctor.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.Configuration.KeyElement.#ctor(IdeaBlade.Core.Configuration.KeyElement)">
            <summary>
            Copy ctor.
            </summary>
            <param name="key"></param>
        </member>
        <member name="P:IdeaBlade.Core.Configuration.KeyElement.Name">
            <summary>
            Gets or sets the name (moniker) by which this element will be referenced in code.  
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.Configuration.KeyElement.Tag">
            <summary>
            A free-form field for developer's custom use.
            </summary>
        </member>
        <member name="T:IdeaBlade.Core.Configuration.NamedElementCollection`1">
            <summary>
            Class for all collections of typed INamedElement objects.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:IdeaBlade.Core.Configuration.NamedElementCollection`1.#ctor">
            <summary>
            Default ctor.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.Configuration.NamedElementCollection`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Ctor.
            </summary>
            <param name="keys"></param>
        </member>
        <member name="M:IdeaBlade.Core.Configuration.NamedElementCollection`1.GetKeyForItem(`0)">
            <summary>
            For internal use only.
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="P:IdeaBlade.Core.Configuration.NamedElementCollection`1.Item(System.String)">
            <summary>
            Base version throws an exception when not found. This version returns null;
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="T:IdeaBlade.Core.Configuration.ObjectServerElement">
            <summary>
            Represents configuration information for the EntityServer.
            </summary>
            <remarks>
            Corresponds to the <b>objectServer</b> element in the IdeaBlade configuration section.
            <para>
            Information here can apply to either or both the client and server.  In 2-tier configurations
            in which an application server is not used, you may still need to include <see cref="!:ServerSettings"/>
            in order to configure the local data service.  In n-tier configurations, you will need to specify
            <see cref="P:IdeaBlade.Core.Configuration.ObjectServerElement.RemoteBaseUrl"/> and other information, and on the client use the <see cref="P:IdeaBlade.Core.Configuration.ObjectServerElement.ClientSettings"/>
            to enable or disable use of the application server; while on the server, the <see cref="!:ServerSettings"/> 
            are used to determine security and other settings.
            </para>
            </remarks>
        </member>
        <member name="F:IdeaBlade.Core.Configuration.ObjectServerElement.DefaultBaseUrl">
            <summary>
            Default base url. 
            </summary>
        </member>
        <member name="F:IdeaBlade.Core.Configuration.ObjectServerElement.DefaultServerPort">
            <summary>
            Default server port. 
            </summary>
        </member>
        <member name="F:IdeaBlade.Core.Configuration.ObjectServerElement.DefaultServiceName">
            <summary>
            Default service name.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.Configuration.ObjectServerElement.#ctor">
            <summary>
            Creates a new instance of this class.  Internal use only.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.Configuration.ObjectServerElement.GetServiceKey(System.String,System.Boolean)">
            <summary>
            Return the ServiceKey with the given name.
            </summary>
            <param name="name"></param>
            <param name="throwIfNotFound"></param>
            <returns></returns>
            <remarks>
            If the <paramref name="name"/> provided is null or an empty string then the default key is returned.
            This will throw an exception if the key is not found, or return null if the <paramref name="throwIfNotFound"/> parameters is false.
            </remarks>
            <exception cref="T:System.InvalidOperationException">Thrown if no service keys are defined, or the key is not found</exception>
        </member>
        <member name="M:IdeaBlade.Core.Configuration.ObjectServerElement.GetDefaultServiceKey">
            <summary>
            Return the default ServiceKey.
            </summary>
            <returns></returns>
            <remarks>
            The default key search is as follows:  1) if the RemoteBaseUrl and other properties on the ObjectServer are set then a ServiceKey is built from
            this information and returned, 2) If a service key named "default" is found it will be returned; otherwise the first key in the collection is returned.
            </remarks>
            <exception cref="T:System.InvalidOperationException">Thrown if a default key cannot be found</exception>
        </member>
        <member name="M:IdeaBlade.Core.Configuration.ObjectServerElement.ShouldSerializeServiceKeys">
            <summary>
            Internal use only.
            </summary>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Configuration.ObjectServerElement.ShouldSerializeClientSettings">
            <summary>
            For internal use only.
            </summary>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Configuration.ObjectServerElement.ToString">
            <summary>
            String representation of this object.
            </summary>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Configuration.ObjectServerElement.Equals(System.Object)">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Configuration.ObjectServerElement.GetHashCode">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:IdeaBlade.Core.Configuration.ObjectServerElement.IsNullInstance">
            <summary>
            Is this a 'null' element?
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.Configuration.ObjectServerElement.ServiceKeys">
            <summary>
            Application server address information - applicable to client but allowed on server.
            </summary>
            <remarks>
            Use <b>ServiceKeys</b> to define the address information to one or more application servers.  A client application can
            specify the <b>ServiceKey</b> to be used when constructing an <b>EntityManager</b>.
            </remarks>
        </member>
        <member name="P:IdeaBlade.Core.Configuration.ObjectServerElement.ClientSettings">
            <summary>
            Configuration settings for client features - applicable to client only.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.Configuration.ObjectServerElement.RemoteBaseUrl">
            <summary>
            Gets or sets the URL where the application server is located - Applicable to both client and server.
            </summary>
            <remarks>
            The <b>RemoteBaseURL</b> consists of the protocol and server name (or IP address) used to
            form the final endpoint address.  Supported protocols are: "http", "https", "net.tcp" or "net.pipe".  
            If you do use named pipes, remember it works on the localhost only, and do not specify a <see cref="P:IdeaBlade.Core.Configuration.ObjectServerElement.ServerPort"/>.
            <para>
            The final endpoint address is formed from the <b>RemoteBaseUrl</b>, <see cref="P:IdeaBlade.Core.Configuration.ObjectServerElement.ServerPort"/> and <see cref="P:IdeaBlade.Core.Configuration.ObjectServerElement.ServiceName"/>
            properties. For example, if the endpoint address is http://localhost:9009/myapp/EntityService.svc, then
            the RemoteBaseUrl would be "http://localhost".  
            </para> 
            <para>
            The <b>RemoteBaseURL</b>, <see cref="P:IdeaBlade.Core.Configuration.ObjectServerElement.ServerPort"/> and <see cref="P:IdeaBlade.Core.Configuration.ObjectServerElement.ServiceName"/> values are ignored by the application server when
            hosted by IIS.  These values are also not requred when endpoint configuration information can be obtained 
            from the <b>system.serviceModel</b> section of the client's configuration file.
            </para>
            </remarks>
        </member>
        <member name="P:IdeaBlade.Core.Configuration.ObjectServerElement.ServerPort">
            <summary>
            Gets or sets the server port that is listening for client requests - Applicable to both client and server.
            </summary>
            <remarks>
            This value must be the same for both Client and Server configurations.
            <para>
            The final endpoint address is formed is formed from the <see cref="P:IdeaBlade.Core.Configuration.ObjectServerElement.RemoteBaseUrl"/>, <b>ServerPort</b> and <see cref="P:IdeaBlade.Core.Configuration.ObjectServerElement.ServiceName"/> properties.
            For example, if the endpoint address is http://localhost:9009/myapp/EntityService.svc, then
            the ServerPort would be "9009".  If the service is hosted under IIS with an address such as http://localhost/MyService/EntityService.svc, then the ServerPort 
            will be 80.
            </para> 
            <para>
            If hosting the application server with either the ServerService or ServerConsole, you will probably need to manually open the port used by your service.  
            If using Windows Firewall, use the "Add Port" button on the Exceptions tab.  
            Be sure to choose a TCP port even if youre using the HTTP protocol.
            </para>
            <para>
            The <b>ServerPort</b>, <see cref="P:IdeaBlade.Core.Configuration.ObjectServerElement.RemoteBaseUrl"/> and <see cref="P:IdeaBlade.Core.Configuration.ObjectServerElement.ServiceName"/> values are ignored by the application server when
            hosted by IIS.  These values are also not requred when endpoint configuration information can be obtained 
            from the <b>system.serviceModel</b> section of the client's configuration file.
            </para>
            </remarks>
        </member>
        <member name="P:IdeaBlade.Core.Configuration.ObjectServerElement.ServiceName">
             <summary>
             Gets or sets the name of the service on the application server - Applicable to both client and server.
             </summary>
             <remarks>
             The <b>ServiceName</b> should always be "EntityService" when the application server is hosted by either the supplied console
             or Windows service DevForce applications.  When hosted by IIS or WAS, the <b>ServiceName</b> should contain
             both the virtual directory and the service file names.  The service file name will usually be "EntityService.svc".
             <para>
             The final endpoint address is formed is formed from the <see cref="P:IdeaBlade.Core.Configuration.ObjectServerElement.RemoteBaseUrl"/>, <see cref="P:IdeaBlade.Core.Configuration.ObjectServerElement.ServerPort"/> and <b>ServiceName</b> properties.
             <see cref="P:IdeaBlade.Core.Configuration.ObjectServerElement.RemoteBaseUrl"/>:<see cref="P:IdeaBlade.Core.Configuration.ObjectServerElement.ServerPort"/>/<see cref="P:IdeaBlade.Core.Configuration.ObjectServerElement.ServiceName"/>.
             For example, if the endpoint address is http://localhost:9009/myapp/EntityService.svc, then
             the ServiceName would be "myapp/EntityService.svc".  
             </para> 
             <para>
             The <b>ServiceName</b>, <see cref="P:IdeaBlade.Core.Configuration.ObjectServerElement.RemoteBaseUrl"/> and <see cref="P:IdeaBlade.Core.Configuration.ObjectServerElement.ServerPort"/> values are ignored by the application server when
             hosted by IIS.  These values are also not requred when endpoint configuration information can be obtained 
             from the <b>system.serviceModel</b> section of the client's configuration file.
             </para>
            </remarks>
        </member>
        <member name="P:IdeaBlade.Core.Configuration.ObjectServerElement.UseDCS">
            <summary>
            For backwards compat, and for future JSON support.
            </summary>
        </member>
        <member name="T:IdeaBlade.Core.Configuration.ServiceKeyElement">
            <summary>
            Represents an endpoint address to the application server.
            </summary>
            <remarks>
            Corresponds to the <b>serviceKey</b> element in the IdeaBlade configuration.  <b>ServiceKeys</b> are intended
            to be used by a client application, but if defined in the server's configuration file the "default" service key
            will be used if a base address must be determined.
            </remarks>  
        </member>
        <member name="M:IdeaBlade.Core.Configuration.ServiceKeyElement.#ctor">
            <summary>
            Creates an empty instance of this class.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.Configuration.ServiceKeyElement.#ctor(IdeaBlade.Core.Configuration.ServiceKeyElement)">
            <summary>
            Copy ctor.
            </summary>
            <param name="key"></param>
        </member>
        <member name="M:IdeaBlade.Core.Configuration.ServiceKeyElement.#ctor(System.String)">
            <summary>
            Creates an instance of this class with the specified key name.
            </summary>
            <param name="keyName"></param>
        </member>
        <member name="M:IdeaBlade.Core.Configuration.ServiceKeyElement.Equals(System.Object)">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Configuration.ServiceKeyElement.GetHashCode">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Configuration.ServiceKeyElement.ToString">
            <summary>
            Returns the name and address represented by this instance.
            </summary>
            <returns></returns>
        </member>
        <member name="P:IdeaBlade.Core.Configuration.ServiceKeyElement.RemoteBaseUrl">
            <summary>
            Gets or sets the URL where the application server is located - Applicable to both client and server.
            </summary>
            <remarks>
            The <b>RemoteBaseURL</b> consists of the protocol and server name (or IP address) used to
            form the final endpoint address.  Supported protocols are: "http", "https", "net.tcp" or "net.pipe".  
            If you do use named pipes, remember it works on the localhost only, and do not specify a <see cref="P:IdeaBlade.Core.Configuration.ServiceKeyElement.ServerPort"/>.
            <para>
            The final endpoint address is formed from the <b>RemoteBaseUrl</b>, <see cref="P:IdeaBlade.Core.Configuration.ServiceKeyElement.ServerPort"/> and <see cref="P:IdeaBlade.Core.Configuration.ServiceKeyElement.ServiceName"/>
            properties. For example, if the endpoint address is http://localhost:9009/myapp/EntityService.svc, then
            the RemoteBaseUrl would be "http://localhost".  
            </para> 
            <para>
            The <b>RemoteBaseURL</b>, <see cref="P:IdeaBlade.Core.Configuration.ServiceKeyElement.ServerPort"/> and <see cref="P:IdeaBlade.Core.Configuration.ServiceKeyElement.ServiceName"/> values are ignored by the application server when
            hosted by IIS.  These values are also not requred when endpoint configuration information can be obtained 
            from the <b>system.serviceModel</b> section of the client's configuration file.
            </para>
            </remarks>
        </member>
        <member name="P:IdeaBlade.Core.Configuration.ServiceKeyElement.ServerPort">
            <summary>
            Gets or sets the server port that is listening for client requests - Applicable to both client and server.
            </summary>
            <remarks>
            This value must be the same for both Client and Server configurations.
            <para>
            The final endpoint address is formed is formed from the <see cref="P:IdeaBlade.Core.Configuration.ServiceKeyElement.RemoteBaseUrl"/>, <b>ServerPort</b> and <see cref="P:IdeaBlade.Core.Configuration.ServiceKeyElement.ServiceName"/> properties.
            For example, if the endpoint address is http://localhost:9009/myapp/EntityService.svc, then
            the ServerPort would be "9009".  If the service is hosted under IIS with an address such as http://localhost/MyService/EntityService.svc, then the ServerPort 
            will be 80.
            </para> 
            <para>
            If hosting the application server with either the ServerService or ServerConsole, you will probably need to manually open the port used by your service.  
            If using Windows Firewall, use the "Add Port" button on the Exceptions tab.  
            Be sure to choose a TCP port even if youre using the HTTP protocol.
            </para>
            <para>
            The <b>ServerPort</b>, <see cref="P:IdeaBlade.Core.Configuration.ServiceKeyElement.RemoteBaseUrl"/> and <see cref="P:IdeaBlade.Core.Configuration.ServiceKeyElement.ServiceName"/> values are ignored by the application server when
            hosted by IIS.  These values are also not requred when endpoint configuration information can be obtained 
            from the <b>system.serviceModel</b> section of the client's configuration file.
            </para>
            </remarks>
        </member>
        <member name="P:IdeaBlade.Core.Configuration.ServiceKeyElement.ServiceName">
             <summary>
             Gets or sets the name of the service on the application server - Applicable to both client and server.
             </summary>
             <remarks>
             The <b>ServiceName</b> should always be "EntityService" when the application server is hosted by either the supplied console
             or Windows service DevForce applications.  When hosted by IIS or WAS, the <b>ServiceName</b> should contain
             both the virtual directory and the service file names.  The service file name will usually be "EntityService.svc".
             <para>
             The final endpoint address is formed is formed from the <see cref="P:IdeaBlade.Core.Configuration.ServiceKeyElement.RemoteBaseUrl"/>, <see cref="P:IdeaBlade.Core.Configuration.ServiceKeyElement.ServerPort"/> and <b>ServiceName</b> properties.
             <see cref="P:IdeaBlade.Core.Configuration.ServiceKeyElement.RemoteBaseUrl"/>:<see cref="P:IdeaBlade.Core.Configuration.ServiceKeyElement.ServerPort"/>/<see cref="P:IdeaBlade.Core.Configuration.ServiceKeyElement.ServiceName"/>.
             For example, if the endpoint address is http://localhost:9009/myapp/EntityService.svc, then
             the ServiceName would be "myapp/EntityService.svc".  
             </para> 
             <para>
             The <b>ServiceName</b>, <see cref="P:IdeaBlade.Core.Configuration.ServiceKeyElement.RemoteBaseUrl"/> and <see cref="P:IdeaBlade.Core.Configuration.ServiceKeyElement.ServerPort"/> values are ignored by the application server when
             hosted by IIS.  These values are also not requred when endpoint configuration information can be obtained 
             from the <b>system.serviceModel</b> section of the client's configuration file.
             </para>
            </remarks>
        </member>
        <member name="T:IdeaBlade.Core.Configuration.SimpleElement">
            <summary>
            Abstract base class for data source key elements within a configuration file.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.Configuration.SimpleElement.#ctor">
            <summary>
            Default ctor.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.Configuration.SimpleElement.#ctor(System.String)">
            <summary>
            Ctor.
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:IdeaBlade.Core.Configuration.SimpleElement.op_Implicit(System.String)~IdeaBlade.Core.Configuration.SimpleElement">
            <summary>
            Implicit operator to convert a String to a NamedElement.
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Configuration.SimpleElement.op_Implicit(IdeaBlade.Core.Configuration.SimpleElement)~System.String">
            <summary>
            Implicit operator to convert a NamedElement to a String.
            </summary>
            <param name="nc"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Configuration.SimpleElement.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:IdeaBlade.Core.Configuration.SimpleElement.Name">
            <summary>
            Gets or sets the name (moniker) by which this data source will be referenced in code.  
            </summary>
        </member>
        <member name="T:IdeaBlade.Core.Configuration.SimpleElementCollection">
            <summary>
            Collection of NamedElement
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.Configuration.SimpleElementCollection.#ctor">
            <summary>
            Default ctor.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.Configuration.SimpleElementCollection.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Ctor.
            </summary>
            <param name="strings"></param>
        </member>
        <member name="M:IdeaBlade.Core.Configuration.SimpleElementCollection.#ctor(System.Collections.Generic.IEnumerable{IdeaBlade.Core.Configuration.SimpleElement})">
            <summary>
            Ctor.
            </summary>
            <param name="namedElements"></param>
        </member>
        <member name="T:IdeaBlade.Core.Configuration.SimpleElementCollection.Wrapper">
            <summary>
            For internal use only.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.Configuration.SimpleElementCollection.Wrapper.#ctor">
            <summary>
            For internal use only.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.Configuration.SimpleElementCollection.Wrapper.Add(IdeaBlade.Core.Configuration.SimpleElement)">
            <summary>
            For internal use only.
            </summary>
            <param name="namedElement"></param>
        </member>
        <member name="M:IdeaBlade.Core.Configuration.SimpleElementCollection.Wrapper.GetEnumerator">
            <summary>
            For internal use only.
            </summary>
            <returns></returns>
        </member>
        <member name="P:IdeaBlade.Core.Configuration.SimpleElementCollection.Wrapper.WrappedCollection">
            <summary>
            For internal use only.
            </summary>
        </member>
        <member name="T:IdeaBlade.Core.Configuration.VerifierElement">
            <summary>
            Represents <code>&lt;verifier&gt;</code> configuration information.
            </summary>
            <remarks>Corresponds to the <b>verifier</b> element in the IdeaBlade configuration file.</remarks>  
        </member>
        <member name="M:IdeaBlade.Core.Configuration.VerifierElement.#ctor">
            <summary>
            Empty constructor.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.Configuration.VerifierElement.GetValue(System.String,System.Type)">
            <summary>
            Returns the value in the <code>&lt;verifierArgs&gt;</code> collection corresponding to the given name.
            If name does not exist, the default value for the given type is returned.
            </summary>
            <param name="name">The name specified in the <code>&lt;verifierArg&gt;</code> element</param>
            <param name="type">The type of the value in the <code>&lt;verifierArg&gt;</code> element</param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Configuration.VerifierElement.GetValue``1(System.String)">
            <summary>
            Returns the value in the <code>&lt;verifierArgs&gt;</code> collection corresponding to the given name.
            If name does not exist, the default value for the given type is returned.
            </summary>
            <param name="name">The name specified in the <code>&lt;verifierArg&gt;</code> element</param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Configuration.VerifierElement.GetType(System.String,System.Boolean,System.Boolean)">
            <summary>
            Returns the fully-qualified type given its name; optionally throws an error 
            if no matching type can be found.
            </summary>
            <param name="typeNameString">A type name to locate</param>
            <param name="throwOnError">Whether to throw an error if a matching type cannot be found</param>
            <param name="ignoreCase">Whether to ignore case when attempting a match</param>
            <returns>The latest version of a type with the specified name</returns>
        </member>
        <member name="M:IdeaBlade.Core.Configuration.VerifierElement.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:IdeaBlade.Core.Configuration.VerifierElement.Name">
            <summary>
            Gets or sets the name (moniker) by which this verifier can be referenced in code.  
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.Configuration.VerifierElement.VerifierTypeName">
            <summary>Gets or sets the VerifierType name.</summary>
        </member>
        <member name="P:IdeaBlade.Core.Configuration.VerifierElement.ApplicableTypeName">
            <summary>Gets or sets the ApplicableType name.</summary>
        </member>
        <member name="P:IdeaBlade.Core.Configuration.VerifierElement.Description">
            <summary>Gets or sets the Description.</summary>
        </member>
        <member name="P:IdeaBlade.Core.Configuration.VerifierElement.SortValue">
            <summary>Gets or sets the SortValue.</summary>
        </member>
        <member name="P:IdeaBlade.Core.Configuration.VerifierElement.Tag">
            <summary>A free-form field for developer's custom use.</summary>
        </member>
        <member name="P:IdeaBlade.Core.Configuration.VerifierElement.ExecutionModes">
            <summary>Gets or sets the ExecutionModes setting.</summary>
        </member>
        <member name="P:IdeaBlade.Core.Configuration.VerifierElement.ErrorContinuationMode">
            <summary>Gets or sets the OnErrorMode setting.</summary>
        </member>
        <member name="P:IdeaBlade.Core.Configuration.VerifierElement.VerifierArgs">
            <summary>Gets or sets the verifier arguments.</summary>
        </member>
        <member name="P:IdeaBlade.Core.Configuration.VerifierElement.VerifierType">
            <summary>
            Gets the fully-qualified type corresponding to the <see cref="P:IdeaBlade.Core.Configuration.VerifierElement.VerifierTypeName"/>; 
            throws an error if no matching type can be found.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.Configuration.VerifierElement.ApplicableType">
            <summary>
            Gets the fully-qualified type corresponding to the <see cref="P:IdeaBlade.Core.Configuration.VerifierElement.ApplicableTypeName"/>; 
            throws an error if no matching type can be found.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.Configuration.VerifierElement.Item(System.String)">
            <summary>
            Gets or sets a property, attribute, or child element of this VerifierElement.
            If pName is not found in VerifierElement, then VerifierArgs children are checked.
            </summary>
            <param name="name">The name of the property to access.</param>
            <returns>The specified property, attribute, or child element</returns>
        </member>
        <member name="T:IdeaBlade.Core.Configuration.VerifierArgElementCollection">
            <summary>
            Collection of VerifierArgElements.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.Configuration.VerifierArgElementCollection.#ctor">
            <summary>
            Default ctor.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.Configuration.VerifierArgElementCollection.GetKey(System.Int32)">
            <summary>
            For internal use only.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Configuration.VerifierArgElementCollection.GetValue(System.String,System.Type)">
            <summary>
            Returns the value in the <code>&lt;verifierArgs&gt;</code> collection corresponding to the given name.
            If name does not exist, the default value for the given type is returned.
            </summary>
            <param name="name">The name specified in the <code>&lt;verifierArg&gt;</code> element</param>
            <param name="type">The type of the value in the <code>&lt;verifierArg&gt;</code> element</param>
            <returns></returns>
        </member>
        <member name="T:IdeaBlade.Core.Configuration.VerifierArgElement">
            <summary>
            Represents a <code>&lt;verifierArg&gt;</code> element within a configuration file.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.Configuration.VerifierArgElement.#ctor">
            <summary>
            Empty constructor.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.Configuration.VerifierArgElement.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:IdeaBlade.Core.Configuration.VerifierArgElement.Name">
            <summary>Gets or sets the Name setting.</summary>
        </member>
        <member name="P:IdeaBlade.Core.Configuration.VerifierArgElement.Value">
            <summary>Gets or sets the Value setting.</summary>
        </member>
        <member name="T:IdeaBlade.Core.IPredicateDescription">
            <summary>
            Interface implemented by dynamically built predicates.
            </summary>
            <remarks>
            See IdeaBlade.Linq.PredicateDescription and IdeaBlade.Linq.CompositePredicateDescription for implementations.
            </remarks>
        </member>
        <member name="M:IdeaBlade.Core.IPredicateDescription.ToLambdaExpression">
            <summary>
            Returns a <see cref="T:System.Linq.Expressions.LambdaExpression"/> representing the predicate.
            </summary>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.IPredicateDescription.CreateUnboundCopy">
            <summary>
            Returns a clone of this predicate description with a null instance type - used by ToPredicate{T}
            </summary>
            <returns></returns>
        </member>
        <member name="P:IdeaBlade.Core.IPredicateDescription.InstanceType">
            <summary>
            The type the predicate acts upon.
            </summary>
        </member>
        <member name="T:IdeaBlade.Core.ISortSelector">
            <summary>
            Interface implemented by dyanmic sorting selectors.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.ISortSelector.InstanceType">
            <summary>
            The type the selector acts upon.
            </summary>
        </member>
        <member name="T:IdeaBlade.Core.IProjectionSelector">
            <summary>
            Interface implemented by dynamic property selectors.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.IProjectionSelector.ToLambdaExpression(System.Type)">
            <summary>
            Returns a <see cref="T:System.Linq.Expressions.LambdaExpression"/> representing the predicate.
            </summary>
            <returns></returns>
        </member>
        <member name="P:IdeaBlade.Core.IProjectionSelector.InstanceType">
            <summary>
            The type the selector acts upon.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.IProjectionSelector.ProjectionType">
            <summary>
            The type being projected into
            </summary>
        </member>
        <member name="T:IdeaBlade.Core.Xap">
            <summary>
            Base class for a Silverlight package.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.Xap.LoadAssembly(System.String)">
            <summary>
            Load the specified assembly.
            </summary>
            <param name="name"></param>
            <returns>Null if a part by this name was not found in the package.</returns>
            <remarks>
            Only the Parts collection of AssemblyParts is searched.
            </remarks>
        </member>
        <member name="M:IdeaBlade.Core.Xap.GetInstanceFromXap(System.String)">
            <summary>
            Instantiates an object of the specified type name from the package.
            </summary>
            <param name="fqTypeName">Assembly qualified type name ("MyNamespace.MyClass, MyAssembly")</param>
            <returns></returns>
            <remarks>
            You should pass the assembly qualified type name.  If the namespace and assembly name are the same you can omit the assembly name and
            pass only the full type name ("MyNamespace.MyClass").
            </remarks>
        </member>
        <member name="M:IdeaBlade.Core.Xap.GetTypeFromXap(System.String)">
            <summary>
            Returns a type with the specified type name from the package.
            </summary>
            <param name="fqTypeName">Assembly qualified type name (eg, "MyNamespace.MyClass, MyAssembly")</param>
            <returns></returns>
            <remarks>
            You should pass the assembly qualified type name.  If the namespace and assembly name are the same you can omit the assembly name and
            pass only the full type name (eg, "MyNamespace.MyClass").
            </remarks>
        </member>
        <member name="M:IdeaBlade.Core.Xap.LoadPart(System.Windows.AssemblyPart)">
            <summary>
            Load an assembly from the specified assembly part.
            </summary>
            <param name="part"></param>
            <returns></returns>
        </member>
        <member name="P:IdeaBlade.Core.Xap.Name">
            <summary>
            Returns the Xap name.
            </summary>
            <remarks>
            If this is the <see cref="T:IdeaBlade.Core.CurrentXap"/> the <b>Name</b> will be the entry point assembly name.
            If a <see cref="T:IdeaBlade.Core.DynamicXap"/> the <b>Name</b> will be the Uri string if built from a Uri, or the name
            provided with the stream.
            </remarks>
        </member>
        <member name="P:IdeaBlade.Core.Xap.Parts">
            <summary>
            Returns the assembly parts in the package.
            </summary>
            <remarks>
            The Parts collection will be empty for a <see cref="T:IdeaBlade.Core.DynamicXap"/> until the load completes.
            </remarks>
        </member>
        <member name="P:IdeaBlade.Core.Xap.IsLoaded">
            <summary>
            Returns whether the package has been downloaded and the <see cref="P:IdeaBlade.Core.Xap.Parts"/> are available.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.Xap.Assemblies">
            <summary>
            Returns the assemblies in the package.
            </summary>
        </member>
        <member name="T:IdeaBlade.Core.CurrentXap">
            <summary>
            Represents the current deployment package.
            </summary>
            <remarks>
            <b>CurrentXap</b> is equivalent to <b>Deployment.Current</b> and contains the parts from the current package.
            </remarks>
        </member>
        <member name="M:IdeaBlade.Core.CurrentXap.#ctor">
            <summary>
            Create an instance of this type.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.CurrentXap.LoadPart(System.Windows.AssemblyPart)">
            <summary>
            Loads the assembly for the specified assembly part.
            </summary>
            <param name="part"></param>
            <returns></returns>
        </member>
        <member name="T:IdeaBlade.Core.DynamicXap">
            <summary>
            Represents a dynamically downloaded deployment package.
            </summary>
            <remarks>
            You can use <b>DynamicXap</b> to download a package, or load the DyanmicXap from the stream of an already downloaded package.
            </remarks>
        </member>
        <member name="M:IdeaBlade.Core.DynamicXap.#ctor(System.Uri)">
            <summary>
            Creates a <b>DynamicXap</b> using the specified URI.
            </summary>
            <param name="uri"></param>
            <remarks>
            The XAP is automatically downloaded from the given URI.  Once the download has completed, the <see cref="E:IdeaBlade.Core.DynamicXap.Loaded"/> event will
            be raised and the <see cref="P:IdeaBlade.Core.Xap.IsLoaded"/> flag will be true.  If the XAP was previously downloaded and available in cache, it
            will not be downloaded again but the <see cref="E:IdeaBlade.Core.DynamicXap.Loaded"/> event will still fire.
            <para>
            Sets <see cref="P:IdeaBlade.Core.Xap.Name"/> to the <b>Uri.OriginalString</b> value.
            </para>
            </remarks>
            <example>
        <code lang="C#">
          <![CDATA[
public void DoDownload(string xapName) {
  var xap = new IdeaBlade.Core.DynamicXap(new Uri(xapName, UriKind.Relative));
  xap.Loaded += new EventHandler(xap_Loaded);
}

void xap_Loaded(object sender, EventArgs e) {
}
          ]]>
        </code>
      </example>
        </member>
        <member name="M:IdeaBlade.Core.DynamicXap.#ctor(System.IO.Stream,System.String)">
            <summary>
            Creates a <b>DynamicXap</b> from the downloaded stream.
            </summary>
            <param name="xapStream"></param>
            <param name="name">Optional name for the Xap</param>
            <remarks>
            Use this constructor when the XAP has already been downloaded.  
            </remarks>
            <example>
        <code lang="C#"> <![CDATA[
        public void DoDownload(string xapName) {
          var uri = new Uri(xapName, UriKind.Relative);
          var client = new WebClient();
          client.OpenReadCompleted += (o, e) => {
            if (e.Cancelled || e.Error != null) {
              return;
            }
            // Create a dynamic xap from the downloaded stream.
            var xap = new IdeaBlade.Core.DynamicXap(e.Result);
          };
          client.OpenReadAsync(uri);
        }
          ]]>
        </code>
      </example>
        </member>
        <member name="M:IdeaBlade.Core.DynamicXap.LoadPart(System.Windows.AssemblyPart)">
            <summary>
            Load the assembly from the specified assembly part.
            </summary>
            <param name="part"></param>
            <returns></returns>
        </member>
        <member name="E:IdeaBlade.Core.DynamicXap.Loaded">
            <summary>
            Event raised when the XAP has been downloaded and the parts collection loaded.
            </summary>
        </member>
        <member name="T:IdeaBlade.Core.DynamicXapLoadedEventArgs">
            <summary>
            Arguments passed to a <see cref="E:IdeaBlade.Core.DynamicXap.Loaded"/> event handler.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.DynamicXapLoadedEventArgs.#ctor(System.Exception,System.Boolean)">
            <summary>
            Create an instance of this class.
            </summary>
            <param name="error"></param>
            <param name="cancelled"></param>
        </member>
        <member name="P:IdeaBlade.Core.DynamicXapLoadedEventArgs.CompletedSuccessfully">
            <summary>
            Returns whether the operation completed successfully. 
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.DynamicXapLoadedEventArgs.HasError">
            <summary>
            Returns whether the operation failed.
            </summary>
        </member>
        <member name="T:IdeaBlade.Core.IdeaBladeApplication">
            <summary>
            A static class holding application-wide properties.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.IdeaBladeApplication.IsExecutingOnServer">
            <summary>
            Returns whether an action is requested on the client or the server logical tier.
            </summary>
        </member>
        <member name="T:IdeaBlade.Core.Reflection.MemberInfoFns">
            <summary>
            For internal use only.
            </summary>
        </member>
        <member name="F:IdeaBlade.Core.Reflection.MemberInfoFns.BuildMethodCallMemoized">
            <summary>
            For internal use only.
            </summary>
        </member>
        <member name="F:IdeaBlade.Core.Reflection.MemberInfoFns.BuildVoidMethodCallMemoized">
            <summary>
            For internal use only.
            </summary>
        </member>
        <member name="F:IdeaBlade.Core.Reflection.MemberInfoFns.BuildStaticMethodCallMemoized">
            <summary>
            For internal use only.
            </summary>
        </member>
        <member name="F:IdeaBlade.Core.Reflection.MemberInfoFns.BuildPropertyGetMemoized">
            <summary>
            For internal use only.
            </summary>
        </member>
        <member name="F:IdeaBlade.Core.Reflection.MemberInfoFns.BuildPropertySetMemoized">
            <summary>
            For internal use only.
            </summary>
        </member>
        <member name="F:IdeaBlade.Core.Reflection.MemberInfoFns.BuildCreateInstanceMemoized">
            <summary>
            For internal use only.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.MemberInfoFns.BuildCreateInstance(System.Type)">
            <summary>
            For internal use only.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.MemberInfoFns.BuildCreateInstance``2">
            <summary>
            For internal use only.
            </summary>
            <typeparam name="TIn"></typeparam>
            <typeparam name="TOut"></typeparam>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.MemberInfoFns.BuildCreateInstance``1(System.Type)">
            <summary>
            For internal use only
            </summary>
            <typeparam name="TOut"></typeparam>
            <param name="inputArgType"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.MemberInfoFns.BuildPropertyGet``1(System.Reflection.PropertyInfo)">
            <summary>
            For internal use only.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.MemberInfoFns.BuildGenericMethodCallFunc``2(System.Reflection.MethodInfo)">
            <summary>
            For internal use only.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.MemberInfoFns.FastCreateInstance(System.Type)">
            <summary>
            For internal use only.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.MemberInfoFns.FastPropertyGet(System.Object,System.Reflection.PropertyInfo)">
            <summary>
            For internal use only.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.MemberInfoFns.FastPropertyGet(System.Object,System.String)">
            <summary>
            For internal use only.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.MemberInfoFns.FastMethodInvoke(System.Object,System.Reflection.MethodInfo,System.Object[])">
            <summary>
            For internal use only.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.MemberInfoFns.FastVoidMethodInvoke(System.Object,System.Reflection.MethodInfo,System.Object[])">
            <summary>
            For internal use only.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.MemberInfoFns.FastStaticMethodInvoke(System.Reflection.MethodInfo,System.Object[])">
            <summary>
            For internal use only.
            </summary>
        </member>
        <member name="T:IdeaBlade.Core.Reflection.AnonymousFns">
            <summary>
            A collection of static utility methods relating to anonymous types.
            </summary>
            <remarks>
            Most methods here are meant for internal use only (or very advanced use cases), except
            for <see cref="M:IdeaBlade.Core.Reflection.AnonymousFns.IsAnonymousType(System.Type)">IsAnonymousType</see>, which you can use to
            check the return type of a query.  In Silverlight applications, which do not support
            binding to anoymous types, you can use this method along with the <see cref="T:IdeaBlade.Core.DynamicTypeConverter"/>
            to convert your results to a type suitable for binding.
            </remarks>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.AnonymousFns.IsAnonymousType(System.Type,System.Boolean)">
            <summary>
            Returns whether the specified type is an anonymous type.
            </summary>
            <param name="type"></param>
            <param name="includeDynamicCheck">Also check if the type is a dynamic type</param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.AnonymousFns.IsAnonymousType(System.Type)">
            <summary>
            Returns whether the specified type is an anonymous type.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.AnonymousFns.Construct(System.Type,System.Object[])">
            <summary>
            Construct a single instance of an anonymous type with a specified set of values
            </summary>
            <param name="anonType"></param>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.AnonymousFns.ConstructMany(System.Type,System.Collections.Generic.IEnumerable{System.Object[]})">
            <summary>
            Construct multiple instances of a specified anonymous type each with a specified set of values
            </summary>
            <param name="anonType"></param>
            <param name="valueArrays">Each item in the enumeration contains an object[] containing the values 
            for a new anonymous instance</param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.AnonymousFns.ConstructFromPrototype``1(``0,System.Object[])">
            <summary>
            Construct a single instance of an anonymous type given a prototype instances and 
            a specified set of values
            </summary>
            <typeparam name="AnonymousType"></typeparam>
            <param name="protoType"></param>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.AnonymousFns.ConstructFromPrototype``3(``0,``1,``2)">
            <summary>
            Construct a single instance of an anonymous type given a prototype instances and 
            a specified set of values
            </summary>
            <typeparam name="AnonymousType"></typeparam>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <param name="protoType"></param>
            <param name="value1"></param>
            <param name="value2"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.AnonymousFns.ConstructFromPrototype``4(``0,``1,``2,``3)">
            <summary>
            Construct a single instance of an anonymous type given a prototype instances and 
            a specified set of values
            </summary>
            <typeparam name="AnonymousType"></typeparam>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <param name="protoType"></param>
            <param name="value1"></param>
            <param name="value2"></param>
            <param name="value3"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.AnonymousFns.BuildConstructorDelegate(System.Type,System.Boolean)">
            <summary>
            Construct a delegate that can build an instance of an anonymous type
            </summary>
            <param name="anonType"></param>
            <param name="isStronglyTyped"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.AnonymousFns.Deconstruct(System.Object,System.Boolean)">
            <summary>
            Deconstruct an anonymous type into an object array.
            </summary>
            <param name="item"></param>
            <param name="shouldRecurse">Whether to recursively perform the same operation on any values in the 
            anonymous type that are themselves instances of an anonymous type</param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.AnonymousFns.Deconstruct``1(``0,System.Boolean)">
            <summary>
            Deconstruct an anonymous type into an object array.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="item"></param>
            <param name="shouldRecurse">Whether to recursively perform the same operation on any values in the 
            anonymous type that are themselves instances of an anonymous type</param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.AnonymousFns.DeconstructMany(System.Collections.IEnumerable,System.Boolean,System.Type)">
            <summary>
            Deconstruct multiple instances of the same anonymous type into an IEnumerable of Object arrays.
            </summary>
            <param name="anonItems"></param>
            <param name="shouldRecurse">Whether to recursively perform the same operation on any values in the 
            anonymous type that are themselves instances of an anonymous type</param>
            <param name="anonymousItemType"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.AnonymousFns.DeconstructMany``1(System.Collections.Generic.IEnumerable{``0},System.Boolean)">
            <summary>
            Deconstruct multiple instances of the same anonymous type into an IEnumerable of Object arrays.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="anonItems"></param>
            <param name="shouldRecurse">Whether to recursively perform the same operation on any values in the 
            anonymous type that are themselves instances of an anonymous type</param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.AnonymousFns.BuildDeconstructorFunc(System.Type,System.Boolean)">
            <summary>
            Returns a function that can deconstruct instances of a specified anonymous type.
            </summary>
            <param name="anonType"></param>
            <param name="shouldRecurse">Whether to recursively perform the same operation on any values in the 
            anonymous type that are themselves instances of an anonymous type</param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.AnonymousFns.BuildDeconstructorFunc``1(System.Boolean)">
            <summary>
            Returns a function that can deconstruct instances of a specified anonymous type.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="shouldRecurse">Whether to recursively perform the same operation on any values in the 
            anonymous type that are themselves instances of an anonymous type</param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.AnonymousFns.CustomConvert(System.Object,System.Type)">
            <summary>
            For internal use only.
            </summary>
            <param name="input"></param>
            <param name="toType"></param>
            <returns></returns>
        </member>
        <member name="T:IdeaBlade.Core.Reflection.INeedsCustomConversion">
            <summary>
            Internal use only.
            </summary>
        </member>
        <member name="T:IdeaBlade.Core.Reflection.ICustomConvertible">
            <summary>
            Internal use only.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.ICustomConvertible.ConvertTo(System.Type)">
            <summary>
            
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="T:IdeaBlade.Core.Reflection.ReflectionFns">
            <summary>
            A collection of static utility methods to assist in using the .NET reflection API.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.ReflectionFns.GetEmbeddedFile(System.Reflection.Assembly,System.String)">
            <summary>
            Returns the contents of a file embedded in an assembly.
            </summary>
            <param name="aAssembly"></param>
            <param name="embeddedFileName"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.ReflectionFns.GetManifestItem(System.Reflection.Assembly,System.String)">
            <summary>
            Returns a manifest resource stream associated with an assembly and an item name.
            </summary>
            <param name="pAssembly">The assembly where the embedded stream is stored</param>
            <param name="pItemName">The unqualified name of the stream</param>
            <returns>A resource stream</returns>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.ReflectionFns.GetTypesImplementing(System.Type,System.Reflection.Assembly)">
            <summary>
            
            </summary>
            <param name="type"></param>
            <param name="assembly"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.ReflectionFns.GetTypesImplementing(System.Type,System.String)">
            <summary>
            
            </summary>
            <param name="type"></param>
            <param name="assemblyName"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.ReflectionFns.GetTypesImplementing(System.Type,System.Collections.Generic.IEnumerable{System.Reflection.Assembly})">
            <summary>
            Returns a list of all of the types in one or more assemblies that implement a specific
            interface or extend a specific class.
            </summary>
            <param name="type">Interface or base type</param>
            <param name="assemblies"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.ReflectionFns.GetTypesImplementing(System.Type,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Returns a list of all of the types in one or more named assemblies that implement a specific
            interface or extend a specific class.
            </summary>
            <param name="type">Interface or base type</param>
            <param name="assemblyNames">Assemblies to load for probing</param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.ReflectionFns.GetTypesImplementing(System.Type,System.Collections.Generic.IEnumerable{System.String},IdeaBlade.Core.Cardinality,System.Boolean)">
            <summary>
            Returns a list of all of the types in one or more named assemblies that implement a specific
            interface or extend a specific class.
            </summary>
            <param name="type">Interface or base type</param>
            <param name="probeAssemblyNames">Assemblies to load for probing</param>
            <param name="expectedCardinality"></param>
            <param name="checkUserAssembliesIfNotFound">If not found in the specified assemblies will
            also check all loaded user assemblies when this parameter is True</param>
            <returns></returns>
            <exception cref="T:IdeaBlade.Core.IdeaBladeException">Thrown when expected cardinality violated</exception>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.ReflectionFns.GetTypeImplementing(System.Type,System.Collections.Generic.IEnumerable{System.String},IdeaBlade.Core.Cardinality,System.Boolean)">
            <summary>
            Returns the type implementing a specific interface or extending a specific class.
            </summary>
            <param name="type">Interface or base type</param>
            <param name="probeAssemblyNames">Assemblies to load for probing</param>
            <param name="expectedCardinality"></param>
            <param name="checkUserAssembliesIfNotFound"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.ReflectionFns.GetInstanceImplementing(System.Type,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Create an instance of a type that either extends or implements the specified type or interface. 
            </summary>
            <param name="type">Type of instance to probe for and create.</param>
            <param name="probeAssemblyNames">Assemblies to search</param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.ReflectionFns.GetInstancesImplementing(System.Type,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Create a list of instances of those types that either extend or implement the specified type or interface. 
            </summary>
            <param name="type">Type of instance to probe for and create</param>
            <param name="probeAssemblyNames">Assemblies to search</param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.ReflectionFns.GetInstanceImplementing``1(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Create an instance of a type that either extends or implements the specified type or interface. 
            </summary>
            <typeparam name="T">Type of instance to probe for and create</typeparam>
            <param name="probeAssemblyNames">Assemblies to search</param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.ReflectionFns.GetInstancesImplementing``1(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Create a list of instances of those types that either extend or implement the specified type or interface. 
            </summary>
            <typeparam name="T">Type of instance to probe for and create</typeparam>
            <param name="probeAssemblyNames">Assemblies to search</param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.ReflectionFns.GetTypeLevelAttributes(System.Type,System.Collections.Generic.IEnumerable{System.Reflection.Assembly})">
             <summary>
            
             </summary>
             <param name="attributeType"></param>
             <param name="assemblies"></param>
             <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.ReflectionFns.GetTypeAttributesWithinAssemblyCore(System.Type,System.Reflection.Assembly)">
            <summary>
            Returns a list of all of the types in an assembly that implement a specific
            interface or extend a specific class.
            </summary>
            <param name="attributeType">Interface or base type</param>
            <param name="assembly"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.ReflectionFns.GetTypesImplementingCore(System.Type,System.Reflection.Assembly)">
            <summary>
            Returns a list of all of the types in an assembly that implement a specific
            interface or extend a specific class.
            </summary>
            <param name="type">Interface or base type</param>
            <param name="assembly"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.ReflectionFns.GetAssembly(System.String)">
            <summary>
            Return an Assembly given an assembly name or null if it cannot be found or loaded; A list of invalid assembly names is retained 
            for better perf on the next call for the same name.
            </summary>
            <param name="assemblyName"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.ReflectionFns.GetLatestType(System.String,System.Boolean,System.Boolean)">
            <summary>
            Returns the latest version of a type given its name; optionally throws an error 
            if no matching type can be found.
            </summary>
            <param name="pTypeName">A type name to locate</param>
            <param name="pThrowOnError">Whether to throw an error if a matching type cannot be found</param>
            <param name="pIgnoreCase">Whether to ignore case when attempting a match</param>
            <returns>The latest version of a type with the specified name</returns>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.ReflectionFns.GetListItemType(System.Object)">
            <summary>
            Returns the data type of the items in the specified data source. 
            </summary>
            <param name="pValue"></param>
            <returns></returns>
            <remarks>
            This is very similar to the <b>ListBindingHelper.GetListItemType</b> but does not depend on 
            System.Windows.WinForms.
            </remarks>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.ReflectionFns.GetProperty(System.Type,System.String)">
            <summary>
            Can be used in place of <see cref="M:System.Type.GetProperty(System.String)"/>.
            Only finds public instance properties.
            </summary>
            <param name="pType"></param>
            <param name="pPropertyName"></param>
            <remarks>
            Should be used in place of Type.GetProperty(propertyName) because
            of problems with AmbiguousMatchException. When multiple public properties
            exist with the same name (can be caused by marking a property with 'new'
            in a derived class) this method returns the most derived class that implements
            the property.
            </remarks>
            <seealso cref="M:IdeaBlade.Core.Reflection.TypeFns.FindPropertyOrField(System.Type,System.String,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.ReflectionFns.GetProperty(System.Type,System.String,System.Reflection.BindingFlags)">
            <summary>
            Can be used in place of <see cref="M:System.Type.GetProperty(System.String)"/>.
            </summary>
            <param name="pType"></param>
            <param name="pPropertyName"></param>
            <param name="flags"></param>
            <remarks>
            Should be used in place of Type.GetProperty(propertyName) because
            of problems with AmbiguousMatchException. When multiple public properties
            exist with the same name (can be caused by marking a property with 'new'
            in a derived class) this method returns the most derived class that implements
            the property.
            </remarks>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.ReflectionFns.GetDelegate``1(System.String,System.String,System.Type[])">
            <summary>
            Returns a delegate of the indicated type.
            </summary>
            <typeparam name="T">Delegate type</typeparam>
            <param name="pTypeName">Assembly-qualified type name</param>
            <param name="pMethodName">Name of static method</param>
            <param name="pSignature">Optional method signature</param>
            <returns></returns>
            <remarks>
            <paramref name="pSignature"/> is required only if the <paramref name="pMethodName"/> is overloaded.
            </remarks>
        </member>
        <member name="T:IdeaBlade.Core.Reflection.TypeFns">
            <summary>
            A collection of static methods used to provide additional <see cref="T:System.Type"/> related services.
            </summary>
        </member>
        <member name="F:IdeaBlade.Core.Reflection.TypeFns.DecimalTypes">
            <summary>
            Returns an array of decimal types.
            </summary>
        </member>
        <member name="F:IdeaBlade.Core.Reflection.TypeFns.IntegerTypes">
            <summary>
            Returns an array of integer types.
            </summary>
        </member>
        <member name="F:IdeaBlade.Core.Reflection.TypeFns.NumericTypes">
            <summary>
            Returns an array of numeric types.
            </summary>
        </member>
        <member name="F:IdeaBlade.Core.Reflection.TypeFns.PredefinedTypes">
            <summary>
            Returns an array of predefined types.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.TypeFns.GetTypeName(System.Type)">
            <summary>
            Returns the name of either the specified type or its non-nullable counterpart.
            </summary>
            <param name="type"></param>
            <returns>the name of the given type</returns>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.TypeFns.IsEnumType(System.Type)">
            <summary>
            Returns whether the specified type (or its non-nullable counterpart) represents an enumeration.
            </summary>
            <param name="type"></param>
            <returns>true if the specified type represents an enumeration; false otherwise</returns>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.TypeFns.IsNumericType(System.Type)">
            <summary>
            Returns whether the specified type (or its non-nullable counterpart) represents a numeric type.
            </summary>
            <param name="type"></param>
            <returns>true if the specified type is numeric; false otherwise</returns>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.TypeFns.IsIntegralType(System.Type)">
            <summary>
            Returns whether the specified type (or its non-nullable counterpart) represents an integer type.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.TypeFns.IsSignedIntegralType(System.Type)">
            <summary>
            Returns whether the specified type (or its non-nullable counterpart) represents a signed integer type.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.TypeFns.IsUnsignedIntegralType(System.Type)">
            <summary>
            Returns whether the specified type (or its non-nullable counterpart) represents an unsigned integer type.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.TypeFns.IsGenericQueryableType(System.Type)">
            <summary>
            Think about making public if used again.
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.TypeFns.IsGroupingType(System.Type)">
            <summary>
            Returns true if the Type is an IGrouping.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.TypeFns.GetGroupingInterface(System.Type)">
            <summary>
            Returns the IGrouping interface implemented by the type.
            </summary>
            <param name="type"></param>
            <returns>May return null if the specified type is not a grouping type</returns>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.TypeFns.GetGenericArgument(System.Type)">
            <summary>
            Gets a single generic argument from a specified type.
            </summary>
            <param name="type"></param>
            <returns>null if it can't find one or result is ambiguous</returns>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.TypeFns.GetNullableType(System.Type)">
            <summary>
            Gets the nullable type that corresponds to the given type.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.TypeFns.GetNonNullableType(System.Type)">
            <summary>
            Returns either the specified type or its non-nullable counterpart.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.TypeFns.GetElementType(System.Type)">
            <summary>
            Returns the element type of any enumerable type;
            </summary>
            <param name="seqType"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.TypeFns.FindIEnumerable(System.Type)">
            <summary>
            
            </summary>
            <param name="seqType"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.TypeFns.IsPredefinedType(System.Type)">
            <summary>
            Returns whether the specified type is one of the <see cref="F:IdeaBlade.Core.Reflection.TypeFns.PredefinedTypes"/>.
            </summary>
            <param name="type"></param>
            <returns>true if the specified type is a predefined type; false otherwise</returns>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.TypeFns.IsPredefinedType(System.Type,System.Boolean)">
            <summary>
            Returns whether the specified type is one of the <see cref="F:IdeaBlade.Core.Reflection.TypeFns.PredefinedTypes"/> and
            optionally includes nullable versions of the same in the check.
            </summary>
            <param name="type"></param>
            <param name="includeNullable"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.TypeFns.IsNullableType(System.Type)">
            <summary>
            Returns whether the specified type is a nullable generic type, i.e. Nullable{T}.
            </summary>
            <param name="type"></param>
            <returns>true if the specified type is a nullable generic type; false otherwise</returns>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.TypeFns.GetDefaultValue(System.Type)">
            <summary>
            Gets the default value for a specified type.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.TypeFns.FindPropertyOrField(System.Type,System.String,System.Boolean,System.Boolean)">
            <summary>
            Finds a specific public property or field. Will be automatically restricted as well by execution environment restrictions ( e.g. Silverlight).
            </summary>
            <param name="type"></param>
            <param name="memberName"></param>
            <param name="isPublic"></param>
            <param name="isStatic"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.TypeFns.FindPropertyOrField(System.Type,System.String,System.Reflection.BindingFlags)">
            <summary>
            Finds a specific property or field
            </summary>
            <param name="type"></param>
            <param name="memberName"></param>
            <param name="bindingFlags"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.TypeFns.GetMethodByExample``2(System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Type[])">
            <summary>
            For internal use only.
            </summary>
            <typeparam name="TIn"></typeparam>
            <typeparam name="TOut"></typeparam>
            <param name="prototypeLambda"></param>
            <param name="resolvedTypes"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.TypeFns.FindMethod(System.Type,System.String,System.Type[])">
            <summary>
            Finds a specific public method.
            </summary>
            <param name="type"></param>
            <param name="methodName"></param>
            <param name="parameterTypes"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.TypeFns.FindMethod(System.Type,System.String,System.Reflection.BindingFlags,System.Type[],System.Type[])">
            <summary>
            Finds a specific method.
            </summary>
            <param name="type"></param>
            <param name="methodName"></param>
            <param name="flags"></param>
            <param name="genericArgTypes"></param>
            <param name="parameterTypes"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.TypeFns.FindMethods(System.Type,System.String,System.Reflection.BindingFlags,System.Type[],System.Type[])">
            <summary>
            Finds all the methods that match specific criteria.
            </summary>
            <param name="type"></param>
            <param name="methodName"></param>
            <param name="flags"></param>
            <param name="genericArgTypes"></param>
            <param name="parameterTypes"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.TypeFns.FindMethod(System.Type,System.String,System.Boolean,System.Type[])">
            <summary>
            Finds a specific method.
            </summary>
            <param name="type"></param>
            <param name="methodName"></param>
            <param name="isStatic"></param>
            <param name="parameterTypes"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.TypeFns.FindMethod(System.Type,System.String,System.Reflection.BindingFlags,System.Type[])">
            <summary>
            Finds a specific method.
            </summary>
            <param name="type"></param>
            <param name="methodName"></param>
            <param name="flags"></param>
            <param name="parameterTypes"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.TypeFns.FindMethods(System.Type,System.String,System.Reflection.BindingFlags,System.Type[])">
            <summary>
            Finds specific methods.
            </summary>
            <param name="type"></param>
            <param name="methodName"></param>
            <param name="flags"></param>
            <param name="parameterTypes"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.TypeFns.FindGenericMethods(System.Type,System.String,System.Reflection.BindingFlags,System.Type[])">
            <summary>
            Finds a collection of generic methods. 
            </summary>
            <param name="type"></param>
            <param name="methodName">Is case insensitive</param>
            <param name="flags"></param>
            <param name="genericArgTypes"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.TypeFns.FindPropertyCached(System.Type,System.String,System.Boolean,System.Boolean)">
            <summary>
            Same as <see cref="M:IdeaBlade.Core.Reflection.TypeFns.FindPropertyOrField(System.Type,System.String,System.Boolean,System.Boolean)"/> but returns the cached result if it exists.
            </summary>
            <param name="type"></param>
            <param name="propertyName"></param>
            <param name="isPublic"></param>
            <param name="isStatic"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.TypeFns.GetSelfAndBaseTypes(System.Type)">
            <summary>
            Returns a collection of types from which the given type directly inherits or implements.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.TypeFns.GetSelfAndBaseClasses(System.Type)">
            <summary>
            Returns a collection of classes (not interfaces) from which the given type directly inherits.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.TypeFns.IsCompatibleWith(System.Type,System.Type)">
            <summary>
            Determines whether the source type is compatible with the given target type.
            </summary>
            <param name="source"></param>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.TypeFns.MakeGenericList(System.Type)">
            <summary>
            Constructs a generic list.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.TypeFns.ConstructGenericInstance(System.Type,System.Type[])">
            <summary>
            Constructs a generic instance.
            </summary>
            <param name="genericType"></param>
            <param name="argTypes"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.TypeFns.ConstructGenericInstance(System.Type,System.Type[],System.Object[])">
            <summary>
            Constructs a generic instance. Can only access public constructors.
            </summary>
            <param name="genericType"></param>
            <param name="argTypes"></param>
            <param name="constructorParams"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Reflection.TypeFns.InitializeType(System.Type)">
            <summary>
            Will initialize a type by calling its static ( class) ctor and insures that it is only called once.
            </summary>
            <param name="t"></param>
        </member>
        <member name="T:IdeaBlade.Core.Wcf.Extensions.CommunicationSettings">
            <summary>
            Used to programmatically set some communication-related settings.
            </summary>
            <remarks>
            Can be used in Silverlight and n-tier applications to override certain communications defaults.
            Use the <see cref="P:IdeaBlade.Core.Wcf.Extensions.CommunicationSettings.CompressionLevel"/> to choose a level of compression based on performance vs. compression
            requirements. 
            </remarks>
        </member>
        <member name="M:IdeaBlade.Core.Wcf.Extensions.CommunicationSettings.#ctor">
            <summary>
            Create an instance of this class with default values.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.Wcf.Extensions.CommunicationSettings.#ctor(Ionic.Zlib.CompressionLevel)">
            <summary>
            Create an instance of this class with the values provided.
            </summary>
            <param name="compressionLevel"></param>
        </member>
        <member name="P:IdeaBlade.Core.Wcf.Extensions.CommunicationSettings.Default">
            <summary>
            The default settings instance.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.Wcf.Extensions.CommunicationSettings.CompressionLevel">
            <summary>
            Gets or sets the compression level for requests and responses between the client application and server.
            </summary>
            <remarks>
            By default, compression is performed on the client for requests to be sent to the server; and on the server for
            responses to be sent to the client.  
            <para>
            The default level is "default", which is intended to provide a balance between speed and compression efficiency.
            Use a level of "None" to turn off compression.  You may use different settings on the client and server, and modify the setting 
            at any time.  When a message is to be compressed, the current value of <b>CommunicationSettings.Default.CompressionLevel</b>
            is used to determine the compression in effect.
            </para>
            </remarks>
        </member>
        <member name="T:IdeaBlade.Core.Wcf.Extensions.GZipMessageEncodingBindingElement">
            <summary>
            This is the binding element that, when plugged into a custom binding, will enable the GZip encoder.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.Wcf.Extensions.GZipMessageEncodingBindingElement.#ctor">
            <summary>
            Create an instance of this class, wrapping a <see cref="T:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement"/>.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.Wcf.Extensions.GZipMessageEncodingBindingElement.#ctor(System.ServiceModel.Channels.MessageEncodingBindingElement)">
            <summary>
            Create an instance of this class, wrapping the specified <see cref="T:System.ServiceModel.Channels.MessageEncodingBindingElement"/>.
            </summary>
            <param name="messageEncoderBindingElement"></param>
        </member>
        <member name="M:IdeaBlade.Core.Wcf.Extensions.GZipMessageEncodingBindingElement.CreateMessageEncoderFactory">
            <summary>
            Main entry point into the encoder binding element. Called by WCF to get the factory that will create the
            message encoder
            </summary>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Wcf.Extensions.GZipMessageEncodingBindingElement.Clone">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Wcf.Extensions.GZipMessageEncodingBindingElement.GetProperty``1(System.ServiceModel.Channels.BindingContext)">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Wcf.Extensions.GZipMessageEncodingBindingElement.BuildChannelFactory``1(System.ServiceModel.Channels.BindingContext)">
            <summary>
            
            </summary>
            <typeparam name="TChannel"></typeparam>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.Wcf.Extensions.GZipMessageEncodingBindingElement.CanBuildChannelFactory``1(System.ServiceModel.Channels.BindingContext)">
            <summary>
            
            </summary>
            <typeparam name="TChannel"></typeparam>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="P:IdeaBlade.Core.Wcf.Extensions.GZipMessageEncodingBindingElement.InnerMessageEncodingBindingElement">
            <summary>
            Gets or set the inner <see cref="T:System.ServiceModel.Channels.MessageEncodingBindingElement"/>.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.Wcf.Extensions.GZipMessageEncodingBindingElement.MessageVersion">
            <summary>
            
            </summary>
        </member>
        <member name="T:Ionic.Crc.CRC32">
            <summary>
              Computes a CRC-32. The CRC-32 algorithm is parameterized - you
              can set the polynomial and enable or disable bit
              reversal. This can be used for GZIP, BZip2, or ZIP.
            </summary>
            <remarks>
              This type is used internally by DotNetZip; it is generally not used
              directly by applications wishing to create, read, or manipulate zip
              archive files.
            </remarks>
        </member>
        <member name="M:Ionic.Crc.CRC32.GetCrc32(System.IO.Stream)">
            <summary>
            Returns the CRC32 for the specified stream.
            </summary>
            <param name="input">The stream over which to calculate the CRC32</param>
            <returns>the CRC32 calculation</returns>
        </member>
        <member name="M:Ionic.Crc.CRC32.GetCrc32AndCopy(System.IO.Stream,System.IO.Stream)">
            <summary>
            Returns the CRC32 for the specified stream, and writes the input into the
            output stream.
            </summary>
            <param name="input">The stream over which to calculate the CRC32</param>
            <param name="output">The stream into which to deflate the input</param>
            <returns>the CRC32 calculation</returns>
        </member>
        <member name="M:Ionic.Crc.CRC32.ComputeCrc32(System.Int32,System.Byte)">
            <summary>
              Get the CRC32 for the given (word,byte) combo.  This is a
              computation defined by PKzip for PKZIP 2.0 (weak) encryption.
            </summary>
            <param name="W">The word to start with.</param>
            <param name="B">The byte to combine it with.</param>
            <returns>The CRC-ized result.</returns>
        </member>
        <member name="M:Ionic.Crc.CRC32.SlurpBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the value for the running CRC32 using the given block of bytes.
            This is useful when using the CRC32() class in a Stream.
            </summary>
            <param name="block">block of bytes to slurp</param>
            <param name="offset">starting point in the block</param>
            <param name="count">how many bytes within the block to slurp</param>
        </member>
        <member name="M:Ionic.Crc.CRC32.UpdateCRC(System.Byte)">
            <summary>
              Process one byte in the CRC.
            </summary>
            <param name = "b">the byte to include into the CRC .  </param>
        </member>
        <member name="M:Ionic.Crc.CRC32.UpdateCRC(System.Byte,System.Int32)">
            <summary>
              Process a run of N identical bytes into the CRC.
            </summary>
            <remarks>
              <para>
                This method serves as an optimization for updating the CRC when a
                run of identical bytes is found. Rather than passing in a buffer of
                length n, containing all identical bytes b, this method accepts the
                byte value and the length of the (virtual) buffer - the length of
                the run.
              </para>
            </remarks>
            <param name = "b">the byte to include into the CRC.  </param>
            <param name = "n">the number of times that byte should be repeated. </param>
        </member>
        <member name="M:Ionic.Crc.CRC32.Combine(System.Int32,System.Int32)">
            <summary>
              Combines the given CRC32 value with the current running total.
            </summary>
            <remarks>
              This is useful when using a divide-and-conquer approach to
              calculating a CRC.  Multiple threads can each calculate a
              CRC32 on a segment of the data, and then combine the
              individual CRC32 values at the end.
            </remarks>
            <param name="crc">the crc value to be combined with this one</param>
            <param name="length">the length of data the CRC value was calculated on</param>
        </member>
        <member name="M:Ionic.Crc.CRC32.#ctor">
            <summary>
              Create an instance of the CRC32 class using the default settings: no
              bit reversal, and a polynomial of 0xEDB88320.
            </summary>
        </member>
        <member name="M:Ionic.Crc.CRC32.#ctor(System.Boolean)">
            <summary>
              Create an instance of the CRC32 class, specifying whether to reverse
              data bits or not.
            </summary>
            <param name='reverseBits'>
              specify true if the instance should reverse data bits.
            </param>
            <remarks>
              <para>
                In the CRC-32 used by BZip2, the bits are reversed. Therefore if you
                want a CRC32 with compatibility with BZip2, you should pass true
                here. In the CRC-32 used by GZIP and PKZIP, the bits are not
                reversed; Therefore if you want a CRC32 with compatibility with
                those, you should pass false.
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.Crc.CRC32.#ctor(System.Int32,System.Boolean)">
             <summary>
               Create an instance of the CRC32 class, specifying the polynomial and
               whether to reverse data bits or not.
             </summary>
             <param name='polynomial'>
               The polynomial to use for the CRC, expressed in the reversed (LSB)
               format: the highest ordered bit in the polynomial value is the
               coefficient of the 0th power; the second-highest order bit is the
               coefficient of the 1 power, and so on. Expressed this way, the
               polynomial for the CRC-32C used in IEEE 802.3, is 0xEDB88320.
             </param>
             <param name='reverseBits'>
               specify true if the instance should reverse data bits.
             </param>
            
             <remarks>
               <para>
                 In the CRC-32 used by BZip2, the bits are reversed. Therefore if you
                 want a CRC32 with compatibility with BZip2, you should pass true
                 here for the <c>reverseBits</c> parameter. In the CRC-32 used by
                 GZIP and PKZIP, the bits are not reversed; Therefore if you want a
                 CRC32 with compatibility with those, you should pass false for the
                 <c>reverseBits</c> parameter.
               </para>
             </remarks>
        </member>
        <member name="M:Ionic.Crc.CRC32.Reset">
            <summary>
              Reset the CRC-32 class - clear the CRC "remainder register."
            </summary>
            <remarks>
              <para>
                Use this when employing a single instance of this class to compute
                multiple, distinct CRCs on multiple, distinct data blocks.
              </para>
            </remarks>
        </member>
        <member name="P:Ionic.Crc.CRC32.TotalBytesRead">
            <summary>
              Indicates the total number of bytes applied to the CRC.
            </summary>
        </member>
        <member name="P:Ionic.Crc.CRC32.Crc32Result">
            <summary>
            Indicates the current CRC for all blocks slurped in.
            </summary>
        </member>
        <member name="T:Ionic.Crc.CrcCalculatorStream">
             <summary>
             A Stream that calculates a CRC32 (a checksum) on all bytes read,
             or on all bytes written.
             </summary>
            
             <remarks>
             <para>
             This class can be used to verify the CRC of a ZipEntry when
             reading from a stream, or to calculate a CRC when writing to a
             stream.  The stream should be used to either read, or write, but
             not both.  If you intermix reads and writes, the results are not
             defined.
             </para>
            
             <para>
             This class is intended primarily for use internally by the
             DotNetZip library.
             </para>
             </remarks>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.#ctor(System.IO.Stream)">
            <summary>
            The default constructor.
            </summary>
            <remarks>
              <para>
                Instances returned from this constructor will leave the underlying
                stream open upon Close().  The stream uses the default CRC32
                algorithm, which implies a polynomial of 0xEDB88320.
              </para>
            </remarks>
            <param name="stream">The underlying stream</param>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.#ctor(System.IO.Stream,System.Boolean)">
            <summary>
              The constructor allows the caller to specify how to handle the
              underlying stream at close.
            </summary>
            <remarks>
              <para>
                The stream uses the default CRC32 algorithm, which implies a
                polynomial of 0xEDB88320.
              </para>
            </remarks>
            <param name="stream">The underlying stream</param>
            <param name="leaveOpen">true to leave the underlying stream
            open upon close of the <c>CrcCalculatorStream</c>; false otherwise.</param>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.#ctor(System.IO.Stream,System.Int64)">
            <summary>
              A constructor allowing the specification of the length of the stream
              to read.
            </summary>
            <remarks>
              <para>
                The stream uses the default CRC32 algorithm, which implies a
                polynomial of 0xEDB88320.
              </para>
              <para>
                Instances returned from this constructor will leave the underlying
                stream open upon Close().
              </para>
            </remarks>
            <param name="stream">The underlying stream</param>
            <param name="length">The length of the stream to slurp</param>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.#ctor(System.IO.Stream,System.Int64,System.Boolean)">
            <summary>
              A constructor allowing the specification of the length of the stream
              to read, as well as whether to keep the underlying stream open upon
              Close().
            </summary>
            <remarks>
              <para>
                The stream uses the default CRC32 algorithm, which implies a
                polynomial of 0xEDB88320.
              </para>
            </remarks>
            <param name="stream">The underlying stream</param>
            <param name="length">The length of the stream to slurp</param>
            <param name="leaveOpen">true to leave the underlying stream
            open upon close of the <c>CrcCalculatorStream</c>; false otherwise.</param>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.#ctor(System.IO.Stream,System.Int64,System.Boolean,Ionic.Crc.CRC32)">
            <summary>
              A constructor allowing the specification of the length of the stream
              to read, as well as whether to keep the underlying stream open upon
              Close(), and the CRC32 instance to use.
            </summary>
            <remarks>
              <para>
                The stream uses the specified CRC32 instance, which allows the
                application to specify how the CRC gets calculated.
              </para>
            </remarks>
            <param name="stream">The underlying stream</param>
            <param name="length">The length of the stream to slurp</param>
            <param name="leaveOpen">true to leave the underlying stream
            open upon close of the <c>CrcCalculatorStream</c>; false otherwise.</param>
            <param name="crc32">the CRC32 instance to use to calculate the CRC32</param>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read from the stream
            </summary>
            <param name="buffer">the buffer to read</param>
            <param name="offset">the offset at which to start</param>
            <param name="count">the number of bytes to read</param>
            <returns>the number of bytes actually read</returns>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Write to the stream.
            </summary>
            <param name="buffer">the buffer from which to write</param>
            <param name="offset">the offset at which to start writing</param>
            <param name="count">the number of bytes to write</param>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.Flush">
            <summary>
            Flush the stream.
            </summary>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Seeking is not supported on this stream. This method always throws
            <see cref="T:System.NotSupportedException"/>
            </summary>
            <param name="offset">N/A</param>
            <param name="origin">N/A</param>
            <returns>N/A</returns>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.SetLength(System.Int64)">
            <summary>
            This method always throws
            <see cref="T:System.NotSupportedException"/>
            </summary>
            <param name="value">N/A</param>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.Close">
            <summary>
            Closes the stream.
            </summary>
        </member>
        <member name="P:Ionic.Crc.CrcCalculatorStream.TotalBytesSlurped">
             <summary>
               Gets the total number of bytes run through the CRC32 calculator.
             </summary>
            
             <remarks>
               This is either the total number of bytes read, or the total number of
               bytes written, depending on the direction of this stream.
             </remarks>
        </member>
        <member name="P:Ionic.Crc.CrcCalculatorStream.Crc">
            <summary>
              Provides the current CRC for all blocks slurped in.
            </summary>
            <remarks>
              <para>
                The running total of the CRC is kept as data is written or read
                through the stream.  read this property after all reads or writes to
                get an accurate CRC for the entire stream.
              </para>
            </remarks>
        </member>
        <member name="P:Ionic.Crc.CrcCalculatorStream.LeaveOpen">
            <summary>
              Indicates whether the underlying stream will be left open when the
              <c>CrcCalculatorStream</c> is Closed.
            </summary>
            <remarks>
              <para>
                Set this at any point before calling <see cref="M:Ionic.Crc.CrcCalculatorStream.Close"/>.
              </para>
            </remarks>
        </member>
        <member name="P:Ionic.Crc.CrcCalculatorStream.CanRead">
            <summary>
            Indicates whether the stream supports reading.
            </summary>
        </member>
        <member name="P:Ionic.Crc.CrcCalculatorStream.CanSeek">
            <summary>
              Indicates whether the stream supports seeking.
            </summary>
            <remarks>
              <para>
                Always returns false.
              </para>
            </remarks>
        </member>
        <member name="P:Ionic.Crc.CrcCalculatorStream.CanWrite">
            <summary>
            Indicates whether the stream supports writing.
            </summary>
        </member>
        <member name="P:Ionic.Crc.CrcCalculatorStream.Length">
            <summary>
              Returns the length of the underlying stream.
            </summary>
        </member>
        <member name="P:Ionic.Crc.CrcCalculatorStream.Position">
            <summary>
              The getter for this property returns the total bytes read.
              If you use the setter, it will throw
            <see cref="T:System.NotSupportedException"/>.
            </summary>
        </member>
        <member name="T:Ionic.Zlib.GZipStream">
             <summary>
               A class for compressing and decompressing GZIP streams.
             </summary>
             <remarks>
            
             <para>
               The <c>GZipStream</c> is a <see href="http://en.wikipedia.org/wiki/Decorator_pattern">Decorator</see> on a
               <see cref="T:System.IO.Stream"/>. It adds GZIP compression or decompression to any
               stream.
             </para>
            
             <para>
               Like the <c>System.IO.Compression.GZipStream</c> in the .NET Base Class Library, the
               <c>Ionic.Zlib.GZipStream</c> can compress while writing, or decompress while
               reading, but not vice versa.  The compression method used is GZIP, which is
               documented in <see href="http://www.ietf.org/rfc/rfc1952.txt">IETF RFC
               1952</see>, "GZIP file format specification version 4.3".</para>
            
             <para>
               A <c>GZipStream</c> can be used to decompress data (through <c>Read()</c>) or
               to compress data (through <c>Write()</c>), but not both.
             </para>
            
             <para>
               If you wish to use the <c>GZipStream</c> to compress data, you must wrap it
               around a write-able stream. As you call <c>Write()</c> on the <c>GZipStream</c>, the
               data will be compressed into the GZIP format.  If you want to decompress data,
               you must wrap the <c>GZipStream</c> around a readable stream that contains an
               IETF RFC 1952-compliant stream.  The data will be decompressed as you call
               <c>Read()</c> on the <c>GZipStream</c>.
             </para>
            
             <para>
               Though the GZIP format allows data from multiple files to be concatenated
               together, this stream handles only a single segment of GZIP format, typically
               representing a single file.
             </para>
            
             <para>
               This class is similar to <b>ZlibStream</b> and <b>DeflateStream</b>.
               <c>ZlibStream</c> handles RFC1950-compliant streams.  <c>DeflateStream</c>
               handles RFC1951-compliant streams. This class handles RFC1952-compliant streams.
             </para>
            
             </remarks>
            
        </member>
        <member name="F:Ionic.Zlib.GZipStream.LastModified">
             <summary>
               The last modified time for the GZIP stream.
             </summary>
            
             <remarks>
               GZIP allows the storage of a last modified time with each GZIP entry.
               When compressing data, you can set this before the first call to
               <c>Write()</c>.  When decompressing, you can retrieve this value any time
               after the first call to <c>Read()</c>.
             </remarks>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode)">
             <summary>
               Create a <c>GZipStream</c> using the specified <c>CompressionMode</c>.
             </summary>
             <remarks>
            
             <para>
               When mode is <c>CompressionMode.Compress</c>, the <c>GZipStream</c> will use the
               default compression level.
             </para>
            
             <para>
               As noted in the class documentation, the <c>CompressionMode</c> (Compress
               or Decompress) also establishes the "direction" of the stream.  A
               <c>GZipStream</c> with <c>CompressionMode.Compress</c> works only through
               <c>Write()</c>.  A <c>GZipStream</c> with
               <c>CompressionMode.Decompress</c> works only through <c>Read()</c>.
             </para>
            
             </remarks>
            
             <example>
               This example shows how to use a GZipStream to compress data.
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(outputFile))
                 {
                     using (Stream compressor = new GZipStream(raw, CompressionMode.Compress))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
             <code lang="VB">
             Dim outputFile As String = (fileToCompress &amp; ".compressed")
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(outputFile)
                 Using compressor As Stream = New GZipStream(raw, CompressionMode.Compress)
                     Dim buffer As Byte() = New Byte(4096) {}
                     Dim n As Integer = -1
                     Do While (n &lt;&gt; 0)
                         If (n &gt; 0) Then
                             compressor.Write(buffer, 0, n)
                         End If
                         n = input.Read(buffer, 0, buffer.Length)
                     Loop
                 End Using
                 End Using
             End Using
             </code>
             </example>
            
             <example>
             This example shows how to use a GZipStream to uncompress a file.
             <code>
             private void GunZipFile(string filename)
             {
                 if (!filename.EndsWith(".gz))
                     throw new ArgumentException("filename");
                 var DecompressedFile = filename.Substring(0,filename.Length-3);
                 byte[] working = new byte[WORKING_BUFFER_SIZE];
                 int n= 1;
                 using (System.IO.Stream input = System.IO.File.OpenRead(filename))
                 {
                     using (Stream decompressor= new Ionic.Zlib.GZipStream(input, CompressionMode.Decompress, true))
                     {
                         using (var output = System.IO.File.Create(DecompressedFile))
                         {
                             while (n !=0)
                             {
                                 n= decompressor.Read(working, 0, working.Length);
                                 if (n > 0)
                                 {
                                     output.Write(working, 0, n);
                                 }
                             }
                         }
                     }
                 }
             }
             </code>
            
             <code lang="VB">
             Private Sub GunZipFile(ByVal filename as String)
                 If Not (filename.EndsWith(".gz)) Then
                     Throw New ArgumentException("filename")
                 End If
                 Dim DecompressedFile as String = filename.Substring(0,filename.Length-3)
                 Dim working(WORKING_BUFFER_SIZE) as Byte
                 Dim n As Integer = 1
                 Using input As Stream = File.OpenRead(filename)
                     Using decompressor As Stream = new Ionic.Zlib.GZipStream(input, CompressionMode.Decompress, True)
                         Using output As Stream = File.Create(UncompressedFile)
                             Do
                                 n= decompressor.Read(working, 0, working.Length)
                                 If n > 0 Then
                                     output.Write(working, 0, n)
                                 End IF
                             Loop While (n  > 0)
                         End Using
                     End Using
                 End Using
             End Sub
             </code>
             </example>
            
             <param name="stream">The stream which will be read or written.</param>
             <param name="mode">Indicates whether the GZipStream will compress or decompress.</param>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,Ionic.Zlib.CompressionLevel)">
             <summary>
               Create a <c>GZipStream</c> using the specified <c>CompressionMode</c> and
               the specified <c>CompressionLevel</c>.
             </summary>
             <remarks>
            
             <para>
               The <c>CompressionMode</c> (Compress or Decompress) also establishes the
               "direction" of the stream.  A <c>GZipStream</c> with
               <c>CompressionMode.Compress</c> works only through <c>Write()</c>.  A
               <c>GZipStream</c> with <c>CompressionMode.Decompress</c> works only
               through <c>Read()</c>.
             </para>
            
             </remarks>
            
             <example>
            
             This example shows how to use a <c>GZipStream</c> to compress a file into a .gz file.
            
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(fileToCompress + ".gz"))
                 {
                     using (Stream compressor = new GZipStream(raw,
                                                               CompressionMode.Compress,
                                                               CompressionLevel.BestCompression))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
            
             <code lang="VB">
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(fileToCompress &amp; ".gz")
                     Using compressor As Stream = New GZipStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
             End Using
             </code>
             </example>
             <param name="stream">The stream to be read or written while deflating or inflating.</param>
             <param name="mode">Indicates whether the <c>GZipStream</c> will compress or decompress.</param>
             <param name="level">A tuning knob to trade speed for effectiveness.</param>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,System.Boolean)">
             <summary>
               Create a <c>GZipStream</c> using the specified <c>CompressionMode</c>, and
               explicitly specify whether the stream should be left open after Deflation
               or Inflation.
             </summary>
            
             <remarks>
             <para>
               This constructor allows the application to request that the captive stream
               remain open after the deflation or inflation occurs.  By default, after
               <c>Close()</c> is called on the stream, the captive stream is also
               closed. In some cases this is not desired, for example if the stream is a
               memory stream that will be re-read after compressed data has been written
               to it.  Specify true for the <paramref name="leaveOpen"/> parameter to leave
               the stream open.
             </para>
            
             <para>
               The <see cref="T:Ionic.Zlib.CompressionMode"/> (Compress or Decompress) also
               establishes the "direction" of the stream.  A <c>GZipStream</c> with
               <c>CompressionMode.Compress</c> works only through <c>Write()</c>.  A <c>GZipStream</c>
               with <c>CompressionMode.Decompress</c> works only through <c>Read()</c>.
             </para>
            
             <para>
               The <c>GZipStream</c> will use the default compression level. If you want
               to specify the compression level, see <see cref="M:Ionic.Zlib.GZipStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,Ionic.Zlib.CompressionLevel,System.Boolean)"/>.
             </para>
            
             <para>
               See the other overloads of this constructor for example code.
             </para>
            
             </remarks>
            
             <param name="stream">
               The stream which will be read or written. This is called the "captive"
               stream in other places in this documentation.
             </param>
            
             <param name="mode">Indicates whether the GZipStream will compress or decompress.
             </param>
            
             <param name="leaveOpen">
               true if the application would like the base stream to remain open after
               inflation/deflation.
             </param>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,Ionic.Zlib.CompressionLevel,System.Boolean)">
             <summary>
               Create a <c>GZipStream</c> using the specified <c>CompressionMode</c> and the
               specified <c>CompressionLevel</c>, and explicitly specify whether the
               stream should be left open after Deflation or Inflation.
             </summary>
            
             <remarks>
            
             <para>
               This constructor allows the application to request that the captive stream
               remain open after the deflation or inflation occurs.  By default, after
               <c>Close()</c> is called on the stream, the captive stream is also
               closed. In some cases this is not desired, for example if the stream is a
               memory stream that will be re-read after compressed data has been written
               to it.  Specify true for the <paramref name="leaveOpen"/> parameter to
               leave the stream open.
             </para>
            
             <para>
               As noted in the class documentation, the <c>CompressionMode</c> (Compress
               or Decompress) also establishes the "direction" of the stream.  A
               <c>GZipStream</c> with <c>CompressionMode.Compress</c> works only through
               <c>Write()</c>.  A <c>GZipStream</c> with <c>CompressionMode.Decompress</c> works only
               through <c>Read()</c>.
             </para>
            
             </remarks>
            
             <example>
               This example shows how to use a <c>GZipStream</c> to compress data.
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(outputFile))
                 {
                     using (Stream compressor = new GZipStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression, true))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
             <code lang="VB">
             Dim outputFile As String = (fileToCompress &amp; ".compressed")
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(outputFile)
                 Using compressor As Stream = New GZipStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression, True)
                     Dim buffer As Byte() = New Byte(4096) {}
                     Dim n As Integer = -1
                     Do While (n &lt;&gt; 0)
                         If (n &gt; 0) Then
                             compressor.Write(buffer, 0, n)
                         End If
                         n = input.Read(buffer, 0, buffer.Length)
                     Loop
                 End Using
                 End Using
             End Using
             </code>
             </example>
             <param name="stream">The stream which will be read or written.</param>
             <param name="mode">Indicates whether the GZipStream will compress or decompress.</param>
             <param name="leaveOpen">true if the application would like the stream to remain open after inflation/deflation.</param>
             <param name="level">A tuning knob to trade speed for effectiveness.</param>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.Dispose(System.Boolean)">
            <summary>
              Dispose the stream.
            </summary>
            <remarks>
              <para>
                This may or may not result in a <c>Close()</c> call on the captive
                stream.  See the constructors that have a <c>leaveOpen</c> parameter
                for more information.
              </para>
              <para>
                This method may be invoked in two distinct scenarios.  If disposing
                == true, the method has been called directly or indirectly by a
                user's code, for example via the public Dispose() method. In this
                case, both managed and unmanaged resources can be referenced and
                disposed.  If disposing == false, the method has been called by the
                runtime from inside the object finalizer and this method should not
                reference other objects; in that case only unmanaged resources must
                be referenced or disposed.
              </para>
            </remarks>
            <param name="disposing">
              indicates whether the Dispose method was invoked by user code.
            </param>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.Flush">
            <summary>
            Flush the stream.
            </summary>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.Read(System.Byte[],System.Int32,System.Int32)">
             <summary>
               Read and decompress data from the source stream.
             </summary>
            
             <remarks>
               With a <c>GZipStream</c>, decompression is done through reading.
             </remarks>
            
             <example>
             <code>
             byte[] working = new byte[WORKING_BUFFER_SIZE];
             using (System.IO.Stream input = System.IO.File.OpenRead(_CompressedFile))
             {
                 using (Stream decompressor= new Ionic.Zlib.GZipStream(input, CompressionMode.Decompress, true))
                 {
                     using (var output = System.IO.File.Create(_DecompressedFile))
                     {
                         int n;
                         while ((n= decompressor.Read(working, 0, working.Length)) !=0)
                         {
                             output.Write(working, 0, n);
                         }
                     }
                 }
             }
             </code>
             </example>
             <param name="buffer">The buffer into which the decompressed data should be placed.</param>
             <param name="offset">the offset within that data array to put the first byte read.</param>
             <param name="count">the number of bytes to read.</param>
             <returns>the number of bytes actually read</returns>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
              Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="offset">irrelevant; it will always throw!</param>
            <param name="origin">irrelevant; it will always throw!</param>
            <returns>irrelevant!</returns>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.SetLength(System.Int64)">
            <summary>
              Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="value">irrelevant; this method will always throw!</param>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.Write(System.Byte[],System.Int32,System.Int32)">
             <summary>
               Write data to the stream.
             </summary>
            
             <remarks>
             <para>
               If you wish to use the <c>GZipStream</c> to compress data while writing,
               you can create a <c>GZipStream</c> with <c>CompressionMode.Compress</c>, and a
               writable output stream.  Then call <c>Write()</c> on that <c>GZipStream</c>,
               providing uncompressed data as input.  The data sent to the output stream
               will be the compressed form of the data written.
             </para>
            
             <para>
               A <c>GZipStream</c> can be used for <c>Read()</c> or <c>Write()</c>, but not
               both. Writing implies compression.  Reading implies decompression.
             </para>
            
             </remarks>
             <param name="buffer">The buffer holding data to write to the stream.</param>
             <param name="offset">the offset within that data array to find the first byte to write.</param>
             <param name="count">the number of bytes to write.</param>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.CompressString(System.String)">
             <summary>
               Compress a string into a byte array using GZip.
             </summary>
            
             <remarks>
               Uncompress it with <see cref="M:Ionic.Zlib.GZipStream.UncompressString(System.Byte[])"/>.
             </remarks>
            
             <seealso cref="M:Ionic.Zlib.GZipStream.UncompressString(System.Byte[])"/>
             <seealso cref="M:Ionic.Zlib.GZipStream.CompressBuffer(System.Byte[])"/>
            
             <param name="s">
               A string to compress. The string will first be encoded
               using UTF8, then compressed.
             </param>
            
             <returns>The string in compressed form</returns>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.CompressBuffer(System.Byte[])">
             <summary>
               Compress a byte array into a new byte array using GZip.
             </summary>
            
             <remarks>
               Uncompress it with <see cref="M:Ionic.Zlib.GZipStream.UncompressBuffer(System.Byte[])"/>.
             </remarks>
            
             <seealso cref="M:Ionic.Zlib.GZipStream.CompressString(System.String)"/>
             <seealso cref="M:Ionic.Zlib.GZipStream.UncompressBuffer(System.Byte[])"/>
            
             <param name="b">
               A buffer to compress.
             </param>
            
             <returns>The data in compressed form</returns>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.UncompressString(System.Byte[])">
             <summary>
               Uncompress a GZip'ed byte array into a single string.
             </summary>
            
             <seealso cref="M:Ionic.Zlib.GZipStream.CompressString(System.String)"/>
             <seealso cref="M:Ionic.Zlib.GZipStream.UncompressBuffer(System.Byte[])"/>
            
             <param name="compressed">
               A buffer containing GZIP-compressed data.
             </param>
            
             <returns>The uncompressed string</returns>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.UncompressBuffer(System.Byte[])">
             <summary>
               Uncompress a GZip'ed byte array into a byte array.
             </summary>
            
             <seealso cref="M:Ionic.Zlib.GZipStream.CompressBuffer(System.Byte[])"/>
             <seealso cref="M:Ionic.Zlib.GZipStream.UncompressString(System.Byte[])"/>
            
             <param name="compressed">
               A buffer containing data that has been compressed with GZip.
             </param>
            
             <returns>The data in uncompressed form</returns>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.Comment">
             <summary>
               The comment on the GZIP stream.
             </summary>
            
             <remarks>
             <para>
               The GZIP format allows for each file to optionally have an associated
               comment stored with the file.  The comment is encoded with the ISO-8859-1
               code page.  To include a comment in a GZIP stream you create, set this
               property before calling <c>Write()</c> for the first time on the
               <c>GZipStream</c>.
             </para>
            
             <para>
               When using <c>GZipStream</c> to decompress, you can retrieve this property
               after the first call to <c>Read()</c>.  If no comment has been set in the
               GZIP bytestream, the Comment property will return <c>null</c>
               (<c>Nothing</c> in VB).
             </para>
             </remarks>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.FileName">
             <summary>
               The FileName for the GZIP stream.
             </summary>
            
             <remarks>
            
             <para>
               The GZIP format optionally allows each file to have an associated
               filename.  When compressing data (through <c>Write()</c>), set this
               FileName before calling <c>Write()</c> the first time on the <c>GZipStream</c>.
               The actual filename is encoded into the GZIP bytestream with the
               ISO-8859-1 code page, according to RFC 1952. It is the application's
               responsibility to insure that the FileName can be encoded and decoded
               correctly with this code page.
             </para>
            
             <para>
               When decompressing (through <c>Read()</c>), you can retrieve this value
               any time after the first <c>Read()</c>.  In the case where there was no filename
               encoded into the GZIP bytestream, the property will return <c>null</c> (<c>Nothing</c>
               in VB).
             </para>
             </remarks>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.Crc32">
            <summary>
            The CRC on the GZIP stream.
            </summary>
            <remarks>
            This is used for internal error checking. You probably don't need to look at this property.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.FlushMode">
            <summary>
            This property sets the flush behavior on the stream.
            </summary>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.BufferSize">
             <summary>
               The size of the working buffer for the compression codec.
             </summary>
            
             <remarks>
             <para>
               The working buffer is used for all stream operations.  The default size is
               1024 bytes.  The minimum size is 128 bytes. You may get better performance
               with a larger buffer.  Then again, you might not.  You would have to test
               it.
             </para>
            
             <para>
               Set this before the first call to <c>Read()</c> or <c>Write()</c> on the
               stream. If you try to set it afterwards, it will throw.
             </para>
             </remarks>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.TotalIn">
            <summary> Returns the total number of bytes input so far.</summary>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.TotalOut">
            <summary> Returns the total number of bytes output so far.</summary>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.CanRead">
            <summary>
            Indicates whether the stream can be read.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports reading.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.CanSeek">
            <summary>
            Indicates whether the stream supports Seek operations.
            </summary>
            <remarks>
            Always returns false.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.CanWrite">
            <summary>
            Indicates whether the stream can be written.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports writing.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.Length">
            <summary>
            Reading this property always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.Position">
             <summary>
               The position of the stream pointer.
             </summary>
            
             <remarks>
               Setting this property always throws a <see cref="T:System.NotImplementedException"/>. Reading will return the total bytes
               written out, if used in writing, or the total bytes read in, if used in
               reading.  The count may refer to compressed bytes or uncompressed bytes,
               depending on how you've used the stream.
             </remarks>
        </member>
        <member name="M:Ionic.Zlib.Tree.DistanceCode(System.Int32)">
            <summary>
            Map from a distance to a distance code.
            </summary>
            <remarks> 
            No side effects. _dist_code[256] and _dist_code[257] are never used.
            </remarks>
        </member>
        <member name="T:Ionic.Zlib.FlushType">
            <summary>
            Describes how to flush the current deflate operation.
            </summary>
            <remarks>
            The different FlushType values are useful when using a Deflate in a streaming application.
            </remarks>
        </member>
        <member name="F:Ionic.Zlib.FlushType.None">
            <summary>No flush at all.</summary>
        </member>
        <member name="F:Ionic.Zlib.FlushType.Partial">
            <summary>Closes the current block, but doesn't flush it to
            the output. Used internally only in hypothetical
            scenarios.  This was supposed to be removed by Zlib, but it is
            still in use in some edge cases.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.FlushType.Sync">
            <summary>
            Use this during compression to specify that all pending output should be
            flushed to the output buffer and the output should be aligned on a byte
            boundary.  You might use this in a streaming communication scenario, so that
            the decompressor can get all input data available so far.  When using this
            with a ZlibCodec, <c>AvailableBytesIn</c> will be zero after the call if
            enough output space has been provided before the call.  Flushing will
            degrade compression and so it should be used only when necessary.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.FlushType.Full">
            <summary>
            Use this during compression to specify that all output should be flushed, as
            with <c>FlushType.Sync</c>, but also, the compression state should be reset
            so that decompression can restart from this point if previous compressed
            data has been damaged or if random access is desired.  Using
            <c>FlushType.Full</c> too often can significantly degrade the compression.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.FlushType.Finish">
            <summary>Signals the end of the compression/decompression stream.</summary>
        </member>
        <member name="T:Ionic.Zlib.CompressionLevel">
            <summary>
            The compression level to be used when using a DeflateStream or ZlibStream with CompressionMode.Compress.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.None">
            <summary>
            None means that the data will be simply stored, with no change at all.
            If you are producing ZIPs for use on Mac OSX, be aware that archives produced with CompressionLevel.None
            cannot be opened with the default zip reader. Use a different CompressionLevel.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level0">
            <summary>
            Same as None.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.BestSpeed">
            <summary>
            The fastest but least effective compression.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level1">
            <summary>
            A synonym for BestSpeed.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level2">
            <summary>
            A little slower, but better, than level 1.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level3">
            <summary>
            A little slower, but better, than level 2.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level4">
            <summary>
            A little slower, but better, than level 3.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level5">
            <summary>
            A little slower than level 4, but with better compression.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Default">
            <summary>
            The default compression level, with a good balance of speed and compression efficiency.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level6">
            <summary>
            A synonym for Default.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level7">
            <summary>
            Pretty good compression!
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level8">
            <summary>
             Better compression than Level7!
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.BestCompression">
            <summary>
            The "best" compression, where best means greatest reduction in size of the input data stream.
            This is also the slowest compression.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level9">
            <summary>
            A synonym for BestCompression.
            </summary>
        </member>
        <member name="T:Ionic.Zlib.CompressionStrategy">
            <summary>
            Describes options for how the compression algorithm is executed.  Different strategies
            work better on different sorts of data.  The strategy parameter can affect the compression
            ratio and the speed of compression but not the correctness of the compresssion.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionStrategy.Default">
            <summary>
            The default strategy is probably the best for normal data.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionStrategy.Filtered">
            <summary>
            The <c>Filtered</c> strategy is intended to be used most effectively with data produced by a
            filter or predictor.  By this definition, filtered data consists mostly of small
            values with a somewhat random distribution.  In this case, the compression algorithm
            is tuned to compress them better.  The effect of <c>Filtered</c> is to force more Huffman
            coding and less string matching; it is a half-step between <c>Default</c> and <c>HuffmanOnly</c>.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionStrategy.HuffmanOnly">
            <summary>
            Using <c>HuffmanOnly</c> will force the compressor to do Huffman encoding only, with no
            string matching.
            </summary>
        </member>
        <member name="T:Ionic.Zlib.CompressionMode">
            <summary>
            An enum to specify the direction of transcoding - whether to compress or decompress.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionMode.Compress">
            <summary>
            Used to specify that the stream should compress the data.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionMode.Decompress">
            <summary>
            Used to specify that the stream should decompress the data.
            </summary>
        </member>
        <member name="T:Ionic.Zlib.ZlibException">
            <summary>
            A general purpose exception class for exceptions in the Zlib library.
            </summary>
        </member>
        <member name="M:Ionic.Zlib.ZlibException.#ctor">
            <summary>
            The ZlibException class captures exception information generated
            by the Zlib library.
            </summary>
        </member>
        <member name="M:Ionic.Zlib.ZlibException.#ctor(System.String)">
            <summary>
            This ctor collects a message attached to the exception.
            </summary>
            <param name="s">the message for the exception.</param>
        </member>
        <member name="M:Ionic.Zlib.SharedUtils.URShift(System.Int32,System.Int32)">
            <summary>
            Performs an unsigned bitwise right shift with the specified number
            </summary>
            <param name="number">Number to operate on</param>
            <param name="bits">Ammount of bits to shift</param>
            <returns>The resulting number from the shift operation</returns>
        </member>
        <member name="M:Ionic.Zlib.SharedUtils.ReadInput(System.IO.TextReader,System.Byte[],System.Int32,System.Int32)">
             <summary>
               Reads a number of characters from the current source TextReader and writes
               the data to the target array at the specified index.
             </summary>
            
             <param name="sourceTextReader">The source TextReader to read from</param>
             <param name="target">Contains the array of characteres read from the source TextReader.</param>
             <param name="start">The starting index of the target array.</param>
             <param name="count">The maximum number of characters to read from the source TextReader.</param>
            
             <returns>
               The number of characters read. The number will be less than or equal to
               count depending on the data available in the source TextReader. Returns -1
               if the end of the stream is reached.
             </returns>
        </member>
        <member name="T:Ionic.Zlib.Adler">
             <summary>
             Computes an Adler-32 checksum.
             </summary>
             <remarks>
             The Adler checksum is similar to a CRC checksum, but faster to compute, though less
             reliable.  It is used in producing RFC1950 compressed streams.  The Adler checksum
             is a required part of the "ZLIB" standard.  Applications will almost never need to
             use this class directly.
             </remarks>
            
             <exclude/>
        </member>
        <member name="M:Ionic.Zlib.Adler.Adler32(System.UInt32,System.Byte[],System.Int32,System.Int32)">
            <summary>
              Calculates the Adler32 checksum.
            </summary>
            <remarks>
              <para>
                This is used within ZLIB.  You probably don't need to use this directly.
              </para>
            </remarks>
            <example>
               To compute an Adler32 checksum on a byte array:
             <code>
               var adler = Adler.Adler32(0, null, 0, 0);
               adler = Adler.Adler32(adler, buffer, index, length);
             </code>
            </example>
        </member>
        <member name="T:Ionic.Zlib.ZlibCodec">
             <summary>
             Encoder and Decoder for ZLIB and DEFLATE (IETF RFC1950 and RFC1951).
             </summary>
            
             <remarks>
             This class compresses and decompresses data according to the Deflate algorithm
             and optionally, the ZLIB format, as documented in <see
             href="http://www.ietf.org/rfc/rfc1950.txt">RFC 1950 - ZLIB</see> and <see
             href="http://www.ietf.org/rfc/rfc1951.txt">RFC 1951 - DEFLATE</see>.
             </remarks>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.InputBuffer">
            <summary>
            The buffer from which data is taken.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.NextIn">
            <summary>
            An index into the InputBuffer array, indicating where to start reading. 
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.AvailableBytesIn">
            <summary>
            The number of bytes available in the InputBuffer, starting at NextIn. 
            </summary>
            <remarks>
            Generally you should set this to InputBuffer.Length before the first Inflate() or Deflate() call. 
            The class will update this number as calls to Inflate/Deflate are made.
            </remarks>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.TotalBytesIn">
            <summary>
            Total number of bytes read so far, through all calls to Inflate()/Deflate().
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.OutputBuffer">
            <summary>
            Buffer to store output data.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.NextOut">
            <summary>
            An index into the OutputBuffer array, indicating where to start writing. 
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.AvailableBytesOut">
            <summary>
            The number of bytes available in the OutputBuffer, starting at NextOut. 
            </summary>
            <remarks>
            Generally you should set this to OutputBuffer.Length before the first Inflate() or Deflate() call. 
            The class will update this number as calls to Inflate/Deflate are made.
            </remarks>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.TotalBytesOut">
            <summary>
            Total number of bytes written to the output so far, through all calls to Inflate()/Deflate().
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.Message">
            <summary>
            used for diagnostics, when something goes wrong!
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.CompressLevel">
            <summary>
            The compression level to use in this codec.  Useful only in compression mode.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.WindowBits">
            <summary>
            The number of Window Bits to use.  
            </summary>
            <remarks>
            This gauges the size of the sliding window, and hence the 
            compression effectiveness as well as memory consumption. It's best to just leave this 
            setting alone if you don't know what it is.  The maximum value is 15 bits, which implies
            a 32k window.  
            </remarks>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.Strategy">
            <summary>
            The compression strategy to use.
            </summary>
            <remarks>
            This is only effective in compression.  The theory offered by ZLIB is that different
            strategies could potentially produce significant differences in compression behavior
            for different data sets.  Unfortunately I don't have any good recommendations for how
            to set it differently.  When I tested changing the strategy I got minimally different
            compression performance. It's best to leave this property alone if you don't have a
            good feel for it.  Or, you may want to produce a test harness that runs through the
            different strategy options and evaluates them on different file types. If you do that,
            let me know your results.
            </remarks>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.#ctor">
            <summary>
            Create a ZlibCodec.
            </summary>
            <remarks>
            If you use this default constructor, you will later have to explicitly call 
            InitializeInflate() or InitializeDeflate() before using the ZlibCodec to compress 
            or decompress. 
            </remarks>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.#ctor(Ionic.Zlib.CompressionMode)">
            <summary>
            Create a ZlibCodec that either compresses or decompresses.
            </summary>
            <param name="mode">
            Indicates whether the codec should compress (deflate) or decompress (inflate).
            </param>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.InitializeInflate">
            <summary>
            Initialize the inflation state. 
            </summary>
            <remarks>
            It is not necessary to call this before using the ZlibCodec to inflate data; 
            It is implicitly called when you call the constructor.
            </remarks>
            <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.InitializeInflate(System.Boolean)">
             <summary>
             Initialize the inflation state with an explicit flag to
             govern the handling of RFC1950 header bytes.
             </summary>
            
             <remarks>
             By default, the ZLIB header defined in <see
             href="http://www.ietf.org/rfc/rfc1950.txt">RFC 1950</see> is expected.  If
             you want to read a zlib stream you should specify true for
             expectRfc1950Header.  If you have a deflate stream, you will want to specify
             false. It is only necessary to invoke this initializer explicitly if you
             want to specify false.
             </remarks>
            
             <param name="expectRfc1950Header">whether to expect an RFC1950 header byte
             pair when reading the stream of data to be inflated.</param>
            
             <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.InitializeInflate(System.Int32)">
            <summary>
            Initialize the ZlibCodec for inflation, with the specified number of window bits. 
            </summary>
            <param name="windowBits">The number of window bits to use. If you need to ask what that is, 
            then you shouldn't be calling this initializer.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.InitializeInflate(System.Int32,System.Boolean)">
             <summary>
             Initialize the inflation state with an explicit flag to govern the handling of
             RFC1950 header bytes. 
             </summary>
            
             <remarks>
             If you want to read a zlib stream you should specify true for
             expectRfc1950Header. In this case, the library will expect to find a ZLIB
             header, as defined in <see href="http://www.ietf.org/rfc/rfc1950.txt">RFC
             1950</see>, in the compressed stream.  If you will be reading a DEFLATE or
             GZIP stream, which does not have such a header, you will want to specify
             false.
             </remarks>
            
             <param name="expectRfc1950Header">whether to expect an RFC1950 header byte pair when reading 
             the stream of data to be inflated.</param>
             <param name="windowBits">The number of window bits to use. If you need to ask what that is, 
             then you shouldn't be calling this initializer.</param>
             <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.Inflate(Ionic.Zlib.FlushType)">
             <summary>
             Inflate the data in the InputBuffer, placing the result in the OutputBuffer.
             </summary>
             <remarks>
             You must have set InputBuffer and OutputBuffer, NextIn and NextOut, and AvailableBytesIn and 
             AvailableBytesOut  before calling this method.
             </remarks>
             <example>
             <code>
             private void InflateBuffer()
             {
                 int bufferSize = 1024;
                 byte[] buffer = new byte[bufferSize];
                 ZlibCodec decompressor = new ZlibCodec();
             
                 Console.WriteLine("\n============================================");
                 Console.WriteLine("Size of Buffer to Inflate: {0} bytes.", CompressedBytes.Length);
                 MemoryStream ms = new MemoryStream(DecompressedBytes);
             
                 int rc = decompressor.InitializeInflate();
             
                 decompressor.InputBuffer = CompressedBytes;
                 decompressor.NextIn = 0;
                 decompressor.AvailableBytesIn = CompressedBytes.Length;
             
                 decompressor.OutputBuffer = buffer;
             
                 // pass 1: inflate 
                 do
                 {
                     decompressor.NextOut = 0;
                     decompressor.AvailableBytesOut = buffer.Length;
                     rc = decompressor.Inflate(FlushType.None);
             
                     if (rc != ZlibConstants.Z_OK &amp;&amp; rc != ZlibConstants.Z_STREAM_END)
                         throw new Exception("inflating: " + decompressor.Message);
             
                     ms.Write(decompressor.OutputBuffer, 0, buffer.Length - decompressor.AvailableBytesOut);
                 }
                 while (decompressor.AvailableBytesIn &gt; 0 || decompressor.AvailableBytesOut == 0);
             
                 // pass 2: finish and flush
                 do
                 {
                     decompressor.NextOut = 0;
                     decompressor.AvailableBytesOut = buffer.Length;
                     rc = decompressor.Inflate(FlushType.Finish);
             
                     if (rc != ZlibConstants.Z_STREAM_END &amp;&amp; rc != ZlibConstants.Z_OK)
                         throw new Exception("inflating: " + decompressor.Message);
             
                     if (buffer.Length - decompressor.AvailableBytesOut &gt; 0)
                         ms.Write(buffer, 0, buffer.Length - decompressor.AvailableBytesOut);
                 }
                 while (decompressor.AvailableBytesIn &gt; 0 || decompressor.AvailableBytesOut == 0);
             
                 decompressor.EndInflate();
             }
            
             </code>
             </example>
             <param name="flush">The flush to use when inflating.</param>
             <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.EndInflate">
            <summary>
            Ends an inflation session. 
            </summary>
            <remarks>
            Call this after successively calling Inflate().  This will cause all buffers to be flushed. 
            After calling this you cannot call Inflate() without a intervening call to one of the
            InitializeInflate() overloads.
            </remarks>
            <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.SyncInflate">
            <summary>
            I don't know what this does!
            </summary>
            <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.InitializeDeflate">
            <summary>
            Initialize the ZlibCodec for deflation operation.
            </summary>
            <remarks>
            The codec will use the MAX window bits and the default level of compression.
            </remarks>
            <example>
            <code>
             int bufferSize = 40000;
             byte[] CompressedBytes = new byte[bufferSize];
             byte[] DecompressedBytes = new byte[bufferSize];
             
             ZlibCodec compressor = new ZlibCodec();
             
             compressor.InitializeDeflate(CompressionLevel.Default);
             
             compressor.InputBuffer = System.Text.ASCIIEncoding.ASCII.GetBytes(TextToCompress);
             compressor.NextIn = 0;
             compressor.AvailableBytesIn = compressor.InputBuffer.Length;
             
             compressor.OutputBuffer = CompressedBytes;
             compressor.NextOut = 0;
             compressor.AvailableBytesOut = CompressedBytes.Length;
             
             while (compressor.TotalBytesIn != TextToCompress.Length &amp;&amp; compressor.TotalBytesOut &lt; bufferSize)
             {
               compressor.Deflate(FlushType.None);
             }
             
             while (true)
             {
               int rc= compressor.Deflate(FlushType.Finish);
               if (rc == ZlibConstants.Z_STREAM_END) break;
             }
             
             compressor.EndDeflate();
              
            </code>
            </example>
            <returns>Z_OK if all goes well. You generally don't need to check the return code.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.InitializeDeflate(Ionic.Zlib.CompressionLevel)">
            <summary>
            Initialize the ZlibCodec for deflation operation, using the specified CompressionLevel.
            </summary>
            <remarks>
            The codec will use the maximum window bits (15) and the specified
            CompressionLevel.  It will emit a ZLIB stream as it compresses.
            </remarks>
            <param name="level">The compression level for the codec.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.InitializeDeflate(Ionic.Zlib.CompressionLevel,System.Boolean)">
            <summary>
            Initialize the ZlibCodec for deflation operation, using the specified CompressionLevel, 
            and the explicit flag governing whether to emit an RFC1950 header byte pair.
            </summary>
            <remarks>
            The codec will use the maximum window bits (15) and the specified CompressionLevel.
            If you want to generate a zlib stream, you should specify true for
            wantRfc1950Header. In this case, the library will emit a ZLIB
            header, as defined in <see href="http://www.ietf.org/rfc/rfc1950.txt">RFC
            1950</see>, in the compressed stream.  
            </remarks>
            <param name="level">The compression level for the codec.</param>
            <param name="wantRfc1950Header">whether to emit an initial RFC1950 byte pair in the compressed stream.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.InitializeDeflate(Ionic.Zlib.CompressionLevel,System.Int32)">
            <summary>
            Initialize the ZlibCodec for deflation operation, using the specified CompressionLevel, 
            and the specified number of window bits. 
            </summary>
            <remarks>
            The codec will use the specified number of window bits and the specified CompressionLevel.
            </remarks>
            <param name="level">The compression level for the codec.</param>
            <param name="bits">the number of window bits to use.  If you don't know what this means, don't use this method.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.InitializeDeflate(Ionic.Zlib.CompressionLevel,System.Int32,System.Boolean)">
             <summary>
             Initialize the ZlibCodec for deflation operation, using the specified
             CompressionLevel, the specified number of window bits, and the explicit flag
             governing whether to emit an RFC1950 header byte pair.
             </summary>
            
             <param name="level">The compression level for the codec.</param>
             <param name="wantRfc1950Header">whether to emit an initial RFC1950 byte pair in the compressed stream.</param>
             <param name="bits">the number of window bits to use.  If you don't know what this means, don't use this method.</param>
             <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.Deflate(Ionic.Zlib.FlushType)">
            <summary>
            Deflate one batch of data.
            </summary>
            <remarks>
            You must have set InputBuffer and OutputBuffer before calling this method.
            </remarks>
            <example>
            <code>
            private void DeflateBuffer(CompressionLevel level)
            {
                int bufferSize = 1024;
                byte[] buffer = new byte[bufferSize];
                ZlibCodec compressor = new ZlibCodec();
            
                Console.WriteLine("\n============================================");
                Console.WriteLine("Size of Buffer to Deflate: {0} bytes.", UncompressedBytes.Length);
                MemoryStream ms = new MemoryStream();
            
                int rc = compressor.InitializeDeflate(level);
            
                compressor.InputBuffer = UncompressedBytes;
                compressor.NextIn = 0;
                compressor.AvailableBytesIn = UncompressedBytes.Length;
            
                compressor.OutputBuffer = buffer;
            
                // pass 1: deflate 
                do
                {
                    compressor.NextOut = 0;
                    compressor.AvailableBytesOut = buffer.Length;
                    rc = compressor.Deflate(FlushType.None);
            
                    if (rc != ZlibConstants.Z_OK &amp;&amp; rc != ZlibConstants.Z_STREAM_END)
                        throw new Exception("deflating: " + compressor.Message);
            
                    ms.Write(compressor.OutputBuffer, 0, buffer.Length - compressor.AvailableBytesOut);
                }
                while (compressor.AvailableBytesIn &gt; 0 || compressor.AvailableBytesOut == 0);
            
                // pass 2: finish and flush
                do
                {
                    compressor.NextOut = 0;
                    compressor.AvailableBytesOut = buffer.Length;
                    rc = compressor.Deflate(FlushType.Finish);
            
                    if (rc != ZlibConstants.Z_STREAM_END &amp;&amp; rc != ZlibConstants.Z_OK)
                        throw new Exception("deflating: " + compressor.Message);
            
                    if (buffer.Length - compressor.AvailableBytesOut &gt; 0)
                        ms.Write(buffer, 0, buffer.Length - compressor.AvailableBytesOut);
                }
                while (compressor.AvailableBytesIn &gt; 0 || compressor.AvailableBytesOut == 0);
            
                compressor.EndDeflate();
            
                ms.Seek(0, SeekOrigin.Begin);
                CompressedBytes = new byte[compressor.TotalBytesOut];
                ms.Read(CompressedBytes, 0, CompressedBytes.Length);
            }
            </code>
            </example>
            <param name="flush">whether to flush all data as you deflate. Generally you will want to 
            use Z_NO_FLUSH here, in a series of calls to Deflate(), and then call EndDeflate() to 
            flush everything. 
            </param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.EndDeflate">
            <summary>
            End a deflation session.
            </summary>
            <remarks>
            Call this after making a series of one or more calls to Deflate(). All buffers are flushed.
            </remarks>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.ResetDeflate">
            <summary>
            Reset a codec for another deflation session.
            </summary>
            <remarks>
            Call this to reset the deflation state.  For example if a thread is deflating
            non-consecutive blocks, you can call Reset() after the Deflate(Sync) of the first
            block and before the next Deflate(None) of the second block.
            </remarks>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.SetDeflateParams(Ionic.Zlib.CompressionLevel,Ionic.Zlib.CompressionStrategy)">
            <summary>
            Set the CompressionStrategy and CompressionLevel for a deflation session.
            </summary>
            <param name="level">the level of compression to use.</param>
            <param name="strategy">the strategy to use for compression.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.SetDictionary(System.Byte[])">
            <summary>
            Set the dictionary to be used for either Inflation or Deflation.
            </summary>
            <param name="dictionary">The dictionary bytes to use.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="P:Ionic.Zlib.ZlibCodec.Adler32">
            <summary>
            The Adler32 checksum on the data transferred through the codec so far. You probably don't need to look at this.
            </summary>
        </member>
        <member name="T:Ionic.Zlib.ZlibConstants">
            <summary>
            A bunch of constants used in the Zlib interface.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.WindowBitsMax">
            <summary>
            The maximum number of window bits for the Deflate algorithm.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.WindowBitsDefault">
            <summary>
            The default number of window bits for the Deflate algorithm.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.Z_OK">
            <summary>
            indicates everything is A-OK
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.Z_STREAM_END">
            <summary>
            Indicates that the last operation reached the end of the stream.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.Z_NEED_DICT">
            <summary>
            The operation ended in need of a dictionary. 
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.Z_STREAM_ERROR">
            <summary>
            There was an error with the stream - not enough data, not open and readable, etc.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.Z_DATA_ERROR">
            <summary>
            There was an error with the data - not enough data, bad data, etc.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.Z_BUF_ERROR">
            <summary>
            There was an error with the working buffer.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.WorkingBufferSizeDefault">
            <summary>
            The size of the working buffer used in the ZlibCodec class. Defaults to 8192 bytes.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.WorkingBufferSizeMin">
            <summary>
            The minimum size of the working buffer used in the ZlibCodec class.  Currently it is 128 bytes.
            </summary>
        </member>
        <member name="T:System.Data.Services.IgnorePropertiesAttribute">
            <summary>
            Fake Silverlight-only attribute.  See corresponding attribute in .NET System.Data.Services.
            </summary>
        </member>
        <member name="M:System.Data.Services.IgnorePropertiesAttribute.#ctor(System.String[])">
            <summary />
        </member>
        <member name="T:System.Data.Services.ETagAttribute">
            <summary>
            Fake Silverlight-only attribute.  See corresponding attribute in .NET System.Data.Services.
            </summary>
        </member>
        <member name="M:System.Data.Services.ETagAttribute.#ctor(System.String[])">
            <summary />
        </member>
        <member name="T:System.Data.Services.Common.DataServiceKeyAttribute">
            <summary>
            Fake Silverlight-only attribute.  See corresponding attribute in .NET System.Data.Services.Client.
            </summary>
        </member>
        <member name="M:System.Data.Services.Common.DataServiceKeyAttribute.#ctor(System.String[])">
            <summary />
        </member>
        <member name="T:IdeaBlade.Core.EnumerableFns">
            <summary>
            Provides a set of static methods for querying objects that implement <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            <seealso cref="N:System.Linq"/>
            </summary>
            <remarks>
            To use these extensions, add a using statement (Imports in Visual Basic) for this namespace
            to your class.  
            <para>
            Since the methods here are DevForce extensions, you cannot use them in queries which will be sent to the data source,
            as Linq to Entities will not recognize the extension method.
            </para>
            <para>
            For more information on extension methods, see <b>Extension Methods (C# Programming Guide)</b>
            or <b>Extension Methods (Visual Basic)</b> in the Visual Studio 2010 documentation.
            </para>
            </remarks>
        </member>
        <member name="M:IdeaBlade.Core.EnumerableFns.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            Enumerate a cached collection performing the specified action on each item.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="items"></param>
            <param name="action"></param>
            <!-- No matching elements were found for the following include tag --><include file="EnumerableFns.Examples.xml" path="//Class[@name=&quot;EnumerableFns&quot;]/method[@name=&quot;ForEach&quot;]/*"/>
        </member>
        <member name="M:IdeaBlade.Core.EnumerableFns.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Int32})">
            <summary>
            Enumerate an indexed collection in cache performing the specified action on each item.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="items"></param>
            <param name="action">Delegate taking a T and an index value</param>
            <!-- No matching elements were found for the following include tag --><include file="EnumerableFns.Examples.xml" path="//Class[@name=&quot;EnumerableFns&quot;]/method[@name=&quot;ForEach2&quot;]/*"/>
        </member>
        <member name="M:IdeaBlade.Core.EnumerableFns.Any``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})">
            <summary>
            Returns true if any of the items in the indexed collection in cache satisfy the given predicate.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="items"></param>
            <param name="predicate"></param>
            <returns></returns>
            <!-- No matching elements were found for the following include tag --><include file="EnumerableFns.Examples.xml" path="//Class[@name=&quot;EnumerableFns&quot;]/method[@name=&quot;Any&quot;]/*"/>
        </member>
        <member name="M:IdeaBlade.Core.EnumerableFns.All``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})">
            <summary>
            Returns true if all items in a cached collection satisfy the given predicate.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="items"></param>
            <param name="predicate"></param>
            <returns></returns>
            <!-- No matching elements were found for the following include tag --><include file="EnumerableFns.Examples.xml" path="//Class[@name=&quot;EnumerableFns&quot;]/method[@name=&quot;All&quot;]/*"/>
        </member>
        <member name="M:IdeaBlade.Core.EnumerableFns.AllEqual``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns true if all items in a cached collection are equal.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="items"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.EnumerableFns.AllEqual``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Returns true if all items in a cached collection have the same projected value.
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="U"></typeparam>
            <param name="items"></param>
            <param name="selector"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.EnumerableFns.Concat``1(System.Collections.Generic.IEnumerable{``0},``0[])">
            <summary>
            Concatenates two sequences.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="sequence1"></param>
            <param name="sequence2"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.EnumerableFns.IndexOf``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Returns the index of the first item in the sequence matching a condition, or -1 if no match found.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="items"></param>
            <param name="predicate"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.EnumerableFns.ToHashSet``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns a <see cref="T:System.Collections.Generic.HashSet`1"/> of the specified collection.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="items"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.EnumerableFns.GetAggregateHashCode(System.Collections.IEnumerable)">
            <summary>
            Returns a hashcode for a collection that 
            uses a similar algorithm to that used by the .NET Tuple class.
            Order matters.
            </summary>
            <remarks>
            </remarks>
            <param name="items"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.EnumerableFns.ToAggregateString(System.Collections.IEnumerable,System.String)">
            <summary>
            Concatenates the string version of each element in a collection using the delimiter provided.
            </summary>
            <param name="items">The enumerated items whose string formated elements will be concatenated</param>
            <param name="delimiter">Delimiter</param>
            <returns>A delimited string</returns>
        </member>
        <member name="M:IdeaBlade.Core.EnumerableFns.Repeat``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Repeat the items enumerable count times.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="items"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.EnumerableFns.Partition``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <param name="items"></param>
            <param name="batchSize"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.EnumerableFns.Distinct``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
             Returns distinct elements from a sequence by using a specified selector function to project objects to compare.
            </summary>
            <typeparam name="TSource"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="source"></param>
            <param name="selector"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.EnumerableFns.Union``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Produces the set union of two sequences by using a specified selector function to project objects to compare.
            </summary>
            <typeparam name="TSource"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="first"></param>
            <param name="second"></param>
            <param name="selector"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.EnumerableFns.Intersect``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Produces the set intersection of two sequences by using a specified selector function to project objects to compare.
            </summary>
            <typeparam name="TSource"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="first"></param>
            <param name="second"></param>
            <param name="selector"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.EnumerableFns.Except``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Produces the set difference of two sequences by using a specified selector function to compare values.
            </summary>
            <typeparam name="TSource"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="first"></param>
            <param name="second"></param>
            <param name="selector"></param>
            <returns></returns>
        </member>
        <member name="T:IdeaBlade.Core.CryptoFns">
            <summary>
            Static class that provides utility functions having to do with cryptography.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.CryptoFns.AesEncrypt(System.String,System.String)">
            <summary>
            Encrypts a string given a password.
            </summary>
            <param name="valueToEncrypt"></param>
            <param name="password"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.CryptoFns.AesEncrypt(System.String,System.String,System.Boolean)">
            <summary>
            Encrypts a string given a password.
            </summary>
            <param name="valueToEncrypt"></param>
            <param name="password"></param>
            <param name="fipsCompliant"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.CryptoFns.AesDecrypt(System.String,System.String)">
            <summary>
            Decrypt a string given the password it was encrypted with.
            </summary>
            <param name="encryptedValue"></param>
            <param name="password"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.CryptoFns.AesDecrypt(System.String,System.String,System.Boolean)">
            <summary>
            Decrypt a string given the password it was encrypted with.
            </summary>
            <param name="encryptedValue"></param>
            <param name="password"></param>
            <param name="fipsCompliant"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.CryptoFns.AesEncrypt(System.String,System.Byte[],System.Boolean)">
            <summary>
            Encrypt a string given an AES hash key.
            </summary>
            <param name="valueToEncrypt"></param>
            <param name="key"></param>
            <param name="fipsCompliant"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.CryptoFns.AesDecrypt(System.String,System.Byte[],System.Boolean)">
            <summary>
            Decrypt a string given the AES hash key it was encrypted with.
            </summary>
            <param name="encryptedValue"></param>
            <param name="key"></param>
            <param name="fipsCompliant"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.CryptoFns.AesGetHashKey(System.String)">
            <summary>
            Generate an AES hash key given a string.
            </summary>
            <param name="password"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.CryptoFns.CalcStringHash(System.String,System.Int32)">
            <summary>
            Returns a hash encoded as a string with the chars (A-Z,A-z,0-9,_) only.
            Under the covers this method returns an 128 bit hash code calculated
            using SHA1.  This code is then encoded into an approx Base64 encode
            of the chars listed above.  This will usually be approx 28 chars in length,
            which may then be truncated based on the maxChars parameter. This
            method can process approx 100K 300 char strings a second.
            </summary>
            <param name="stringToHash"></param>
            <param name="maxChars"></param>
            <returns></returns>
        </member>
        <member name="T:IdeaBlade.Core.DynamicComparer`2">
            <summary>
            Dynamic implementation of an IEqualityComparer.  
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TResult"></typeparam>
        </member>
        <member name="M:IdeaBlade.Core.DynamicComparer`2.#ctor(System.Func{`0,`1})">
            <summary>
            Ctor. The selector func is used to project the comparison object from the compared object.
            </summary>
            <param name="selector"></param>
        </member>
        <member name="M:IdeaBlade.Core.DynamicComparer`2.Equals(`0,`0)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.DynamicComparer`2.GetHashCode(`0)">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="T:IdeaBlade.Core.DynamicTypeBase">
            <summary>
            For internal use only.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.DynamicTypeBase.#ctor">
            <summary>
            For internal use only.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.DynamicTypeBase.Equals(System.Object)">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.DynamicTypeBase.GetHashCode">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.DynamicGenericTypeBuilder.CreateType(IdeaBlade.Core.DynamicTypeInfo)">
            <summary>
            Constructs a new dynamic entity type from the specified DynamicTypeInfo.
            </summary>
            <param name="info">An DynamicTypeInfo instance</param>
            <returns></returns>
            <exception cref="T:System.ArgumentException">Thrown if the dynamic type key name is already defined.</exception>
        </member>
        <member name="T:IdeaBlade.Core.DynamicTypeConverter">
            <summary>
            Converts anonymously-typed objects to dynamicly-typed objects for binding in Silverlight applications.
            </summary>
            <remarks>
            Use the <see cref="M:IdeaBlade.Core.DynamicTypeConverter.Convert(System.Collections.IEnumerable)"/> method to convert one or more instances of an 
            anonymous type to corresponding instances of a DevForce dynamic type.  A DevForce "dynamic type" is
            a <see cref="T:System.Type"/> created dynamically at runtime.  Generally the primary use for this conversion
            is in Silverlight applications, which do not support data binding to anonymous types.
            Projection queries are one common example in which return data will be anonymously-typed.
            </remarks>
        </member>
        <member name="M:IdeaBlade.Core.DynamicTypeConverter.Convert(System.Object)">
            <summary>
            Convert a single anonymously-typed object into a dynamically-typed object.
            </summary>
            <param name="anonObject"></param>
            <returns></returns>
            <remarks>
            The return object will be an instance of a dynamic type, and you can bind to its properties
            without problems in Silverlight.
            </remarks>
            <example>
        <code lang="C#">
    private void RunProjectionQuery() {
      // Run a query (asynchronously) which returns an anonymous type.
      // Assume we've already connected and logged in.
      
      DomainModelEntityManager mgr = DomainModelEntityManager.DefaultManager;

      var query = mgr.Customers
                  .Select(c =&gt; new { c.CustomerID, c.CompanyName });
      mgr.ExecuteQueryAsync(query, FetchCompleted, "F1");
    }

    private void FetchCompleted(EntityFetchedEventArgs args) {
      // Special logic to handle a projection query - 
      //  you can't bind to an anonymous type in Silverlight.

      // If an anonymous type is returned from a query, convert
      // it to a DevForce dynamic type to enable binding.
      // The Convert method returns an IEnumerable, which you
      // can use to directly set a DataGrid ItemsSource property.
      if (AnonymousFns.IsAnonymousType(args.Query.ReturnType)) {
        _dataGrid.ItemsSource = DynamicTypeConverter.Convert(args.Result);
      } else {
        _dataGrid.ItemsSource = args.Result;
      }

      // Binding to anonymous types isn't supported in Silverlight because the anonymous
      // type is not a public type.  The converted 'dynamic type' is public.  We can see this
      // here:
      bool isPublic1 = args.Query.ReturnType.IsPublic;
      bool isPublic2 = DynamicTypeConverter.Convert(args.Result).AsQueryable().ElementType.IsPublic;
   }
        </code>
      </example>
        </member>
        <member name="M:IdeaBlade.Core.DynamicTypeConverter.Convert(System.Collections.IEnumerable)">
            <summary>
            Convert a collection of anonymously-typed objects into dynamicly-typed objects.
            </summary>
            <param name="anonObjects"></param>
            <returns></returns>
            <remarks>
            The return object will be a collection of dynamic type instances, which can be bound to
            without problems in Silverlight.
            </remarks>
            <example>
        <code lang="C#">
    private void RunProjectionQuery() {
      // Run a query (asynchronously) which returns an anonymous type.
      // Assume we've already connected and logged in.
      
      DomainModelEntityManager mgr = DomainModelEntityManager.DefaultManager;

      var query = mgr.Customers
                  .Select(c =&gt; new { c.CustomerID, c.CompanyName });
      mgr.ExecuteQueryAsync(query, FetchCompleted, "F1");
    }

    private void FetchCompleted(EntityFetchedEventArgs args) {
      // Special logic to handle a projection query - 
      //  you can't bind to an anonymous type in Silverlight.

      // If an anonymous type is returned from a query, convert
      // it to a DevForce dynamic type to enable binding.
      // The Convert method returns an IEnumerable, which you
      // can use to directly set a DataGrid ItemsSource property.
      if (AnonymousFns.IsAnonymousType(args.Query.ReturnType)) {
        _dataGrid.ItemsSource = DynamicTypeConverter.Convert(args.Result);
      } else {
        _dataGrid.ItemsSource = args.Result;
      }

      // Binding to anonymous types isn't supported in Silverlight because the anonymous
      // type is not a public type.  The converted 'dynamic type' is public.  We can see this
      // here:
      bool isPublic1 = args.Query.ReturnType.IsPublic;
      bool isPublic2 = DynamicTypeConverter.Convert(args.Result).AsQueryable().ElementType.IsPublic;
   }
        </code>
      </example>
        </member>
        <member name="T:IdeaBlade.Core.DynamicTypeInfo">
            <summary>
            Internal use only.
            </summary>
        </member>
        <member name="F:IdeaBlade.Core.DynamicTypeInfo.CSharpAnonPrefix">
            <summary>
            For internal use only
            </summary>
        </member>
        <member name="F:IdeaBlade.Core.DynamicTypeInfo.CSharpDynamicPrefix">
            <summary>
            For internal use only
            </summary>
        </member>
        <member name="F:IdeaBlade.Core.DynamicTypeInfo.VBAnonPrefix">
            <summary>
            For internal use only
            </summary>
        </member>
        <member name="F:IdeaBlade.Core.DynamicTypeInfo.VBDynamicPrefix">
            <summary>
            For internal use only
            </summary>
        </member>
        <member name="F:IdeaBlade.Core.DynamicTypeInfo.BaseDynamicPrefix">
            <summary>
            For internal use only
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.DynamicTypeInfo.FindOrCreate(System.Type)">
            <summary>
            Either finds a dynamic type that matches the specified anon or dynamic type or 
            creates a new DynamicTypeInfo that does.
            </summary>
            <param name="anonOrDynType"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.DynamicTypeInfo.FindOrCreate(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Either finds a dynamic type that matches the specified propertyNames and propertyTypes or creates a 
            new DynamicType that does.  
            </summary>
            <param name="propertyNames"></param>
            <param name="propertyTypes"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.DynamicTypeInfo.#ctor(System.Type)">
            <summary>
            For internal use only. Builds a dynamic type from an anonymous type.
            </summary>
            <param name="anonType"></param>
        </member>
        <member name="M:IdeaBlade.Core.DynamicTypeInfo.#ctor(IdeaBlade.Core.DynamicTypeInfo.TypeShape)">
            <summary>
            Called by FindOrCreate to create a new dynamictypeinfo based on the selected properties and types  
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.DynamicTypeInfo.Equals(System.Object)">
            <summary>
            For internal use only.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.DynamicTypeInfo.GetHashCode">
            <summary>
            For internal use only.
            </summary>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.DynamicTypeInfo.ConvertType(System.Type)">
            <summary>
            Converts a anon type to a dynamic type and returns non-anon types unchanged.  If the same anon type is converted more than once the same dynamic type will be returned.
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.DynamicTypeInfo.FindByAssemblyName(System.String)">
            <summary>
            Return the DynamicTypeInfo for the specified assembly name containing a dynamic type.
            </summary>
            <param name="pAssemblyName"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.DynamicTypeInfo.FindByDynamicTypeName(System.String)">
            <summary>
            Return the DynamicTypeInfo for the specified dynamic type name.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.DynamicTypeInfo.IsDynamicType(System.Type)">
            <summary>
            For internal use only.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.DynamicTypeInfo.ConvertDynamicAssemblyNameToDynamicTypeName(System.String)">
            <summary>
            Return the dynamic type name for the specified assembly name containing the dynamic type.
            </summary>
            <param name="pAssemblyName"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.DynamicTypeInfo.FindByTypeShape(IdeaBlade.Core.DynamicTypeInfo.TypeShape)">
            <summary>
            For internal use only.
            </summary>
            <param name="typeShape"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.DynamicTypeInfo.BuildDynamicTypeName">
            <summary>
            The type name generated must be the same even if generated during different sessions
            ( so no part can be random or based on the current time)
            because this same name may be sent to the server by multiple clients and
            the server needs to understand that these are all the same type. 
            </summary>
            <returns></returns>
        </member>
        <member name="P:IdeaBlade.Core.DynamicTypeInfo.OriginalType">
            <summary>
            For internal use only.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.DynamicTypeInfo.DynamicType">
            <summary>
            For internal use only.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.DynamicTypeInfo.TypeName">
            <summary>
            For internal use only.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.DynamicTypeInfo.DynamicTypeName">
            <summary>
            For internal use only.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.DynamicTypeInfo.PropertyNames">
            <summary>
            For internal use only.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.DynamicTypeInfo.PropertyTypes">
            <summary>
            For internal use only.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.DynamicTypeInfo.Properties">
            <summary>
            For internal use only.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.DynamicTypeInfo.DynamicConstructor">
            <summary>
            For internal use only.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.DynamicTypeInfo.DynamicEmptyConstructor">
            <summary>
            For internal use only.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.DynamicTypeInfo.DynamicTypeShouldSave">
            <summary>
            Should this dynamic type's assembly be written out as a file.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.DynamicTypeInfo.DynamicTypeFileDirectory">
            <summary>
            File directory to write out the dynamic types assembly.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.DynamicTypeInfo.PropertyNameWrappers">
            <summary>
            For internal use only.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.DynamicTypeInfo.PropertyTypeWrappers">
            <summary>
            For internal use only.
            </summary>
        </member>
        <member name="T:IdeaBlade.Core.DynamicTypeInfo.TypeShape">
             <summary>
            Used for shape comparison.
             </summary>
        </member>
        <member name="T:IdeaBlade.Core.EventsHelper">
            <summary>
            Static methods to help when invoking event handlers.  Internal use only.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.EventsHelper.Fire(System.Delegate,System.Object[])">
            <summary>
            
            </summary>
            <param name="del"></param>
            <param name="args"></param>
        </member>
        <member name="M:IdeaBlade.Core.EventsHelper.FireAsync(System.Delegate,System.Object[])">
            <summary>
            
            </summary>
            <param name="del"></param>
            <param name="args"></param>
        </member>
        <member name="T:IdeaBlade.Core.FileFns">
            <summary>
            A collection of static utility methods all involved with the manipulation of files.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.FileFns.GetRelativePath(System.String,System.String)">
            { copied from Rick Stahl's blog }
            <summary>
            Returns a relative path string from a full path.
            </summary>
            <param name="fullPath">Full path</param>
            <param name="basePath">Base path from which full path will be made relative </param>
            <returns>The relative path</returns>
            <remarks>
            The path to convert can be either a file or a directory.  If path is a directory it's returned 
            without a backslash at the end.  Examples of returned values:
            ".\test.txt", "..\test.txt", "..\..\..\test.txt", ".", "..".
            </remarks>
        </member>
        <member name="M:IdeaBlade.Core.FileFns.WriteTextFile(System.String,System.String)">
            <summary>
            Write a string into a file either creating the file or replacing its current contents
            </summary>
            <param name="pFileName">The file to write to</param>
            <param name="pContents">A string to write to the file</param>
        </member>
        <member name="M:IdeaBlade.Core.FileFns.WriteTextFile(System.String,System.String,System.Text.Encoding)">
            <summary>
            Write a string into a file either creating the file or replacing its current contents
            </summary>
            <param name="pFileName">The file to write to</param>
            <param name="pContents">A string to write to the file</param>
            <param name="pEncoding">The Encoding to use</param>
        </member>
        <member name="M:IdeaBlade.Core.FileFns.WriteStream(System.String,System.IO.Stream)">
            <summary>
            Write a stream into a file either creating the file or replacing its current contents
            </summary>
            <param name="fileName">The file to write to</param>
            <param name="stream">A stream to write to the file</param>
        </member>
        <member name="M:IdeaBlade.Core.FileFns.RenameFileWithCurrentTimestamp(System.String,System.Boolean)">
            <summary>
            Renames a file by adding the current ts to its name
            For example: foo.txt becomes foo.bak.20021102-102034.txt
            </summary>
            <param name="pFileName"></param>
            <param name="pThrowOnNotFound"></param>
        </member>
        <member name="M:IdeaBlade.Core.FileFns.CopyDirectory(System.String,System.String,System.Boolean)">
            <summary>
            
            </summary>
            <param name="pSourcePath"></param>
            <param name="pDestPath"></param>
            <param name="pOverwrite"></param>
        </member>
        <member name="M:IdeaBlade.Core.FileFns.DeleteDirectory(System.String)">
            <summary>
            This method is intended to work around a bug with Directory.Delete sometimes failing 
            with "Directory is not empty" error. It does a recursive delete of the entire dir structure
            under the specified path
            </summary>
            <param name="pPath"></param>
        </member>
        <member name="T:IdeaBlade.Core.IHasListManager">
            <summary>
            Interface implemented by lists which can be managed by a <see cref="T:IdeaBlade.Core.IListManager"/>.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.IHasListManager.ListManager">
            <summary>
            Gets or sets the list the <see cref="T:IdeaBlade.Core.IListManager"/> for a list.
            </summary>
            <returns></returns>
        </member>
        <member name="T:IdeaBlade.Core.IHideObjectMembers">
            <summary>
            Hides standard Object members from Intellisense  
            to make fluent interfaces easier to read. 
            May be implemented on any class.
            Based on blog post by @kzu here: 
            http://bit.ly/ifluentinterface 
            </summary> 
        </member>
        <member name="M:IdeaBlade.Core.IHideObjectMembers.GetType">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.IHideObjectMembers.GetHashCode">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.IHideObjectMembers.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.IHideObjectMembers.Equals(System.Object)">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="T:IdeaBlade.Core.IListManager">
            <summary>
            An implementor of the IListManager interface
            holds one IList (or many ILists collectively) 
            under the control of a manager of some sort.
            </summary>
            <remarks>
            The manager is expected to control how items are added and removed from the list(s).
            <see cref="T:IdeaBlade.EntityModel.EntityListManager`1"/> is the primary example of an IListManager implementor.
            </remarks>
        </member>
        <member name="M:IdeaBlade.Core.IListManager.ManageList(System.Collections.IList,System.Boolean)">
            <summary>
            Add pList to the set of the manager's lists.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.IListManager.UnmanageList(System.Collections.IList)">
            <summary>
            Remove pList from the set of the manager's lists.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.IListManager.ContainsList(System.Collections.IList)">
            <summary>
            Return true if pList is in the set of the manager's lists.
            </summary>
        </member>
        <member name="T:IdeaBlade.Core.InternalFns">
            <summary>
            A collection of static utility methods used internally by the DevForce framework.
            </summary>
        </member>
        <member name="F:IdeaBlade.Core.InternalFns.DynamicAssemblyNameSuffix">
            <summary>
            Suffix added to all dynamic assemblies constructed by the DevForce framework.
            </summary>
        </member>
        <member name="F:IdeaBlade.Core.InternalFns.IdeaBladeAssemblyExtn">
            <summary>
            Version, culture and PublicKeyToken for all IdeaBlade assemblies - should be concatenated
            to the end of a partially qualified assembly name to fully qualify it
            See GetIdeaBladeType
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.InternalFns.GetIdeaBladeAssemblyName(System.String)">
            <summary>
            Returns the assembly-qualified name of an IdeaBlade assembly.
            </summary>
            <param name="pAssemblyName"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.InternalFns.GetIdeaBladeAssembly(System.String,System.Boolean)">
            <summary>
            Returns the specified IdeaBlade assembly.
            </summary>
            <param name="assemblyName"></param>
            <param name="throwOnError"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.InternalFns.GetIdeaBladeType(System.String,System.Boolean)">
            <summary>
            Returns the specified IdeaBlade type.
            </summary>
            <param name="typeName"></param>
            <param name="throwOnError"></param>
            <returns></returns>
        </member>
        <member name="T:IdeaBlade.Core.MemberMetadataMap">
            <summary>
            Singleton class that provides metadata about any .NET member. 
            </summary>
            <remarks>
            This is used internally by the framework to hold information about Entity
            properties.
            </remarks>
        </member>
        <member name="M:IdeaBlade.Core.MemberMetadataMap.GetMemberMetadata(System.Reflection.MemberInfo,System.Func{System.Reflection.MemberInfo,IdeaBlade.Core.MemberMetadata})">
            <summary>
            Get the MemberMetadata for any given member of a Type.
            </summary>
            <param name="member"></param>
            <param name="memberMetadataCtor"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.MemberMetadataMap.InitializeEntityMemberMetadata">
            <summary>
            Need to insure that EntityMemberMetadata constructor is initialized.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.MemberMetadataMap.Instance">
            <summary>
            Singleton instance of the MemberdataMap.
            </summary>
        </member>
        <member name="T:IdeaBlade.Core.MemberMetadata">
            <summary>
            Metadata information about a Type member.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.MemberMetadata.Merge(IdeaBlade.Core.MemberMetadata)">
            <summary>
            For internal use only.
            </summary>
            <param name="other"></param>
        </member>
        <member name="F:IdeaBlade.Core.MemberMetadata.NullInstance">
            <summary>
            A null instance of a MemberMetadata.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.MemberMetadata.Member">
            <summary>
            The Member to which this metadata applies.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.MemberMetadata.DisplayName">
            <summary>
            The display name for this member;
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.MemberMetadata.Description">
            <summary>
            The description of this member.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.MemberMetadata.ShortName">
            <summary>
            The description of this member.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.MemberMetadata.ReadOnly">
            <summary>
            Is this member readonly?
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.MemberMetadata.ValidationAttributes">
            <summary>
            List of validation attributes.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.MemberMetadata.Bindable">
            <summary>
            Is this member bindable?
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.MemberMetadata.BindingDirection">
            <summary>
            If bindable, in which directions?
            </summary>
        </member>
        <member name="T:IdeaBlade.Core.MemoFns">
            <summary>
            A collection of static utility methods relating to memoization.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.MemoFns.Memoize``1(System.Func{``0})">
            <summary>
            Function memoization overload
            </summary>
            <typeparam name="R"></typeparam>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.MemoFns.Memoize``2(System.Func{``0,``1})">
            <summary>
            Function memoization overload
            </summary>
            <typeparam name="A"></typeparam>
            <typeparam name="R"></typeparam>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.MemoFns.Memoize``3(System.Func{``0,``1,``2})">
            <summary>
            Function memoization overload
            </summary>
            <typeparam name="A1"></typeparam>
            <typeparam name="A2"></typeparam>
            <typeparam name="R"></typeparam>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.MemoFns.Memoize``4(System.Func{``0,``1,``2,``3})">
            <summary>
            Function memoization overload
            </summary>
            <typeparam name="A1"></typeparam>
            <typeparam name="A2"></typeparam>
            <typeparam name="A3"></typeparam>
            <typeparam name="R"></typeparam>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.MemoFns.Memoize``5(System.Func{``0,``1,``2,``3,``4})">
            <summary>
            Function memoization overload
            </summary>
            <typeparam name="A1"></typeparam>
            <typeparam name="A2"></typeparam>
            <typeparam name="A3"></typeparam>
            <typeparam name="A4"></typeparam>
            <typeparam name="R"></typeparam>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.MemoFns.Memoize``6(System.Func{``0,``1,``2,``3,``4,``5})">
            <summary>
            Function memoization overload
            </summary>
            <typeparam name="A1"></typeparam>
            <typeparam name="A2"></typeparam>
            <typeparam name="A3"></typeparam>
            <typeparam name="A4"></typeparam>
            <typeparam name="A5"></typeparam>
            <typeparam name="R"></typeparam>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="T:IdeaBlade.Core.DictionaryComparer`1">
            <summary>
            For internal use only. 
            </summary>
            <remarks>Hack for problem with Type[] equality</remarks>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:IdeaBlade.Core.DictionaryComparer`1.#ctor">
            <summary>
            Creates a new instance of  the DictionaryComparer{T} class.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.DictionaryComparer`1.Equals(`0,`0)">
            <summary>
            Determines whether the given instances are considered equal.
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.DictionaryComparer`1.GetHashCode(`0)">
            <summary>
            Returns the hash code for thge given object.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="T:IdeaBlade.Core.NamespaceFilterMode">
            <summary>
            An enum that is used to accept or reject logging from specific namespaces.  Internal use only.
            <seealso cref="T:IdeaBlade.Core.NamespaceFilter"/>
            </summary>
        </member>
        <member name="F:IdeaBlade.Core.NamespaceFilterMode.Accept">
            <summary>
            Accept the namespace
            </summary>
        </member>
        <member name="F:IdeaBlade.Core.NamespaceFilterMode.Reject">
            <summary>
            Reject the namespace
            </summary>
        </member>
        <member name="T:IdeaBlade.Core.NamespaceFilter">
            <summary>
            Used in trace message logging to determine whether calls from a namespace should be traced.
            </summary>
            <remarks>
            You can control the namespaces to be filtered during use of the <see cref="T:IdeaBlade.Core.DebugFns"/> and
            <see cref="T:IdeaBlade.Core.TraceFns"/> calls by using the <b>namespaceAcceptFilters</b> and 
            <b>namespaceRejectFilters</b> settings in the <see cref="P:IdeaBlade.Core.IdeaBladeConfig.Logging"/> section 
            of your configuration file.
            </remarks>
        </member>
        <member name="M:IdeaBlade.Core.NamespaceFilter.#ctor">
            <summary>
            Initializes a new instance of the NamespaceFilter class.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.NamespaceFilter.#ctor(IdeaBlade.Core.NamespaceFilterMode,System.String)">
            <summary>
            Initializes a new instance of the NamespaceFilter class.
            </summary>
            <param name="mode"></param>
            <param name="aNamespace"></param>
        </member>
        <member name="P:IdeaBlade.Core.NamespaceFilter.Mode">
            <summary>
            The NamespaceFilterMode associated with this filter.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.NamespaceFilter.Namespace">
            <summary>
            The namespace associated with this filter.
            </summary>
        </member>
        <member name="T:IdeaBlade.Core.PropertyInterceptor">
            <summary>
            Used to add custom actions to property getters and setters.
            <seealso cref="T:IdeaBlade.Core.PropertyInterceptor`3"/>
            <seealso cref="T:IdeaBlade.Core.PropertyInterceptorAction`1"/>
            </summary>
            <remarks>
            An interceptor is defined for a <see cref="P:IdeaBlade.Core.PropertyInterceptor.TargetType"/>, <see cref="P:IdeaBlade.Core.PropertyInterceptor.TargetName"/>
            and <see cref="P:IdeaBlade.Core.PropertyInterceptor.PropertyDirection"/> to provide custom actions on getters and setters.
            <para>
            Any number of <see cref="T:IdeaBlade.Core.PropertyInterceptorAction">PropertyInterceptorActions</see>
            may be defined for each interceptor.  You add these actions using <see cref="T:IdeaBlade.Core.PropertyInterceptorAttribute">attributes</see>
            and <see cref="M:IdeaBlade.Core.PropertyInterceptor`3.AddAction(IdeaBlade.Core.PropertyInterceptorAction{`2})">AddAction</see>.
            </para>
            <para>
            You may also define <b>PropertyInterceptors</b> and actions on non-Entity types.
            </para>
            </remarks>
        </member>
        <member name="M:IdeaBlade.Core.PropertyInterceptor.GetValue(System.Object,System.Object)">
            <summary>
            Retrieves the value of this property in the specified object.
            </summary>
            <param name="instance"></param>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.PropertyInterceptor.SetValue(System.Object,System.Object,System.Object)">
            <summary>
            Sets the value of this property in the specified object.
            </summary>
            <param name="instance"></param>
            <param name="context"></param>
            <param name="value"></param>
        </member>
        <member name="M:IdeaBlade.Core.PropertyInterceptor.Reset">
            <summary>
            Resets the actions for the interceptor.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.PropertyInterceptor.TargetType">
            <summary>
            Type of object on which the interceptor acts.
            </summary>
            <remarks>
            The action will apply to the TargetType and its sub-types.
            </remarks>
        </member>
        <member name="P:IdeaBlade.Core.PropertyInterceptor.TargetName">
            <summary>
            The name of the property on which the interceptor acts.
            </summary>
            <remarks>
            If null or an emtpy string the action applies to all properties in the
            <see cref="P:IdeaBlade.Core.PropertyInterceptor.TargetType"/> and sub-types.
            </remarks>
        </member>
        <member name="P:IdeaBlade.Core.PropertyInterceptor.ValueType">
            <summary>
            The Type of the property value.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.PropertyInterceptor.ArgsType">
            <summary>
            Type of arguments passed to interceptor actions.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.PropertyInterceptor.PropertyDirection">
            <summary>
            Whether the interceptor is defined for a getter or setter.
            </summary>
        </member>
        <member name="T:IdeaBlade.Core.PropertyInterceptor`3">
            <summary>
            Used to add custom actions to property getters and setters.
            <seealso cref="T:IdeaBlade.Core.PropertyInterceptorAction`1"/>
            </summary>
            <typeparam name="TInstance">Type of object</typeparam>
            <typeparam name="TValue">Type of property value</typeparam>
            <typeparam name="TArgs">Type of arguments to actions</typeparam>
            <remarks>
            Every <b>EntityProperty</b> has a <b>GetterInterceptor</b>, and if not returning a list of related entities, a <b>SetterInterceptor</b>.
            <para>
            Any number of <see cref="T:IdeaBlade.Core.PropertyInterceptorAction">PropertyInterceptorActions</see>
            may be defined for each interceptor.  You add these actions using <see cref="T:IdeaBlade.Core.PropertyInterceptorAttribute">attributes</see>
            and <see cref="M:IdeaBlade.Core.PropertyInterceptor`3.AddAction(IdeaBlade.Core.PropertyInterceptorTiming,System.Action{`2})"/>.
            </para>
            <para>
            You may also define <b>PropertyInterceptors</b> and actions on non-Entity types.
            </para>
            </remarks>
            <example>
        <code lang="C#">
          
      public void Sample() {
       
        // Sample showing a mix of attribute and dynamic actions, on both base and derived types.
    
        // Add dynamic actions on Entity to affect any property:
        PropertyInterceptorManager.CurrentInstance.AddAction(
          new PropertyInterceptorAction&lt;PropertyInterceptorArgs&lt;Entity, Object&gt;&gt;(
            typeof(Entity),
            null,
            PropertyInterceptorMode.BeforeSet,
            (args) =&gt; Console.WriteLine("Entity BeforeSet"),
            0.0, "A"));

        PropertyInterceptorManager.CurrentInstance.AddAction(
          new PropertyInterceptorAction&lt;PropertyInterceptorArgs&lt;Entity, Object&gt;&gt;(
            typeof(Entity), 
            null,
            PropertyInterceptorMode.AfterSet,
            (args) =&gt; Console.WriteLine("Entity AfterSet"),
            0.0, "B"));

        // Look at all before set actions affecting customer company name
        foreach (var action in Customer.CompanyNameEntityProperty.SetterInterceptor.GetActions(typeof(Customer), PropertyInterceptorMode.BeforeSet)) {
          Console.WriteLine(action.Key + ", order = " + action.Order);
        }
        // Now look at all after set actions affecting customer company name
        foreach (var action in Customer.CompanyNameEntityProperty.SetterInterceptor.GetActions(typeof(Customer), PropertyInterceptorMode.AfterSet)) {
          Console.WriteLine(action.Key + ", order = " + action.Order);
        }
        
        // Now get a customer entity and set company name - see output for actions invoked.
        DomainModelEntityManager mgr = DomainModelEntityManager.DefaultManager;
        Customer c1 = mgr.Customers.First();
        c1.CompanyName = "Books N Things";
      }
      
  public partial class Customer {

    [BeforeSet(Key = "CustomerBeforeAction1")]
    public void BeforeSetAnyCustomerProperty(IEntityPropertySetInterceptorArgs args) {
      Console.WriteLine("Customer any - before setting " + args.EntityProperty.Name);
    }

    [BeforeSet("CompanyName", Key = "CustomerBeforeAction2")]
    public void BeforeSetCompanyName(IEntityPropertySetInterceptorArgs args) {
      Console.WriteLine("Customer companyname - before setting company name");
    }

    [AfterSet(Key="CustomerAfterAction1")]
    public void AfterSetAnyCustomerProperty(IEntityPropertySetInterceptorArgs args) {
      Console.WriteLine("Customer any - After setting " + args.EntityProperty.Name);
    }

    [AfterSet("CompanyName", Key="CustomerAfterAction2")]
    public void AfterSetCompanyName(IEntityPropertySetInterceptorArgs args) {
      Console.WriteLine("Customer companyname - After setting company name");
    }
  }
        </code>
      </example>
        </member>
        <member name="M:IdeaBlade.Core.PropertyInterceptor`3.#ctor(System.String,IdeaBlade.Core.PropertyDirection,System.Action{`2},System.Func{`0,System.Object,`2})">
            <summary>
            Creates an instance of this class.
            </summary>
            <param name="targetName"></param>
            <param name="direction"></param>
            <param name="baseAction"></param>
            <param name="buildArgsFunc"></param>
        </member>
        <member name="M:IdeaBlade.Core.PropertyInterceptor`3.GetValue(`0)">
            <summary>
            Retrieves the value of this property in the specified object.
            </summary>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.PropertyInterceptor`3.GetValue(System.Object,System.Object)">
            <summary>
            Retrieves the value of this property in the specified object.
            </summary>
            <param name="instance"></param>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.PropertyInterceptor`3.GetValue(`0,System.Object)">
            <summary>
            Retrieves the value of this property in the specified object.
            </summary>
            <param name="instance"></param>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.PropertyInterceptor`3.SetValue(`0,`1)">
            <summary>
            Sets the value of this property in the specified object.
            </summary>
            <param name="instance"></param>
            <param name="value"></param>
        </member>
        <member name="M:IdeaBlade.Core.PropertyInterceptor`3.SetValue(System.Object,System.Object,System.Object)">
            <summary>
            Sets the value of this property in the specified object.
            </summary>
            <param name="instance"></param>
            <param name="context"></param>
            <param name="value"></param>
        </member>
        <member name="M:IdeaBlade.Core.PropertyInterceptor`3.SetValue(`0,System.Object,`1)">
            <summary>
            Sets the value of this property in the specified object.
            </summary>
            <param name="instance"></param>
            <param name="context"></param>
            <param name="value"></param>
        </member>
        <member name="M:IdeaBlade.Core.PropertyInterceptor`3.AddAction(IdeaBlade.Core.PropertyInterceptorTiming,System.Action{`2})">
            <summary>
            Adds an action to the interceptor.
            </summary>
            <param name="timing"></param>
            <param name="action"></param>
            <example>
        <code lang="C#">
    public void Sample() {

      // Add a BeforeGet action to a GetterInterceptor:
      Employee.PropertyMetadata.Address.GetterInterceptor.AddAction(
        PropertyInterceptorTiming.Before,
        TraceGetter);

      // Add a BeforeSet action to a SetterInterceptor:
      Employee.PropertyMetadata.Country.SetterInterceptor.AddAction(
        PropertyInterceptorTiming.Before,
        TraceSetter);

      // Get/set a few properties
      DomainModelEntityManager mgr = DomainModelEntityManager.DefaultManager;
      Employee e = mgr.Employees.First();
      string addy = e.Address;
      e.Country = "UK";
    }
    
    public static void TraceGetter(IEntityPropertyGetInterceptorArgs args) {
      Console.WriteLine("getter called for " + args.EntityProperty.Name);
    }

    public static void TraceSetter(IEntityPropertySetInterceptorArgs args) {
      Console.WriteLine("setter called for " + args.EntityProperty.Name);
    }
        </code>
      </example>
        </member>
        <member name="M:IdeaBlade.Core.PropertyInterceptor`3.AddAction(IdeaBlade.Core.PropertyInterceptorAction{`2})">
            <summary>
            Adds an action to the interceptor.
            </summary>
            <param name="interceptorAction"></param>
            <example>
        <code lang="C#">
    public void Sample() {

      // Add a BeforeGet action on Employe.Address  
      var piAction = new PropertyInterceptorAction&lt;DataEntityPropertyGetInterceptorArgs&lt;Employee, String&gt;&gt;(
                typeof(Employee),
                Employee.EntityPropertyNames.Address,
                PropertyInterceptorMode.BeforeGet,
                TraceGetter);
      PropertyInterceptorManager.CurrentInstance.AddAction(piAction);

      // Add a BeforeSet action on Employee.Country
      var piAction2 = new PropertyInterceptorAction&lt;DataEntityPropertySetInterceptorArgs&lt;Employee, String&gt;&gt;(
          typeof(Employee),
          Employee.EntityPropertyNames.Country,
          PropertyInterceptorMode.BeforeSet,
          TraceSetter);
      PropertyInterceptorManager.CurrentInstance.AddAction(piAction2);

      // Get/set a few properties
      DomainModelEntityManager mgr = DomainModelEntityManager.DefaultManager;
      Employee e = mgr.Employees.First();
      string addy = e.Address;
      e.Country = "UK";
    }
    
    public static void TraceGetter(DataEntityPropertyGetInterceptorArgs&lt;Employee, String&gt;&gt; args) {
      Console.WriteLine("getter called for " + args.DataEntityProperty.Name);
    }

    public static void TraceSetter(DataEntityPropertySetInterceptorArgs&lt;Employee, String&gt;&gt; args) {
      Console.WriteLine("setter called for " + args.DataEntityProperty.Name);
    }
        </code>
      </example>
        </member>
        <member name="M:IdeaBlade.Core.PropertyInterceptor`3.AddAction``1(IdeaBlade.Core.PropertyInterceptorAction{``0})">
            <summary>
            Adds an action to the interceptor.
            </summary>
            <typeparam name="TNewArgs"></typeparam>
            <param name="interceptorAction"></param>
            <remarks>
            For use when the type of arguments to the action differ from <see cref="P:IdeaBlade.Core.PropertyInterceptor`3.ArgsType"/>.
            <para>
            Primarily intended for use within the framework when the action provided 
            is not a true base class of PropertyIntercepterAction&lt;TArgs&gt; but is
            coerceable into it.
            </para>
            </remarks>
        </member>
        <member name="M:IdeaBlade.Core.PropertyInterceptor`3.GetActions">
            <summary>
            Retrieve all actions for the interceptor.
            </summary>
            <returns></returns>
            <remarks>
            Skipped keys are not included in the return list.
            </remarks>
            <example>
        <code lang="C#">
    public void Sample() {

      DomainModelEntityManager mgr = DomainModelEntityManager.DefaultManager;
      Customer c1 = mgr.Customers.First();

      // Look at all before set actions affecting customer company name
      foreach (var action in Customer.CompanyNameEntityProperty.SetterInterceptor.GetActions(PropertyInterceptorTiming.Before, typeof(Customer))) {
        Console.WriteLine(action.Key + " = " + action.Order);
      }

      // Skip an action
      Customer.CompanyNameEntityProperty.SetterInterceptor.AddSkipKey("A");

      // Set property - output window will show which actions were performed.
      c1.CompanyName = "Boxes n Things";

      // Now include the skipped action.
      Customer.CompanyNameEntityProperty.SetterInterceptor.RemoveSkipKey("A");

      // Set property - we should see all actions invoked.
      c1.CompanyName = "Boxes n Stuff";
    }
    
  public partial class Customer {

    [BeforeSet(Key = "A")]
    public void BeforeSetAnyCustomerProperty(IEntityPropertySetInterceptorArgs args) {
      Console.WriteLine("Customer any - before setting " + args.EntityProperty.Name);
    }

    [BeforeSet("CompanyName", Key = "B")]
    public void BeforeSetCompanyName(IEntityPropertySetInterceptorArgs args) {
      Console.WriteLine("Customer companyname - before setting company name");
    }
  }
        </code>
      </example>
        </member>
        <member name="M:IdeaBlade.Core.PropertyInterceptor`3.GetActions(IdeaBlade.Core.PropertyInterceptorTiming)">
            <summary>
            Retrieve all before or after actions for the interceptor.
            </summary>
            <param name="timing"></param>
            <returns></returns>
            <remarks>
            Skipped keys are not included in the return list.
            </remarks>
            <example>
        <code lang="C#">
    public void Sample() {

      DomainModelEntityManager mgr = DomainModelEntityManager.DefaultManager;
      Customer c1 = mgr.Customers.First();

      // Look at all before set actions affecting customer company name
      foreach (var action in Customer.CompanyNameEntityProperty.SetterInterceptor.GetActions(PropertyInterceptorTiming.Before, typeof(Customer))) {
        Console.WriteLine(action.Key + " = " + action.Order);
      }

      // Skip an action
      Customer.CompanyNameEntityProperty.SetterInterceptor.AddSkipKey("A");

      // Set property - output window will show which actions were performed.
      c1.CompanyName = "Boxes n Things";

      // Now include the skipped action.
      Customer.CompanyNameEntityProperty.SetterInterceptor.RemoveSkipKey("A");

      // Set property - we should see all actions invoked.
      c1.CompanyName = "Boxes n Stuff";
    }
    
  public partial class Customer {

    [BeforeSet(Key = "A")]
    public void BeforeSetAnyCustomerProperty(IEntityPropertySetInterceptorArgs args) {
      Console.WriteLine("Customer any - before setting " + args.EntityProperty.Name);
    }

    [BeforeSet("CompanyName", Key = "B")]
    public void BeforeSetCompanyName(IEntityPropertySetInterceptorArgs args) {
      Console.WriteLine("Customer companyname - before setting company name");
    }
  }
        </code>
      </example>
        </member>
        <member name="M:IdeaBlade.Core.PropertyInterceptor`3.GetActions(IdeaBlade.Core.PropertyInterceptorTiming,System.Type)">
            <summary>
            Retrieve all actions for the specified type and mode.
            </summary>
            <param name="timing"></param>
            <param name="targetType"></param>
            <returns></returns>
            <remarks>
            The <paramref name="targetType"/> parameter value may  be a subtype of <see cref="P:IdeaBlade.Core.PropertyInterceptor`3.TargetType"/>.
            Skipped keys are not included in the return list.
            </remarks>
            <example>
        <code lang="C#">
    public void Sample() {

      DomainModelEntityManager mgr = DomainModelEntityManager.DefaultManager;
      Customer c1 = mgr.Customers.First();

      // Look at all before set actions affecting customer company name
      foreach (var action in Customer.CompanyNameEntityProperty.SetterInterceptor.GetActions(PropertyInterceptorTiming.Before, typeof(Customer))) {
        Console.WriteLine(action.Key + " = " + action.Order);
      }

      // Skip an action
      Customer.CompanyNameEntityProperty.SetterInterceptor.AddSkipKey("A");

      // Set property - output window will show which actions were performed.
      c1.CompanyName = "Boxes n Things";

      // Now include the skipped action.
      Customer.CompanyNameEntityProperty.SetterInterceptor.RemoveSkipKey("A");

      // Set property - we should see all actions invoked.
      c1.CompanyName = "Boxes n Stuff";
    }
    
  public partial class Customer {

    [BeforeSet(Key = "A")]
    public void BeforeSetAnyCustomerProperty(IEntityPropertySetInterceptorArgs args) {
      Console.WriteLine("Customer any - before setting " + args.EntityProperty.Name);
    }

    [BeforeSet("CompanyName", Key = "B")]
    public void BeforeSetCompanyName(IEntityPropertySetInterceptorArgs args) {
      Console.WriteLine("Customer companyname - before setting company name");
    }
  }
        </code>
      </example>
        </member>
        <member name="M:IdeaBlade.Core.PropertyInterceptor`3.Reset">
            <summary>
            All actions for the interceptor will be re-discovered.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.PropertyInterceptor`3.AddSkipKey(System.String)">
            <summary>
            Use to temporarily ignore a specific action in the interceptor.
            </summary>
            <param name="key"></param>
            <example>
        <code lang="C#">
    public void Sample() {

      DomainModelEntityManager mgr = DomainModelEntityManager.DefaultManager;
      Customer c1 = mgr.Customers.First();

      // Look at all before set actions affecting customer company name
      foreach (var action in Customer.CompanyNameEntityProperty.SetterInterceptor.GetActions(PropertyInterceptorTiming.Before, typeof(Customer))) {
        Console.WriteLine(action.Key + " = " + action.Order);
      }

      // Skip an action
      Customer.CompanyNameEntityProperty.SetterInterceptor.AddSkipKey("A");

      // Set property - output window will show which actions were performed.
      c1.CompanyName = "Boxes n Things";

      // Now include the skipped action.
      Customer.CompanyNameEntityProperty.SetterInterceptor.RemoveSkipKey("A");

      // Set property - we should see all actions invoked.
      c1.CompanyName = "Boxes n Stuff";
    }
    
  public partial class Customer {

    [BeforeSet(Key = "A")]
    public void BeforeSetAnyCustomerProperty(IEntityPropertySetInterceptorArgs args) {
      Console.WriteLine("Customer any - before setting " + args.EntityProperty.Name);
    }

    [BeforeSet("CompanyName", Key = "B")]
    public void BeforeSetCompanyName(IEntityPropertySetInterceptorArgs args) {
      Console.WriteLine("Customer companyname - before setting company name");
    }
  }
        </code>
      </example>
        </member>
        <member name="M:IdeaBlade.Core.PropertyInterceptor`3.RemoveSkipKey(System.String)">
            <summary>
            Use to restore an action which had been skipped.
            </summary>
            <param name="key"></param>
            <example>
        <code lang="C#">
    public void Sample() {

      DomainModelEntityManager mgr = DomainModelEntityManager.DefaultManager;
      Customer c1 = mgr.Customers.First();

      // Look at all before set actions affecting customer company name
      foreach (var action in Customer.CompanyNameEntityProperty.SetterInterceptor.GetActions(PropertyInterceptorTiming.Before, typeof(Customer))) {
        Console.WriteLine(action.Key + " = " + action.Order);
      }

      // Skip an action
      Customer.CompanyNameEntityProperty.SetterInterceptor.AddSkipKey("A");

      // Set property - output window will show which actions were performed.
      c1.CompanyName = "Boxes n Things";

      // Now include the skipped action.
      Customer.CompanyNameEntityProperty.SetterInterceptor.RemoveSkipKey("A");

      // Set property - we should see all actions invoked.
      c1.CompanyName = "Boxes n Stuff";
    }
    
  public partial class Customer {

    [BeforeSet(Key = "A")]
    public void BeforeSetAnyCustomerProperty(IEntityPropertySetInterceptorArgs args) {
      Console.WriteLine("Customer any - before setting " + args.EntityProperty.Name);
    }

    [BeforeSet("CompanyName", Key = "B")]
    public void BeforeSetCompanyName(IEntityPropertySetInterceptorArgs args) {
      Console.WriteLine("Customer companyname - before setting company name");
    }
  }
        </code>
      </example>
        </member>
        <member name="P:IdeaBlade.Core.PropertyInterceptor`3.TargetType">
            <summary>
            Type of object on which the interceptor acts.
            </summary>
            <remarks>
            The action will apply to the TargetType and its sub-types.
            </remarks>
        </member>
        <member name="P:IdeaBlade.Core.PropertyInterceptor`3.ValueType">
            <summary>
            The Type of the property value.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.PropertyInterceptor`3.ArgsType">
            <summary>
            Type of arguments returned from the interceptor.
            </summary>
        </member>
        <member name="T:IdeaBlade.Core.PropertyInterceptorAction">
            <summary>
            Defines an action to  be performed in a <see cref="T:IdeaBlade.Core.PropertyInterceptor"/>.
            <seealso cref="T:IdeaBlade.Core.PropertyInterceptorAttribute"/>
            <seealso cref="T:IdeaBlade.Core.PropertyInterceptorAction`1"/>
            </summary>
            <remarks>
            See <see cref="T:IdeaBlade.Core.PropertyInterceptorAction`1"/> for more information.
            </remarks>
        </member>
        <member name="M:IdeaBlade.Core.PropertyInterceptorAction.ConvertTo``1">
            <summary>
            Internal use only.
            </summary>
            <typeparam name="TArgs"></typeparam>
            <returns></returns>
        </member>
        <member name="P:IdeaBlade.Core.PropertyInterceptorAction.TargetType">
            <summary>
            The Type of the object on which the interceptor acts.
            </summary>
            <remarks>
            Applies to the Type and its sub-types.
            </remarks>
        </member>
        <member name="P:IdeaBlade.Core.PropertyInterceptorAction.TargetName">
            <summary>
            The name of the property on which the interceptor acts.
            </summary>
            <remarks>
            The <b>TargetName</b> for untargeted interceptors - those for any property - will be
            null or an empty string.
            </remarks>
        </member>
        <member name="P:IdeaBlade.Core.PropertyInterceptorAction.Mode">
            <summary>
            When the action will be invoked.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.PropertyInterceptorAction.ArgsType">
            <summary>
            Type of arguments passed to the action.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.PropertyInterceptorAction.InstanceType">
            <summary>
            Instance type may not be the same as the TargetType. It may be one of its base classes.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.PropertyInterceptorAction.ValueType">
            <summary>
            Type of the property value.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.PropertyInterceptorAction.Key">
            <summary>
            The identifying name assigned to the action.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.PropertyInterceptorAction.Order">
            <summary>
            The invocation order of the action. 
            </summary>
            <remarks>
            The default <b>Order</b> is 0.0, indicating the order of execution follows
            the usual property interception rules (see the Developer's Guide).  Set the 
            <b>Order</b> to override the default.  Lower values will be executed before
            higher values.  Use the <b>Order</b> to control the execution sequence of a series of actions 
            for a getter or setter.
            </remarks>
            <example>
        <code lang="C#">
    public partial class Employee {
    
      // Sample interceptors with the Order attribute set.
      // Lower values are executed before higher values.
      // Here, BeforeGetLastName2 will be executed before BeforeGetLastName3.
      
      [BeforeGet(EntityPropertyNames.LastName, Order = 3.0)]
      public static void BeforeGetLastName3(IPropertyInterceptorArgs args) {
        var emp = args.Instance as Employee;
        Console.WriteLine("emp:BeforeGetLastName3");
      }

     [BeforeGet(EntityPropertyNames.LastName, Order = 2.0)]
      public static void BeforeGetLastName2(PropertyInterceptorArgs&lt;Employee, String&gt; args) {
        var emp = args.Instance as Employee;
        Console.WriteLine("emp:BeforeGetLastName2");
      }
    }
        </code>
      </example>
        </member>
        <member name="T:IdeaBlade.Core.PropertyInterceptorAction`1">
            <summary>
            Defines an action to  be performed in a <see cref="T:IdeaBlade.Core.PropertyInterceptor"/>.
            <seealso cref="T:IdeaBlade.Core.PropertyInterceptorAttribute"/>
            </summary>
            <typeparam name="TArgs">Type of arguments to the action</typeparam>
            <remarks>
            <b>PropertyInterceptorActions</b> are generally added by marking a method with one of the
            <see cref="T:IdeaBlade.Core.PropertyInterceptorAttribute"/> derivations.  You may also
            create actions dynamically and add them to the appropriate interceptor 
            or <see cref="T:IdeaBlade.Core.PropertyInterceptorManager"/> with
            <see cref="M:IdeaBlade.Core.PropertyInterceptor`3.AddAction(IdeaBlade.Core.PropertyInterceptorAction{`2})"/>
            </remarks>
        </member>
        <member name="M:IdeaBlade.Core.PropertyInterceptorAction`1.#ctor(System.Type,System.String,IdeaBlade.Core.PropertyInterceptorMode,System.Action{`0})">
            <summary>
            Creates an instance of this class.
            </summary>
            <param name="targetType">Type of object on which the interceptor action is invoked</param>
            <param name="targetName">The name of the property on which the interceptor acts.</param>
            <param name="mode">When the action is invoked</param>
            <param name="action">The action to be performed</param>
            <remarks>
            Both <see cref="P:IdeaBlade.Core.PropertyInterceptorAction.Order"/> and <see cref="P:IdeaBlade.Core.PropertyInterceptorAction.Key"/> default when using this constructor.
            </remarks>
            <example>
        <code lang="C#">
    public void Sample() {

      // Add a BeforeGet action on Employe.Address  
      var piAction = new PropertyInterceptorAction&lt;DataEntityPropertyGetInterceptorArgs&lt;Employee, String&gt;&gt;(
                typeof(Employee),
                Employee.EntityPropertyNames.Address,
                PropertyInterceptorMode.BeforeGet,
                TraceGetter);
      PropertyInterceptorManager.CurrentInstance.AddAction(piAction);

      // Add a BeforeSet action on Employee.Country
      var piAction2 = new PropertyInterceptorAction&lt;DataEntityPropertySetInterceptorArgs&lt;Employee, String&gt;&gt;(
          typeof(Employee),
          Employee.EntityPropertyNames.Country,
          PropertyInterceptorMode.BeforeSet,
          TraceSetter);
      PropertyInterceptorManager.CurrentInstance.AddAction(piAction2);

      // Get/set a few properties
      DomainModelEntityManager mgr = DomainModelEntityManager.DefaultManager;
      Employee e = mgr.Employees.First();
      string addy = e.Address;
      e.Country = "UK";
    }
    
    public static void TraceGetter(DataEntityPropertyGetInterceptorArgs&lt;Employee, String&gt;&gt; args) {
      Console.WriteLine("getter called for " + args.DataEntityProperty.Name);
    }

    public static void TraceSetter(DataEntityPropertySetInterceptorArgs&lt;Employee, String&gt;&gt; args) {
      Console.WriteLine("setter called for " + args.DataEntityProperty.Name);
    }
        </code>
      </example>
        </member>
        <member name="M:IdeaBlade.Core.PropertyInterceptorAction`1.#ctor(System.Type,System.String,IdeaBlade.Core.PropertyInterceptorMode,System.Action{`0},System.Double,System.String)">
            <summary>
            Creates an instance of this class.
            </summary>
            <param name="targetType">Type of object on which the interceptor action is invoked</param>
            <param name="targetName">The name of the property on which the interceptor acts.</param>
            <param name="mode">When the action is invoked</param>
            <param name="action">The action to be performed</param>
            <param name="order">The invocation order of the action</param>
            <param name="key">Uniquely identifies the action</param>
            <remarks>
            Use <see cref="M:IdeaBlade.Core.PropertyInterceptor`3.AddAction(IdeaBlade.Core.PropertyInterceptorAction{`2})"/> or
            <see cref="M:IdeaBlade.Core.PropertyInterceptorManager.AddAction(IdeaBlade.Core.PropertyInterceptorAction)"/> to add the action to an interceptor.
            </remarks>
            <example>
        <code lang="C#">
    public void Sample() {

      // Add a BeforeGet action on Employe.Address  
      var piAction = new PropertyInterceptorAction&lt;DataEntityPropertyGetInterceptorArgs&lt;Employee, String&gt;&gt;(
                typeof(Employee),
                Employee.EntityPropertyNames.Address,
                PropertyInterceptorMode.BeforeGet,
                TraceGetter);
      PropertyInterceptorManager.CurrentInstance.AddAction(piAction);

      // Add a BeforeSet action on Employee.Country
      var piAction2 = new PropertyInterceptorAction&lt;DataEntityPropertySetInterceptorArgs&lt;Employee, String&gt;&gt;(
          typeof(Employee),
          Employee.EntityPropertyNames.Country,
          PropertyInterceptorMode.BeforeSet,
          TraceSetter);
      PropertyInterceptorManager.CurrentInstance.AddAction(piAction2);

      // Get/set a few properties
      DomainModelEntityManager mgr = DomainModelEntityManager.DefaultManager;
      Employee e = mgr.Employees.First();
      string addy = e.Address;
      e.Country = "UK";
    }
    
    public static void TraceGetter(DataEntityPropertyGetInterceptorArgs&lt;Employee, String&gt;&gt; args) {
      Console.WriteLine("getter called for " + args.DataEntityProperty.Name);
    }

    public static void TraceSetter(DataEntityPropertySetInterceptorArgs&lt;Employee, String&gt;&gt; args) {
      Console.WriteLine("setter called for " + args.DataEntityProperty.Name);
    }
        </code>
      </example>
        </member>
        <member name="M:IdeaBlade.Core.PropertyInterceptorAction`1.ConvertTo``1">
            <summary>
            Internal use only.
            </summary>
            <typeparam name="TNewArgs"></typeparam>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.PropertyInterceptorAction`1.BuildFunc``2(System.Type)">
            <summary>
            Internal use only.
            </summary>
            <typeparam name="TOldArgs"></typeparam>
            <typeparam name="TNewArgs"></typeparam>
            <param name="realNewArgsType"></param>
            <returns></returns>
        </member>
        <member name="P:IdeaBlade.Core.PropertyInterceptorAction`1.Action">
            <summary>
            The action to be invoked.
            </summary>
        </member>
        <member name="T:IdeaBlade.Core.IPropertyInterceptorArgs">
            <summary>
            Interface implemented by property interceptor argument classes.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.IPropertyInterceptorArgs.Instance">
            <summary>
            The object on which the interceptor acts.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.IPropertyInterceptorArgs.Value">
            <summary>
            The value of the property being retrieved or set.
            </summary>
            <remarks>
            You may modify this value in any <see cref="T:IdeaBlade.Core.PropertyInterceptorAction"/>.  The modified
            value is passed to other actions in the getter or setter.  Note that in a set,
            modifying the <b>Value</b> in an AfterSet does not affect the backing store value.
            </remarks>
            <!-- No matching elements were found for the following include tag --><include file="PropertyInterceptorArgs.Examples.xml" path="//Class[@name=&quot;PropertyInterceptorArgs&quot;]/method[@name=&quot;Value&quot;]/*"/>
        </member>
        <member name="P:IdeaBlade.Core.IPropertyInterceptorArgs.Cancel">
            <summary>
            Whether or not to cancel any further actions for the <see cref="T:IdeaBlade.Core.PropertyInterceptor"/>.
            </summary>
            <remarks>
            You can cancel both get and set actions.
            If you set <b>Cancel</b> to true in a <see cref="T:IdeaBlade.Core.PropertyInterceptorAction"/> no further
            actions will be invoked for that get or set call.  In a get, the current <see cref="P:IdeaBlade.Core.IPropertyInterceptorArgs.Value"/> 
            will be returned from the property getter. In a set, a cancel in a BeforeSet action
            will cause the backing store not to be updated with the new value, while a cancel in
            an AfterSet action stops subsequent AfterSet actions from being invoked.
            </remarks>
            <!-- No matching elements were found for the following include tag --><include file="PropertyInterceptorArgs.Examples.xml" path="//Class[@name=&quot;PropertyInterceptorArgs&quot;]/method[@name=&quot;Cancel&quot;]/*"/>
        </member>
        <member name="P:IdeaBlade.Core.IPropertyInterceptorArgs.Tag">
            <summary>
            Gets or sets a user-defined value.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.IPropertyInterceptorArgs.ExceptionAction">
            <summary>
            The handler to be invoked when an exception is thrown during a get or set.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.IPropertyInterceptorArgs.Context">
            <summary>
            Used internally to indicate the Entity version.
            </summary>
        </member>
        <member name="T:IdeaBlade.Core.IPropertyInterceptorArgs`2">
            <summary>
            Generic interface for property interceptor arguments.
            </summary>
            <typeparam name="TInstance"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="P:IdeaBlade.Core.IPropertyInterceptorArgs`2.Instance">
            <summary>
            The object on which the interceptor acts.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.IPropertyInterceptorArgs`2.Value">
            <summary>
            The value of the property being retrieved or set.
            </summary>
        </member>
        <member name="T:IdeaBlade.Core.PropertyInterceptorArgs">
            <summary>
            Base interface for arguments to a <see cref="T:IdeaBlade.Core.PropertyInterceptorAction"/>.
            <seealso cref="T:IdeaBlade.Core.PropertyInterceptorArgs`2"/>
            <seealso cref="T:IdeaBlade.Core.PropertyInterceptorAction"/>
            <seealso cref="T:IdeaBlade.Core.PropertyInterceptor"/>
            </summary>
            <remarks>
            </remarks>
        </member>
        <member name="P:IdeaBlade.Core.PropertyInterceptorArgs.Instance">
            <summary>
             The object on which the interceptor acts.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.PropertyInterceptorArgs.Value">
            <summary>
            The value of the property being retrieved or set.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.PropertyInterceptorArgs.Cancel">
            <summary>
            Whether or not to cancel any further actions for the <see cref="T:IdeaBlade.Core.PropertyInterceptor"/>.
            </summary>
            <remarks>
            You can cancel both get and set actions.
            If you set <b>Cancel</b> to true in a <see cref="T:IdeaBlade.Core.PropertyInterceptorAction"/> no further
            actions will be invoked for that get or set call.  In a get, the current <see cref="P:IdeaBlade.Core.PropertyInterceptorArgs.Value"/> 
            will be returned from the property getter. In a set, a cancel in a BeforeSet action
            will cause the backing store not to be updated with the new value, while a cancel in
            an AfterSet action stops subsequent AfterSet actions from being invoked.
            </remarks>
            <!-- No matching elements were found for the following include tag --><include file="PropertyInterceptorArgs.Examples.xml" path="//Class[@name=&quot;PropertyInterceptorArgs&quot;]/method[@name=&quot;Cancel&quot;]/*"/>
        </member>
        <member name="P:IdeaBlade.Core.PropertyInterceptorArgs.Tag">
            <summary>
            Gets or sets a user-defined value.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.PropertyInterceptorArgs.ExceptionAction">
            <summary>
            The handler to be invoked when an exception is thrown during a get or set.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.PropertyInterceptorArgs.Context">
            <summary>
            Used internally to indicate the Entity version.
            </summary>
        </member>
        <member name="T:IdeaBlade.Core.PropertyInterceptorArgs`2">
            <summary>
            Strongly-typed arguments to a <see cref="T:IdeaBlade.Core.PropertyInterceptorAction"/>.
            <seealso cref="T:IdeaBlade.Core.PropertyInterceptorArgs"/>
            </summary>
            <typeparam name="TInstance">Type of declaring object</typeparam>
            <typeparam name="TValue">Type of property value</typeparam>
        </member>
        <member name="M:IdeaBlade.Core.PropertyInterceptorArgs`2.#ctor(`0,System.Object)">
            <summary>
            Creates a new instance of this class.
            </summary>
            <param name="instance"></param>
            <param name="context"></param>
        </member>
        <member name="M:IdeaBlade.Core.PropertyInterceptorArgs`2.#ctor(IdeaBlade.Core.IPropertyInterceptorArgs)">
            <summary>
            Creates a new instance of this class.
            </summary>
            <param name="args"></param>
        </member>
        <member name="P:IdeaBlade.Core.PropertyInterceptorArgs`2.IdeaBlade#Core#IPropertyInterceptorArgs#Instance">
            <summary>
            The object on which the interceptor acts.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.PropertyInterceptorArgs`2.IdeaBlade#Core#IPropertyInterceptorArgs#Value">
            <summary>
            The value of the property being retrieved or set.
            </summary>
            <remarks>
            You may modify this value in any <see cref="T:IdeaBlade.Core.PropertyInterceptorAction"/>.  The modified
            value is passed to other actions in the getter or setter.  Note that in a set,
            modifying the <b>Value</b> in an AfterSet does not affect the backing store value.
            </remarks>
            <!-- No matching elements were found for the following include tag --><include file="PropertyInterceptorArgs.Examples.xml" path="//Class[@name=&quot;PropertyInterceptorArgs&quot;]/method[@name=&quot;Value&quot;]/*"/>
        </member>
        <member name="P:IdeaBlade.Core.PropertyInterceptorArgs`2.Instance">
            <summary>
            The strongly-typed object on which the interceptor acts.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.PropertyInterceptorArgs`2.Value">
            <summary>
            The strongly-typed value of the property being retrieved or set.
            </summary>
            <remarks>
            You may modify this value in any <see cref="T:IdeaBlade.Core.PropertyInterceptorAction"/>.  The modified
            value is passed to other actions in the getter or setter.  Note that in a set,
            modifying the <b>Value</b> in an AfterSet does not affect the backing store value.
            </remarks>
            <!-- No matching elements were found for the following include tag --><include file="PropertyInterceptorArgs.Examples.xml" path="//Class[@name=&quot;PropertyInterceptorArgs&quot;]/method[@name=&quot;Value&quot;]/*"/>
        </member>
        <member name="P:IdeaBlade.Core.PropertyInterceptorArgs`2.Cancel">
            <summary>
            Whether or not to cancel any further actions for the <see cref="T:IdeaBlade.Core.PropertyInterceptor"/>.
            </summary>
            <remarks>
            You can cancel both get and set actions.
            If you set <b>Cancel</b> to true in a <see cref="T:IdeaBlade.Core.PropertyInterceptorAction"/> no further
            actions will be invoked for that get or set call.  In a get, the current <see cref="P:IdeaBlade.Core.PropertyInterceptorArgs`2.Value"/> 
            will be returned from the property getter. In a set, a cancel in a BeforeSet action
            will cause the backing store not to be updated with the new value, while a cancel in
            an AfterSet action stops subsequent AfterSet actions from being invoked.
            </remarks>
            <!-- No matching elements were found for the following include tag --><include file="PropertyInterceptorArgs.Examples.xml" path="//Class[@name=&quot;PropertyInterceptorArgs&quot;]/method[@name=&quot;Cancel&quot;]/*"/>
        </member>
        <member name="P:IdeaBlade.Core.PropertyInterceptorArgs`2.ExceptionAction">
            <summary>
            The action to perform when an exception is thrown within the property interceptor.
            </summary>
            <remarks>
            You can use this to set a common handler for exceptions on a property or type basis, or 
            even for all properties on all entities.  Make sure that the <see cref="T:IdeaBlade.Core.PropertyInterceptorAction"/> 
            which sets the <b>ExceptionAction</b> is executed early within the getter or setter by 
            setting the <see cref="P:IdeaBlade.Core.PropertyInterceptorAction.Order"/> to a low value.
            </remarks>
            <!-- No matching elements were found for the following include tag --><include file="PropertyInterceptorArgs.Examples.xml" path="//Class[@name=&quot;PropertyInterceptorArgs&quot;]/method[@name=&quot;ExceptionAction&quot;]/*"/>
        </member>
        <member name="P:IdeaBlade.Core.PropertyInterceptorArgs`2.Tag">
            <summary>
            Gets or sets a user-defined value.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.PropertyInterceptorArgs`2.Context">
            <summary>
            Used internally to represent the Entity version.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.PropertyInterceptorArgs`2.OriginalInterceptorArgs">
            <summary>
            Internal use only.
            </summary>
        </member>
        <member name="T:IdeaBlade.Core.PropertyInterceptorAttribute">
            <summary>
            Base class for all DevForce property interceptor attributes.
            <seealso cref="T:IdeaBlade.Core.BeforeGetAttribute"/>
            <seealso cref="T:IdeaBlade.Core.AfterGetAttribute"/>
            <seealso cref="T:IdeaBlade.Core.BeforeSetAttribute"/>
            <seealso cref="T:IdeaBlade.Core.AfterSetAttribute"/>
            </summary>
            <remarks>
            <see cref="T:IdeaBlade.Core.PropertyInterceptor">PropertyInterceptors</see> are used
            within DevForce to add custom actions to getters and setters.  Use
            the <see cref="T:IdeaBlade.Core.BeforeGetAttribute"/> and <see cref="T:IdeaBlade.Core.AfterGetAttribute"/>
            to inject one or more actions into a property getter, and 
            <see cref="T:IdeaBlade.Core.BeforeSetAttribute"/> and <see cref="T:IdeaBlade.Core.AfterSetAttribute"/>
            to inject one or more actions into a property setter.
            </remarks>
        </member>
        <member name="M:IdeaBlade.Core.PropertyInterceptorAttribute.#ctor(IdeaBlade.Core.PropertyInterceptorMode)">
            <summary>
            Create an instance of this type.
            </summary>
            <param name="mode"></param>
        </member>
        <member name="M:IdeaBlade.Core.PropertyInterceptorAttribute.#ctor(System.String,IdeaBlade.Core.PropertyInterceptorMode)">
            <summary>
            Create an instance of this type.
            </summary>
            <param name="targetName"></param>
            <param name="mode"></param>
        </member>
        <member name="P:IdeaBlade.Core.PropertyInterceptorAttribute.TargetType">
            <summary>
            The Type of the object for which the property interceptor is defined.
            </summary>
            <remarks>
            Applies to the Type and its sub-types.
            </remarks>
            <example>
        <code lang="C#">
          
    public class EmployeeInterceptorExtensions {

      // A sample BeforeSet attribute defined on a static method which is not
      // in the TargetType class.  Here, both TargetName and TargetType
      // are specified.  
      
      [BeforeSet( Employee.EntityPropertyNames.Country, TargetType=typeof(Employee))]
      public static void UpperCaseCountry(IPropertyInterceptorArgs&lt;Employee, String&gt; args) {
        string country = args.Value;
        if (!String.IsNullOrEmpty(country)) {
          args.Value = country.ToUpper();
        }
      }
    }
    
    // Attributes which are not defined on the TargetType class
    // will not be automatically discovered, so we also need to force the discovery:
    PropertyInterceptorManager.CurrentInstance.DiscoverInterceptorsFromAttributes(typeof(EmployeeInterceptorExtensions));
        </code>
      </example>
        </member>
        <member name="P:IdeaBlade.Core.PropertyInterceptorAttribute.TargetName">
            <summary>
            The name of the property for which the property interceptor is defined.
            </summary>
            <remarks>
            The <b>TargetName</b> for untargeted interceptors - those for any property - will be
            null or an empty string.
            </remarks>
        </member>
        <member name="P:IdeaBlade.Core.PropertyInterceptorAttribute.Key">
            <summary>
            The identifying name assigned to the action.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.PropertyInterceptorAttribute.Order">
            <summary>
            The invocation order of the action. 
            </summary>
            <remarks>
            The default <b>Order</b> is 0.0, indicating the order of execution follows
            the usual property interception rules (see the Developer's Guide).  Set the 
            <b>Order</b> to override the default.  Lower values will be executed before
            higher values.  Use the <b>Order</b> to control the execution sequence of a series of actions 
            for a getter or setter.
            </remarks>
            <example>
        <code lang="C#">
    public partial class Employee {
    
      // Sample interceptors with the Order attribute set.
      // Lower values are executed before higher values.
      // Here, BeforeGetLastName2 will be executed before BeforeGetLastName3.
      
      [BeforeGet(EntityPropertyNames.LastName, Order = 3.0)]
      public static void BeforeGetLastName3(IPropertyInterceptorArgs args) {
        var emp = args.Instance as Employee;
        Console.WriteLine("emp:BeforeGetLastName3");
      }

     [BeforeGet(EntityPropertyNames.LastName, Order = 2.0)]
      public static void BeforeGetLastName2(PropertyInterceptorArgs&lt;Employee, String&gt; args) {
        var emp = args.Instance as Employee;
        Console.WriteLine("emp:BeforeGetLastName2");
      }
    }
        </code>
      </example>
        </member>
        <member name="P:IdeaBlade.Core.PropertyInterceptorAttribute.Mode">
            <summary>
            When the action will be invoked.
            </summary>
        </member>
        <member name="T:IdeaBlade.Core.BeforeGetAttribute">
            <summary>
            Marks an action to be performed in a property getter before the value is retrieved
            from the backing store.
            <seealso cref="T:IdeaBlade.Core.PropertyInterceptorArgs"/>
            <seealso cref="T:IdeaBlade.Core.PropertyInterceptorAction"/>
            </summary>
            <remarks>
            Use <b>BeforeGet</b> to specify one or more actions to be performed when a property
            getter is invoked.  These actions occur before the backing value is retrieved.
            Actions may be defined as instance or static methods on a base or derived type.
            The execution order may be specified by using the <see cref="P:IdeaBlade.Core.PropertyInterceptorAttribute.Order">Order</see>
            named parameter.  See the Developer's Guide for more information on action chaining and ordering.
            <b>BeforeGet</b> interceptor actions are automatically discovered the first time a property getter
            is called.
            <para>
            There are a number of acceptable signatures for methods marked with this attribute. In general,
            you can accept (or accept and return) an object of the expected property type, or accept
            one of the many derivations of <see cref="T:IdeaBlade.Core.PropertyInterceptorArgs"/>.  See the
            examples provided with the constructors for more information.  If a signature is invalid,
            you will receive a <see cref="T:IdeaBlade.Core.PropertyInterceptorException"/> when DevForce either builds
            or tries to execute the method, depending on when the error is detected.    
            </para>
            </remarks>
            <example>
        <code lang="C#">
  public partial class Customer {

    // Sample signatures for a BeforeGet method for any Customer property
    // (invoked for both simple and navigation properties).
    // Additional signatures are possible.

    // Signature 1 - accept a property value and return a property value.
    // The input value may be null if no prior BeforeGet interceptors 
    // have returned a value.
    // Any value returned is passed to next interceptor.
    [BeforeGet]
    public object BeforeGetAnyCustomerProperty1(object value) {
      Console.WriteLine("Getting a customer property 1");
      return value;
    }

    // Signature 2 - accept a property value, but no return value.
    [BeforeGet]
    public void BeforeGetAnyCustomerProperty2(object value) {
      Console.WriteLine("Getting a customer property 2");
    }

    // Signature 3 - accept base IPropertyInterceptorArgs.
    // Allows you to cancel further actions and modify the Value.
    // No property information available.
    [BeforeGet]
    public void BeforeGetAnyCustomerProperty3(IPropertyInterceptorArgs args) {
      Console.WriteLine("Getting a customer property 3");
    }

    // Signature 4 - accept EntityProperty interceptor arguments.
    // The arguments passed allow you to determine the property retrieved
    // and to cancel the get if necessary.  The args.Value may be null
    // if no prior BeforeGet interceptor has set the value.  args.Value
    // can also be set before returning.
    [BeforeGet]
    public void BeforeGetAnyCustomerProperty4(IEntityPropertyGetInterceptorArgs args) {
      Console.WriteLine("Getting customer property " + args.EntityProperty.Name);
    }

    // Signature 5 - accept strongly-typed IPropertyInterceptorArgs.
    // Same features as IPropertyInterceptorArgs but Instance is now strongly-typed.
    [BeforeGet]
    public void BeforeGetAnyCustomerProperty5(IPropertyInterceptorArgs&lt;Customer, object&gt; args) {
      Customer c = args.Instance;
      Console.WriteLine("Getting customer property 5");
    }
  }
        </code>
      </example>
        </member>
        <member name="M:IdeaBlade.Core.BeforeGetAttribute.#ctor">
            <summary>
            Marks an action to be performed for any property in the declaring type
            or its subclasses when the getter is invoked.
            </summary>
            <remarks>
            Actions with this attribute apply to all properties in the type and sub-types.
            </remarks>
        </member>
        <member name="M:IdeaBlade.Core.BeforeGetAttribute.#ctor(System.String)">
            <summary>
            Marks an action to be performed when the getter for the property of the specified name
            is invoked.  
            </summary>
            <param name="targetName">Property or method name</param>
            <remarks>
            </remarks>
        </member>
        <member name="T:IdeaBlade.Core.AfterGetAttribute">
            <summary>
            Marks an action to be performed in a property getter after the value is retrieved
            from the backing store.
            <seealso cref="T:IdeaBlade.Core.PropertyInterceptorArgs"/>
            <seealso cref="T:IdeaBlade.Core.PropertyInterceptorAction"/>
            </summary>
            <remarks>
            Use <b>AfterGet</b> to specify one or more actions to be performed when a property
            getter is invoked.  These actions occur after the backing value is retrieved.
            Actions may be defined as instance or static methods on a base or derived type.
            The execution order may be specified by using the <see cref="P:IdeaBlade.Core.PropertyInterceptorAttribute.Order">Order</see>
            named parameter.  See the Developer's Guide for more information on action chaining and ordering.
            <b>AfterGet</b> interceptor actions are automatically discovered the first time a property getter
            is called.
            <para>
            There are a number of acceptable signatures for methods marked with this attribute. In general,
            you can accept (or accept and return) an object of the expected property type, or accept
            one of the many derivations of <see cref="T:IdeaBlade.Core.PropertyInterceptorArgs"/>.  See the
            examples provided with the constructors for more information.  If a signature is invalid,
            you will receive a <see cref="T:IdeaBlade.Core.PropertyInterceptorException"/> when DevForce either builds
            or tries to execute the method, depending on when detected.    
            </para>
            </remarks>
            <example>
        <code lang="C#">
  public partial class Customer {

    // Sample signatures for a AfterGet method for any Customer property
    // (both simple and navigation properties).
    // Additional signatures are possible.

    // Signature 1 - accept a property value and return a property value.
    // Any value returned is passed to the next interceptor.
    [AfterGet]
    public object AfterGetAnyCustomerProperty1(object value) {
      Console.WriteLine("AfterGet on a customer property 1");
      return value;
    }

    // Signature 2 - accept a property value, but no return value.
    [AfterGet]
    public void AfterGetAnyCustomerProperty2(object value) {
      Console.WriteLine("AfterGet on a customer property 2");
    }

    // Signature 3 - accept base IPropertyInterceptorArgs.
    // Allows you to cancel further actions and modify the Value.
    // No property information available.
    [AfterGet]
    public void AfterGetAnyCustomerProperty3(IPropertyInterceptorArgs args) {
      Console.WriteLine("AfterGet on a customer property 3");
    }

    // Signature 4 - accept EntityProperty interceptor arguments.
    // The arguments passed allow you to determine the property retrieved
    // and to to cancel further actions and modify the Value.
    [AfterGet]
    public void AfterGetAnyCustomerProperty4(IEntityPropertyGetInterceptorArgs args) {
      Console.WriteLine("Got customer property " + args.EntityProperty.Name);
    }

    // Signature 5 - accept strongly-typed IPropertyInterceptorArgs.
    // Same features as IPropertyInterceptorArgs but Instance is now strongly-typed.
    [AfterGet]
    public void AfterGetAnyCustomerProperty5(IPropertyInterceptorArgs&lt;Customer, object&gt; args) {
      Customer c = args.Instance;
      Console.WriteLine("AfterGet on a customer property 5");
    }
  }
        </code>
      </example>
        </member>
        <member name="M:IdeaBlade.Core.AfterGetAttribute.#ctor">
            <summary>
            Marks an action to be performed for any property in the declaring type
            or its subclasses when the getter is invoked.
            </summary>
            <remarks>
            Actions with this attribute apply to all properties in the type and sub-types.
            </remarks>
        </member>
        <member name="M:IdeaBlade.Core.AfterGetAttribute.#ctor(System.String)">
            <summary>
            Marks an action to be performed when the getter for the property of the specified name
            is invoked.  
            </summary>
            <param name="targetName">Property or method name</param>
            <remarks>
            </remarks>
        </member>
        <member name="T:IdeaBlade.Core.BeforeSetAttribute">
            <summary>
            Marks an action to be performed in a property setter before the value is written
            to the backing store.
            <seealso cref="T:IdeaBlade.Core.PropertyInterceptorArgs"/>
            <seealso cref="T:IdeaBlade.Core.PropertyInterceptorAction"/>
            </summary>
            <remarks>
            Use <b>BeforeSet</b> to specify one or more actions to be performed when a property
            setter is invoked.  These actions occur before the backing value is stored.
            Actions may be defined as instance or static methods on a base or derived type.
            The execution order may be specified by using the <see cref="P:IdeaBlade.Core.PropertyInterceptorAttribute.Order">Order</see>
            named parameter.  See the Developer's Guide for more information on action chaining and ordering.
            <b>BeforeSet</b> interceptor actions are automatically discovered the first time a property setter
            is called.
            <para>
            There are a number of acceptable signatures for methods marked with this attribute. In general,
            you can accept (or accept and return) an object of the expected property type, or accept
            one of the many derivations of <see cref="T:IdeaBlade.Core.PropertyInterceptorArgs"/>.  See the
            examples provided with the constructors for more information.  If a signature is invalid,
            you will receive a <see cref="T:IdeaBlade.Core.PropertyInterceptorException"/> when DevForce either builds
            or tries to execute the method, depending on when the error is detected.    
            </para>
            </remarks>
            <example>
        <code lang="C#">
  public partial class Customer {

    // Sample signatures for a BeforeSet method for any Customer property
    // (invoked for both simple and navigation properties).
    // Additional signatures are possible.

    // Signature 1 - accept a property value and return a property value.
    // Any value returned is passed to next action.
    [BeforeSet]
    public object BeforeSetAnyCustomerProperty1(object value) {
      Console.WriteLine("Before setting a customer property 1");
      return value;
    }

    // Signature 2 - accept a property value, but no return value.
    [BeforeSet]
    public void BeforeSetAnyCustomerProperty2(object value) {
      Console.WriteLine("Before setting a customer property 2");
    }

    // Signature 3 - accept base IPropertyInterceptorArgs.
    // Allows you to cancel further actions and modify the Value.
    // No property information available.
    [BeforeSet]
    public void BeforeSetAnyCustomerProperty3(IPropertyInterceptorArgs args) {
      Console.WriteLine("Before setting a customer property 3");
    }

    // Signature 4 - accept EntityProperty interceptor arguments.
    // The arguments passed allow you to determine the property retrieved
    // and to cancel the set.  args.Value can be modified.
    // args.VerificationSetterOptions allows verification options to be set for all subsequent
    // actions within the setter.  Note that verification can be turned off also.
    [BeforeSet]
    public void BeforeSetAnyCustomerProperty4(IEntityPropertySetInterceptorArgs args) {
      Console.WriteLine("Before setting a customer property 4");
    }

    // Signature 5 - accept strongly-typed IPropertyInterceptorArgs.
    // Same features as IPropertyInterceptorArgs but Instance is now strongly-typed.
    [BeforeSet]
    public void BeforeSetAnyCustomerProperty5(IPropertyInterceptorArgs&lt;Customer, object&gt; args) {
      Console.WriteLine("Before setting a customer property 5");
    }
  }
        </code>
      </example>
        </member>
        <member name="M:IdeaBlade.Core.BeforeSetAttribute.#ctor">
            <summary>
            Marks an action to be performed for any property in the declaring type
            or its subclasses when the setter is invoked.
            </summary>
            <remarks>
            Actions with this attribute apply to all properties in the type and sub-types.
            </remarks>
        </member>
        <member name="M:IdeaBlade.Core.BeforeSetAttribute.#ctor(System.String)">
            <summary>
            Marks an action to be performed when the setter for the property of the specified name
            is invoked.  
            </summary>
            <param name="targetName">Property or method name</param>
            <remarks>
            </remarks>
        </member>
        <member name="T:IdeaBlade.Core.AfterSetAttribute">
            <summary>
            Marks an action to be performed in a property setter after the value is written
            to the backing store.
            <seealso cref="T:IdeaBlade.Core.PropertyInterceptorArgs"/>
            <seealso cref="T:IdeaBlade.Core.PropertyInterceptorAction"/>
            </summary>
            <remarks>
            Use <b>AfterSet</b> to specify one or more actions to be performed when a property
            setter is invoked.  These actions occur after the backing value has been written.
            Actions may be defined as instance or static methods on a base or derived type.
            The execution order may be specified by using the <see cref="P:IdeaBlade.Core.PropertyInterceptorAttribute.Order">Order</see>
            named parameter.  See the Developer's Guide for more information on action chaining and ordering.
            <b>AfterSet</b> interceptor actions are automatically discovered the first time a property setter
            is called.
            <para>
            There are a number of acceptable signatures for methods marked with this attribute. In general,
            you can accept (or accept and return) an object of the expected property type, or accept
            one of the many derivations of <see cref="T:IdeaBlade.Core.PropertyInterceptorArgs"/>.  See the
            examples provided with the constructors for more information.  If a signature is invalid,
            you will receive a <see cref="T:IdeaBlade.Core.PropertyInterceptorException"/> when DevForce either builds
            or tries to execute the method, depending on when detected.    
            </para>
            </remarks>
            <example>
        <code lang="C#">
  public partial class Customer {

    // Sample signatures for a AfterSet method for any Customer property
    // (invoked for both simple and navigation properties).
    // Additional signatures are possible.

    // Although you can change args.Value in an AfterSet method, the backing store
    // is not modified, but the modified value will be passed to subsequent AfterSet actions.
    // Setting args.Cancel in an AfterSet also does not affect the backing store,
    // but does stop subsequent actions from being executed.

    // Signature 1 - accept a property value and return a property value.
    // Any value returned is passed to next action but does not affect the 
    // backing store.
    [AfterSet]
    public object AfterSetAnyCustomerProperty1(object value) {
      Console.WriteLine("After setting a customer property 1");
      return value;
    }

    // Signature 2 - accept a property value, but no return value.
    [AfterSet]
    public void AfterSetAnyCustomerProperty2(object value) {
      Console.WriteLine("After setting a customer property 2");
    }

    // Signature 3 - accept base IPropertyInterceptorArgs.
    // Allows you to cancel further actions and modify the Value.
    // No property information available.
    [AfterSet]
    public void AfterSetAnyCustomerProperty3(IPropertyInterceptorArgs args) {
      Console.WriteLine("After setting a customer property 3");
    }

    // Signature 4 - accept EntityProperty interceptor arguments.
    // The arguments passed allow you to determine the property retrieved
    // and to cancel further actions. 
    [AfterSet]
    public void AfterSetAnyCustomerProperty4(IEntityPropertySetInterceptorArgs args) {
      Console.WriteLine("After setting a customer property 4");
    }

    // Signature 5 - accept strongly-typed IPropertyInterceptorArgs.
    // Same features as IPropertyInterceptorArgs but Instance is now strongly-typed.
    [AfterSet]
    public void AfterSetAnyCustomerProperty5(IPropertyInterceptorArgs&lt;Customer, object&gt; args) {
      Console.WriteLine("After setting a customer property 5");
    }
  }
        </code>
      </example>
        </member>
        <member name="M:IdeaBlade.Core.AfterSetAttribute.#ctor">
            <summary>
            Marks an action to be performed for any property in the declaring type
            or its subclasses when the setter is invoked.
            </summary>
            <remarks>
            Actions with this attribute apply to all properties in the type and sub-types.
            </remarks>
        </member>
        <member name="M:IdeaBlade.Core.AfterSetAttribute.#ctor(System.String)">
            <summary>
            Marks an action to be performed when the setter for the property of the specified name
            is invoked.  
            </summary>
            <param name="targetName">Property or method name</param>
            <remarks>
            </remarks>
        </member>
        <member name="T:IdeaBlade.Core.PropertyInterceptorException">
            <summary>
            Exception thrown for errors encountered when property interceptors
            are created or discovered.
            <seealso cref="T:IdeaBlade.Core.PropertyInterceptor"/>
            <seealso cref="T:IdeaBlade.Core.PropertyInterceptorAttribute"/>
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.PropertyInterceptorException.#ctor">
            <summary>
            Initializes a new instance of the PropertyInterceptorException class.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.PropertyInterceptorException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the PropertyInterceptorException class. 
            </summary>
            <param name="pMessage"></param>
        </member>
        <member name="M:IdeaBlade.Core.PropertyInterceptorException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the PropertyInterceptorException class. 
            </summary>
            <param name="pMessage"></param>
            <param name="pException"></param>
        </member>
        <member name="M:IdeaBlade.Core.PropertyInterceptorException.#ctor(System.String,System.Object[])">
            <summary>
            Initializes a new instance of the PropertyInterceptorException class. 
            </summary>
            <param name="pMessage"></param>
            <param name="pMessageArgs"></param>
        </member>
        <member name="T:IdeaBlade.Core.PropertyInterceptorManager">
            <summary>
            Manages DevForce property interceptors.
            <seealso cref="T:IdeaBlade.Core.PropertyInterceptor"/>
            <seealso cref="T:IdeaBlade.Core.PropertyInterceptorAttribute"/>
            </summary>
            <remarks>
            Manages a dictionary of all interceptors and their actions.  You can use <see cref="M:IdeaBlade.Core.PropertyInterceptorManager.AddAction(IdeaBlade.Core.PropertyInterceptorAction)"/>
            and <see cref="M:IdeaBlade.Core.PropertyInterceptorManager.RemoveAction(IdeaBlade.Core.PropertyInterceptorAction)"/> to add and remove actions.  Use <see cref="M:IdeaBlade.Core.PropertyInterceptorManager.GetActions``1(System.Type,System.String,IdeaBlade.Core.PropertyInterceptorMode)"/>
            to retrieve a list of all actions in effect for a given type, property name and mode.
            </remarks>
        </member>
        <member name="M:IdeaBlade.Core.PropertyInterceptorManager.DiscoverInterceptorsFromAttributes(System.Type)">
            <summary>
            Force attribute discovery in the specified Type.
            </summary>
            <param name="typeContainingInterceptors"></param>
            <remarks>
            This call is not needed for any type with static EntityProperties.  You must use this method when
            you use <see cref="T:IdeaBlade.Core.PropertyInterceptorAttribute">attributes</see> to mark methods in non-Entity classes,
            since they will not be automatically discovered.
            </remarks>
            <example>
        <code lang="C#">
          
    public class EmployeeInterceptorExtensions {

      // A sample BeforeSet attribute defined on a static method which is not
      // in the TargetType class.  Here, both TargetName and TargetType
      // are specified.  
      
      [BeforeSet( Employee.EntityPropertyNames.Country, TargetType=typeof(Employee))]
      public static void UpperCaseCountry(IPropertyInterceptorArgs&lt;Employee, String&gt; args) {
        string country = args.Value;
        if (!String.IsNullOrEmpty(country)) {
          args.Value = country.ToUpper();
        }
      }
    }
    
    // Attributes which are not defined on the TargetType class
    // will not be automatically discovered, so we also need to force the discovery:
    PropertyInterceptorManager.CurrentInstance.DiscoverInterceptorsFromAttributes(typeof(EmployeeInterceptorExtensions));
        </code>
      </example>
        </member>
        <member name="M:IdeaBlade.Core.PropertyInterceptorManager.AddAction(IdeaBlade.Core.PropertyInterceptorAction)">
            <summary>
            Adds a property interceptor action.
            </summary>
            <param name="interceptorAction"></param>
            <example>
        <code lang="C#">
    public void Sample() {

      // Add a BeforeGet action on Employe.Address  
      var piAction = new PropertyInterceptorAction&lt;DataEntityPropertyGetInterceptorArgs&lt;Employee, String&gt;&gt;(
                typeof(Employee),
                Employee.EntityPropertyNames.Address,
                PropertyInterceptorMode.BeforeGet,
                TraceGetter);
      PropertyInterceptorManager.CurrentInstance.AddAction(piAction);

      // Add a BeforeSet action on Employee.Country
      var piAction2 = new PropertyInterceptorAction&lt;DataEntityPropertySetInterceptorArgs&lt;Employee, String&gt;&gt;(
          typeof(Employee),
          Employee.EntityPropertyNames.Country,
          PropertyInterceptorMode.BeforeSet,
          TraceSetter);
      PropertyInterceptorManager.CurrentInstance.AddAction(piAction2);

      // Get/set a few properties
      DomainModelEntityManager mgr = DomainModelEntityManager.DefaultManager;
      Employee e = mgr.Employees.First();
      string addy = e.Address;
      e.Country = "UK";
    }
    
    public static void TraceGetter(DataEntityPropertyGetInterceptorArgs&lt;Employee, String&gt;&gt; args) {
      Console.WriteLine("getter called for " + args.DataEntityProperty.Name);
    }

    public static void TraceSetter(DataEntityPropertySetInterceptorArgs&lt;Employee, String&gt;&gt; args) {
      Console.WriteLine("setter called for " + args.DataEntityProperty.Name);
    }
        </code>
      </example>
        </member>
        <member name="M:IdeaBlade.Core.PropertyInterceptorManager.RemoveAction(IdeaBlade.Core.PropertyInterceptorAction)">
            <summary>
            Removes an action.
            </summary>
            <param name="interceptorAction"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.PropertyInterceptorManager.GetActions``1(System.Type,System.String,IdeaBlade.Core.PropertyInterceptorMode)">
            <summary>
            Retrieve all actions for the target and mode.
            </summary>
            <param name="targetType"></param>
            <param name="targetName"></param>
            <param name="mode"></param>
            <returns></returns>
            <remarks>
            Skipped keys are not included in the return list.
            </remarks>
        </member>
        <member name="P:IdeaBlade.Core.PropertyInterceptorManager.CurrentInstance">
            <summary>
            Singleton instance of this class.
            </summary>
        </member>
        <member name="T:IdeaBlade.Core.PropertyDirection">
            <summary>
            Indicates whether a <see cref="T:IdeaBlade.Core.PropertyInterceptor"/> is for a getter or setter.
            </summary>
        </member>
        <member name="F:IdeaBlade.Core.PropertyDirection.Get">
            <summary>
            Property getter.
            </summary>
        </member>
        <member name="F:IdeaBlade.Core.PropertyDirection.Set">
            <summary>
            Property setter.
            </summary>
        </member>
        <member name="T:IdeaBlade.Core.PropertyInterceptorTiming">
            <summary>
            The timing of the <see cref="T:IdeaBlade.Core.PropertyInterceptorAction"/>.
            </summary>
        </member>
        <member name="F:IdeaBlade.Core.PropertyInterceptorTiming.Before">
            <summary>
            Before a get or set.
            </summary>
        </member>
        <member name="F:IdeaBlade.Core.PropertyInterceptorTiming.After">
            <summary>
            After a get or set.
            </summary>
        </member>
        <member name="T:IdeaBlade.Core.PropertyInterceptorMode">
            <summary>
            When the <see cref="T:IdeaBlade.Core.PropertyInterceptorAction"/> will be invoked.
            <seealso cref="T:IdeaBlade.Core.PropertyInterceptorAttribute"/>
            </summary>
        </member>
        <member name="F:IdeaBlade.Core.PropertyInterceptorMode.BeforeGet">
            <summary>
            Before the value is retrieved from the backing field.
            </summary>
        </member>
        <member name="F:IdeaBlade.Core.PropertyInterceptorMode.AfterGet">
            <summary>
            After the value is retrieved from the backing field.
            </summary>
        </member>
        <member name="F:IdeaBlade.Core.PropertyInterceptorMode.BeforeSet">
            <summary>
            Before the value is stored to the backing field.
            </summary>
        </member>
        <member name="F:IdeaBlade.Core.PropertyInterceptorMode.AfterSet">
            <summary>
            After the value is stored to the backing field.
            </summary>
        </member>
        <member name="T:IdeaBlade.Core.PropertyInterceptorModeExtensions">
            <summary>
            Provides a set of static methods for working with the <see cref="T:IdeaBlade.Core.PropertyInterceptorMode"/>.
            </summary>
            <remarks>
            These are primarily for internal use only.
            </remarks>
        </member>
        <member name="M:IdeaBlade.Core.PropertyInterceptorModeExtensions.With(IdeaBlade.Core.PropertyDirection,IdeaBlade.Core.PropertyInterceptorTiming)">
            <summary>
            Return a <see cref="T:IdeaBlade.Core.PropertyInterceptorMode"/> from the specified <see cref="T:IdeaBlade.Core.PropertyDirection"/> and <see cref="T:IdeaBlade.Core.PropertyInterceptorTiming"/>.
            </summary>
            <param name="operationMode"></param>
            <param name="timing"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.PropertyInterceptorModeExtensions.IsGetMode(IdeaBlade.Core.PropertyInterceptorMode)">
            <summary>
            Whether the property direction is for a get.
            </summary>
            <param name="mode"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.PropertyInterceptorModeExtensions.IsSetMode(IdeaBlade.Core.PropertyInterceptorMode)">
            <summary>
            Whether the property direction is for a set.
            </summary>
            <param name="mode"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.PropertyInterceptorModeExtensions.IsBeforeMode(IdeaBlade.Core.PropertyInterceptorMode)">
            <summary>
            Whether the timing is before a get or set.
            </summary>
            <param name="mode"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.PropertyInterceptorModeExtensions.IsAfterMode(IdeaBlade.Core.PropertyInterceptorMode)">
            <summary>
            Whether the timing is after a get or set.
            </summary>
            <param name="mode"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.PropertyInterceptorModeExtensions.GetPropertyDirection(IdeaBlade.Core.PropertyInterceptorMode)">
            <summary>
            Returns the <see cref="T:IdeaBlade.Core.PropertyDirection"/>.
            </summary>
            <param name="mode"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.PropertyInterceptorModeExtensions.GetLocationMode(IdeaBlade.Core.PropertyInterceptorMode)">
            <summary>
            Returns the <see cref="T:IdeaBlade.Core.PropertyInterceptorTiming"/>.
            </summary>
            <param name="mode"></param>
            <returns></returns>
        </member>
        <member name="T:IdeaBlade.Core.PropertyPath">
            <summary>
            Utility class for converting strongly typed property paths into strings for use in databinding.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.PropertyPath.For``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
            <summary>
            Converts an expression into a textual representation that can be used for databinding.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="expr"></param>
            <returns></returns>
            <remarks>
            Example:
            var r = PropertyPath.For&lt;Type&gt;(t => t.Assembly.CodeBase.Length);
            will return "Assembly.CodeBase.Length".
            </remarks>
        </member>
        <member name="M:IdeaBlade.Core.PropertyPath.ForAlt``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
            <summary>
            TODO: alternate approach; simpler but may be slower test this approach for performance 
            </summary>
            <typeparam name="T"></typeparam>
            <param name="expr"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.StableSortFns.Sort``1(System.Collections.Generic.IList{``0},System.ComponentModel.ListSortDirection,System.Comparison{``0})">
            <summary>
            Implements an InsertionSort - not the fastest but Ok for small sets 
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="direction"></param>
            <param name="comparison"></param>
        </member>
        <member name="T:IdeaBlade.Core.StreamFns">
            <summary>
            A static class of utility functions related to stream handling.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.StreamFns.ToStream(System.String)">
            <summary>
            Returns a memory stream from a string.
            </summary>
            <param name="pString"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.StreamFns.ToStream(System.Byte[])">
            <summary>
            Returns a memory stream from a byte array.
            </summary>
            <param name="pBytes"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.StreamFns.ToString(System.IO.Stream)">
            <summary>
            Returns a string from a stream.
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="T:IdeaBlade.Core.StringFns">
            <summary>
            A static class providing utility functions related to string handling.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.StringFns.ProperCase(System.String)">
            <summary>
            Capitalizes the first letter of the incoming string.
            </summary>
            <param name="pName"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.StringFns.CamelCase(System.String)">
            <summary>
            Converts multiple words in the incoming string into a 
            single word with the first letter of each of the multiple 
            words capitalized so that each word that makes up the name 
            can easily be read, e.g. "first name" becomes "FirstName".
            </summary>
            <param name="pName"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.StringFns.PropertyNameToDisplayName(System.String)">
            <summary>
            Converts the incoming string into <see cref="M:IdeaBlade.Core.StringFns.CamelCase(System.String)"/> and
            separates it into multiple words, e.g. "firstName" becomes "First Name".
            </summary>
            <param name="pPropertyName"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.StringFns.ByteArrayToString(System.Byte[])">
            <summary>
            Converts the byte array to its equivalent hex string representation.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.StringFns.StringToByteArray(System.String)">
            <summary>
            Converts a hex string to its byte array representation.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.StringFns.ByteArrayToHexString(System.Byte[])">
            <summary>
            Returns the hex string representation of a byte array.
            </summary>
            <param name="bytes"></param>
            <returns></returns>
        </member>
        <member name="T:IdeaBlade.Core.TopoSort">
            <summary>
            Static class for Topological Sort of Vertices based on their Edges
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.TopoSort.Sort``1(System.Collections.Generic.ICollection{IdeaBlade.Core.IEdge{``0}},System.Boolean@)">
            <summary>
            Topological Sort of Vertices based on their edges in a Digraph
            </summary>
            <remarks>
            Wrote to support calculation of PersistenceOrder where
            EntityRelations are the edges and their parent and class entities are the vertices
            
            Based on algorithm and analysis in PowerPoint slide "Directed Graphs Algorithms: CSE  373, Lecture 14"
            from  http://www.lazyi.net/classdata/CSE373/Lecture%20Slides/lecture14.ppt
            
            Sort is undefined for cyclic graphs but this is modified to keep going so all vertices are returned
            Only considers a list of edges.
            Does not consider nor allow definition of any vertex (Entity Type) not on an edge (in an EntityRelation)
            </remarks>
            <param name="pEdgeList">Edges are directed links (Parent -> Child) such as EntityRelations </param>
            <param name="pIsAcyclic">True if the EdgeList defines an acyclic graph</param>
            <returns>TopoSort of vertices in all edges (all Parents and Children)</returns>
        </member>
        <member name="M:IdeaBlade.Core.TopoSort.Sort``1(System.Collections.Generic.ICollection{IdeaBlade.Core.IEdge{``0}})">
            <summary>
            Topological sort that eats the Acyclic flag
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.TopoSort.EdgesToString``1(System.Collections.Generic.ICollection{IdeaBlade.Core.IEdge{``0}})">
            <summary>
            Return formatted string of StringEdge names
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.TopoSort.BreakNextCycle``1(System.Collections.Generic.Queue{IdeaBlade.Core.TopoSort.Vertex{``0}},System.Collections.Generic.IDictionary{``0,IdeaBlade.Core.TopoSort.Vertex{``0}})">
            <summary>
            Break next cycle by clearing link count of the next vertex w/ least parent links
            </summary>
            <param name="pQueue">Queue of vertices w/ no parent links left</param>
            <param name="pVertices">Dictionary of vertices</param>
        </member>
        <member name="T:IdeaBlade.Core.TopoSort.Vertex`1">
            <summary>
            Vertex of an edge. Private internal class of TopoSort
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.TopoSort.Vertex`1.ParentLinkCount">
            <summary>
            Get or set the ParentLinkCount
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.TopoSort.Vertex`1.Node">
            <summary>
            Get just the vertex's node
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.TopoSort.Vertex`1.Children">
            <summary>
            Get or set the Child vertices (edges)
            </summary>
        </member>
        <member name="T:IdeaBlade.Core.IEdge`1">
            <summary>
            IEdge interface for directed edges in a Digraph 
            </summary>
            <remarks>
            Implementors can be sorted topologically.
            EntityList should implement this
            </remarks>
        </member>
        <member name="P:IdeaBlade.Core.IEdge`1.Child">
            <summary>
            Gets the child.
            </summary>
            <value>The child.</value>
        </member>
        <member name="P:IdeaBlade.Core.IEdge`1.Parent">
            <summary>
            Gets the parent.
            </summary>
            <value>The parent.</value>
        </member>
        <member name="T:IdeaBlade.Core.StringEdge">
            <summary>
            StringEdge is an example IEdge implementor
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.StringEdge.#ctor(System.String)">
            <summary>
            Test edge based on syntax "A.B"
            </summary>
            <param name="pStringEdge">String with single period in it, e.g. "A.B"</param>
        </member>
        <member name="M:IdeaBlade.Core.StringEdge.CreateTestEdgeList(System.String)">
            <summary>
            Return list of test edges based on string edge spec
            </summary>
            <param name="pEdgeListText">StringEdge spec like "A.B, A.C, A.A, B.C"</param>
            <returns>List of edges</returns>
        </member>
        <member name="P:IdeaBlade.Core.StringEdge.Parent">
            <summary>
            Get the Parent
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.StringEdge.Child">
            <summary>
            Get the Child
            </summary>
        </member>
        <member name="T:IdeaBlade.Core.DebugFns">
            <summary>
            A collection of static (Shared in Visual Basic) methods used to provide code assertions, tracing and logging
            functionality for debug builds of DevForce applications.
            <seealso cref="T:IdeaBlade.Core.TraceFns"/>
            </summary>
            <remarks>
            <para>
            Both <b>DebugFns</b> and <see cref="T:IdeaBlade.Core.TraceFns"/> provide
            identical behavior except that calls to methods in this class may be suppressed by
            setting the conditional DEBUG flag to false. In Visual Studio .NET projects, 
            creating a debug build enables DEBUG.  DEBUG is normally off in a release build.
            </para>
            <para>Output is to the <see cref="P:IdeaBlade.Core.IdeaBladeConfig.LoggingInfo.LogFile"/>
            specified in the the IdeaBlade configuration file, and can also be viewed using the 
            <b>Trace Viewer</b> utility, or any class implementing <see cref="T:IdeaBlade.Core.ITraceSubscriberCallback"/>.
            </para>
            <para>TraceFns filters can be set using the
            <see cref="P:IdeaBlade.Core.IdeaBladeConfig.LoggingInfo.RejectFilters"/> and 
            <see cref="P:IdeaBlade.Core.IdeaBladeConfig.LoggingInfo.AcceptFilters"/> nodes in the IdeaBlade configuration
            file to enable and disable logging from specific namespaces.
            </para>
            </remarks>
        </member>
        <member name="T:IdeaBlade.Core.TraceFns">
            <summary>
            A collection of static methods used to provide code assertions, tracing and logging
            functionality for release builds of DevForce applications.
            <seealso cref="T:IdeaBlade.Core.DebugFns"/>
            </summary>
            <remarks>
            <para>Both <b>TraceFns</b> and <see cref="T:IdeaBlade.Core.DebugFns"/> provide
            identical behavior except that calls to methods in this class are intended to always execute.
            In Visual Studio .NET projects, the conditional TRACE flag is enabled by default 
            for both release and debug builds.
            </para>
            <para>Messages are written to the <see cref="T:IdeaBlade.Core.ITraceLogger"/> implementation found; if a custom ILogger is
            not provided then output is to the <see cref="P:IdeaBlade.Core.IdeaBladeConfig.LoggingInfo.LogFile"/>
            specified in the IdeaBlade configuration, and can also be viewed using the 
            <b>Trace Viewer</b> utility.
            </para>
            <para>Tracing "Filters" can be set using the
            <see cref="P:IdeaBlade.Core.IdeaBladeConfig.LoggingInfo.RejectFilters"/> and 
            <see cref="P:IdeaBlade.Core.IdeaBladeConfig.LoggingInfo.AcceptFilters"/> nodes in the IdeaBlade configuration
            file to enable and disable logging from specific namespaces.
            </para>
            </remarks>
        </member>
        <member name="M:IdeaBlade.Core.TraceFns.Assert(System.Boolean)">
            <summary>
            Asserts that the specified condition is true; raises an exception if it is not.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.TraceFns.Assert(System.Boolean,System.String)">
            <summary>
            Asserts that the specified condition is true; raises an exception if it is not.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.TraceFns.Fail(System.String)">
            <summary>
            Force an exception.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.TraceFns.WriteLine(System.Object)">
            <summary>
            Write a string representation of an object to the log.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.TraceFns.WriteLineIf(System.Boolean,System.Object)">
            <summary>
            Write a string representation of an object to the log if the specified condition is true.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.TraceFns.#ctor">
            <summary>
            Initializes a new instance of the TraceFns class
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.TraceFns.StackAssert(System.Boolean,System.String)">
            <summary>
            Writes the message if the condition is false.
            </summary>
            <param name="pCondition"></param>
            <param name="pMessage"></param>
        </member>
        <member name="M:IdeaBlade.Core.TraceFns.StackFail(System.String)">
            <summary>
            Writes the message and throws an <see cref="T:IdeaBlade.Core.AssertionException"/>.
            </summary>
            <param name="pMessage"></param>
        </member>
        <member name="M:IdeaBlade.Core.TraceFns.StackWriteLineIf(System.Boolean,System.String)">
            <summary>
            Writes the message if the condition is true.
            </summary>
            <param name="pCondition"></param>
            <param name="pMessage"></param>
        </member>
        <member name="M:IdeaBlade.Core.TraceFns.StackWriteLine(System.Diagnostics.StackFrame,System.String)">
            <summary>
            Writes the message.
            </summary>
            <param name="pStackFrame"></param>
            <param name="pMessage"></param>
        </member>
        <member name="M:IdeaBlade.Core.TraceFns.GetNamespace(System.Diagnostics.StackFrame)">
            <summary>
            
            </summary>
            <param name="pStackFrame"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.TraceFns.PassesFilter(System.String)">
            <summary>
            Returns true if the specified namespace passes the <see cref="T:IdeaBlade.Core.NamespaceFilter"/>s.
            </summary>
            <param name="pNamespace"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.DebugFns.Assert(System.Boolean)">
            <summary>
            See <see cref="M:IdeaBlade.Core.TraceFns.Assert(System.Boolean)"/>
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.DebugFns.Assert(System.Boolean,System.String)">
            <summary>
            See <see cref="M:IdeaBlade.Core.TraceFns.Assert(System.Boolean)"/>
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.DebugFns.Fail(System.String)">
            <summary>
            See <see cref="M:IdeaBlade.Core.TraceFns.Fail(System.String)"/>
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.DebugFns.WriteLine(System.Object)">
            <summary>
            See <see cref="M:IdeaBlade.Core.TraceFns.WriteLine(System.Object)"/>
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.DebugFns.WriteLineIf(System.Boolean,System.Object)">
            <summary>
            See <see cref="M:IdeaBlade.Core.TraceFns.WriteLineIf(System.Boolean,System.Object)"/>
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.DebugFns.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="T:IdeaBlade.Core.DefaultLoggerProvider">
            <summary>
            Returns the default DevForce <see cref="T:IdeaBlade.Core.ITraceLogger"/> implementation.
            </summary>
            <remarks>
            The default <see cref="T:IdeaBlade.Core.ITraceLogger"/> in DevForce is the <see cref="!:TraceFileXmlLogger"/>.
            </remarks>
        </member>
        <member name="T:IdeaBlade.Core.ITraceLoggerProvider">
            <summary>
            Implement the <b>ILoggerProvider</b> to provide custom logging in your application.
            </summary>
            <remarks>
            You may include multiple <b>ITraceLoggerProvider</b> implementations in your application.
            </remarks>
            <example>
      <code lang="C#">
        <![CDATA[
using System;
using IdeaBlade.Core;

namespace Samples {

  public class SampleLoggerProvider : ITraceLoggerProvider {

    public ITraceLogger GetLogger() {
      return new SampleConsoleLogger();
    }
  }

  // Sample logger - note that DevForce supplies a class named ConsoleLogger - this is shown here
  // as a sample only.
  public class SampleConsoleLogger : ITraceLogger {

    /// <summary>
    /// Return true if your logger is not thread-safe.
    /// </summary>
    public bool IsSingleThreaded {
      get { return false; }
    }

    /// <summary>
    /// Log the trace message - here were write to the Console.
    /// </summary>
    /// <param name="message"></param>
    public void Log(object message) {
      Console.WriteLine(message);
    }
  }
}
        
        

      ]]></code>
    </example>
        </member>
        <member name="M:IdeaBlade.Core.ITraceLoggerProvider.GetLogger">
            <summary>
            Return the <see cref="T:IdeaBlade.Core.ITraceLogger"/> to use for logging of debug and trace messages.
            </summary>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.DefaultLoggerProvider.GetLogger">
            <summary>
            Returns the <see cref="T:IdeaBlade.Core.NullLogger"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="T:IdeaBlade.Core.ITraceLogger">
            <summary>
            Interface describing simple logging capabilities.
            </summary>
            <remarks>
            DevForce will call methods in this interface to write the output from
            <see cref="T:IdeaBlade.Core.DebugFns"/> and <see cref="T:IdeaBlade.Core.TraceFns"/> calls.
            </remarks>
            <example>
      <code lang="C#">
        <![CDATA[
using System;
using IdeaBlade.Core;

namespace Samples {

  public class SampleLoggerProvider : ITraceLoggerProvider {

    public ITraceLogger GetLogger() {
      return new SampleConsoleLogger();
    }
  }

  // Sample logger - note that DevForce supplies a class named ConsoleLogger - this is shown here
  // as a sample only.
  public class SampleConsoleLogger : ITraceLogger {

    /// <summary>
    /// Return true if your logger is not thread-safe.
    /// </summary>
    public bool IsSingleThreaded {
      get { return false; }
    }

    /// <summary>
    /// Log the trace message - here were write to the Console.
    /// </summary>
    /// <param name="message"></param>
    public void Log(object message) {
      Console.WriteLine(message);
    }
  }
}
        
        

      ]]></code>
    </example>
        </member>
        <member name="M:IdeaBlade.Core.ITraceLogger.Log(System.Object)">
            <summary>
            Write a DevForce tracing message.
            </summary>
            <param name="message"></param>
            <remarks>
            Calls originating from DevForce via DebugFns and TraceFns calls will pass a <see cref="T:IdeaBlade.Core.TraceMessage"/>
            to the method.
            </remarks>
        </member>
        <member name="P:IdeaBlade.Core.ITraceLogger.IsSingleThreaded">
            <summary>
            Whether logger can be called from multiple threads.
            </summary>
            <remarks>
            If single-threaded, calls to the Log method will be from a single thread.  If multi-threaded,
            you must ensure that your logger is thread safe.
            </remarks>
        </member>
        <member name="T:IdeaBlade.Core.ITracePublisher">
            <summary>
            Interface to be implemented by any publisher of trace messages.  Internal use only.
            </summary>
            <remarks>
            </remarks>
        </member>
        <member name="M:IdeaBlade.Core.ITracePublisher.Subscribe(System.Guid,IdeaBlade.Core.ITraceSubscriberCallback)">
            <summary>
            Called by <see cref="T:IdeaBlade.Core.ITraceSubscriberCallback"/> implementations in order to receive <see cref="M:IdeaBlade.Core.ITraceSubscriberCallback.OnPublish(IdeaBlade.Core.TraceMessage)"/> notifications.
            </summary>
            <param name="pKey">Id of the subscriber</param>
            <param name="pSubscriber"></param>
        </member>
        <member name="M:IdeaBlade.Core.ITracePublisher.Unsubscribe(System.Guid)">
            <summary>
            Called by <see cref="T:IdeaBlade.Core.ITraceSubscriberCallback"/> implementations when publication notice is no longer wanted.
            </summary>
            <param name="pKey">Id of the subscriber</param>
        </member>
        <member name="T:IdeaBlade.Core.ITraceSubscriberCallback">
            <summary>
            Interface that any subscriber to an <see cref="T:IdeaBlade.Core.ITracePublisher"/> must implement.
            <seealso cref="T:IdeaBlade.Core.TraceSubscriber"/>
            <seealso cref="T:IdeaBlade.Core.TracePublisher"/>
            </summary>
            <remarks>
            </remarks>
        </member>
        <member name="M:IdeaBlade.Core.ITraceSubscriberCallback.OnPublish(IdeaBlade.Core.TraceMessage)">
            <summary>
            Receive messages published by the TracePublisher.
            </summary>
        </member>
        <member name="T:IdeaBlade.Core.BootstrapLogger">
            <summary>
            Used for message logging during startup.
            </summary>
        </member>
        <member name="T:IdeaBlade.Core.NullLogger">
            <summary>
            Logger which writes trace messages using System.Diagnostics.Debug.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.NullLogger.Log(System.Object)">
            <summary>
            Write the trace message.
            </summary>
            <param name="message"></param>
        </member>
        <member name="P:IdeaBlade.Core.NullLogger.IsSingleThreaded">
            <summary>
            This logger is not single-threaded.
            </summary>
        </member>
        <member name="T:IdeaBlade.Core.ConsoleLogger">
            <summary>
            Logger which writes trace messages to the Console.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.ConsoleLogger.Log(System.Object)">
            <summary>
            Write the trace message.
            </summary>
            <param name="message"></param>
        </member>
        <member name="P:IdeaBlade.Core.ConsoleLogger.IsSingleThreaded">
            <summary>
            This logger is not single-threaded.
            </summary>
        </member>
        <member name="T:IdeaBlade.Core.TraceMessage">
            <summary>
            A message to be published by the <see cref="T:IdeaBlade.Core.TracePublisher"/>.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.TraceMessage.#ctor(System.Diagnostics.StackFrame,System.String)">
            <summary>
            
            </summary>
            <param name="pStackFrame"></param>
            <param name="pMessage"></param>
        </member>
        <member name="M:IdeaBlade.Core.TraceMessage.#ctor(System.Diagnostics.StackFrame,System.String,System.Boolean)">
            <summary>
            
            </summary>
            <param name="pStackFrame"></param>
            <param name="pMessage"></param>
            <param name="pGenerateMessageId"></param>
        </member>
        <member name="M:IdeaBlade.Core.TraceMessage.GetFullyQualifiedMethodName(System.Reflection.MemberInfo)">
            <summary>
            
            </summary>
            <param name="pMemberInfo"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.TraceMessage.GetUserName">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.TraceMessage.ToString">
            <summary>
            String representation of the TraceMessage.
            </summary>
            <returns></returns>
        </member>
        <member name="P:IdeaBlade.Core.TraceMessage.Id">
            <summary>
            
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.TraceMessage.Timestamp">
            <summary>
            
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.TraceMessage.UserName">
            <summary>
            
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.TraceMessage.Source">
            <summary>
            
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.TraceMessage.Message">
            <summary>
            
            </summary>
        </member>
        <member name="T:IdeaBlade.Core.TracePublisher">
            <summary>
            Publishes debugging and tracing messages generated by DevForce Silverlight applications.
            </summary>
            <remarks>
            The <b>TracePublisher</b> is used internally within DevForce applications to publish all
            trace and debug messages generated by calls to <see cref="M:IdeaBlade.Core.TraceFns.WriteLine(System.Object)"/> and <see cref="M:IdeaBlade.Core.DebugFns.WriteLine(System.Object)"/>.
            You can create a <see cref="T:IdeaBlade.Core.TraceSubscriber"/> to listen for tracing messages.
            </remarks>
        </member>
        <member name="M:IdeaBlade.Core.TracePublisher.Subscribe(System.Guid,IdeaBlade.Core.ITraceSubscriberCallback)">
            <summary>
            Called by <see cref="T:IdeaBlade.Core.ITraceSubscriberCallback"/> implementations in order to receive <see cref="M:IdeaBlade.Core.ITraceSubscriberCallback.OnPublish(IdeaBlade.Core.TraceMessage)"/> notifications.
            </summary>
            <param name="pKey">Subscriber Id</param>
            <param name="pSubscriber"></param>
            <remarks>
            If subscribing to a remote TracePublisher the <paramref name="pSubscriber"/> parameter should be null since
            a callback channel is used instead.
            </remarks>
        </member>
        <member name="M:IdeaBlade.Core.TracePublisher.Unsubscribe(System.Guid)">
            <summary>
            Called by <see cref="T:IdeaBlade.Core.ITraceSubscriberCallback"/> implementations when publication notice is no longer wanted.
            </summary>
            <param name="pKey">Subscriber Id</param>
        </member>
        <member name="M:IdeaBlade.Core.TracePublisher.Publish(IdeaBlade.Core.TraceMessage)">
            <summary>
            Instructs the TracePublisher to publish a message.
            </summary>
            <param name="pTraceMessage"></param>
            <remarks>The <see cref="M:IdeaBlade.Core.ITraceSubscriberCallback.OnPublish(IdeaBlade.Core.TraceMessage)"/> method will be called
            on all subscribers for every message published.</remarks>
        </member>
        <member name="M:IdeaBlade.Core.TracePublisher.ProcessQueue">
            <summary>
            Runs on a separate thread to publish queued messages.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.TracePublisher.PublishCore(IdeaBlade.Core.TraceMessage)">
            <summary>
            Call OnPublish method for all subscribers.
            </summary>
            <param name="pTraceMessage"></param>
        </member>
        <member name="M:IdeaBlade.Core.TracePublisher.Dispose">
            <summary>
            
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.TracePublisher.Dispose(System.Boolean)">
            <summary>
            All subscribers receive a shutdown notice when the publisher is disposing.
            </summary>
            <param name="pDisposing"></param>
        </member>
        <member name="P:IdeaBlade.Core.TracePublisher.LocalInstance">
            <summary>
            Returns the singleton instance for this class.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.TracePublisher.ThreadKeepAliveMilliseconds">
            <summary>
            Milliseconds the publishing thread sleeps between checks of its queue. Default is 1000 milliseconds (1 second).
            </summary>
        </member>
        <member name="T:IdeaBlade.Core.TraceSubscriber">
            <summary>
            Subscriber to the <see cref="T:IdeaBlade.Core.TracePublisher"/> used by DevForce.
            </summary>
            <remarks>
            For developers implementing a custom TraceSubscriber, you can extend this class 
            or implement the <see cref="T:IdeaBlade.Core.ITraceSubscriberCallback"/> interface.
            </remarks>
        </member>
        <member name="M:IdeaBlade.Core.TraceSubscriber.#ctor">
            <summary>
            Create a new instance of this class.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.TraceSubscriber.Finalize">
            <summary>
            Finalizer.  Stops subscription.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.TraceSubscriber.StartSubscription">
            <summary>
            Start subscription to the local TracePublisher.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.TraceSubscriber.StopSubscription">
            <summary>
            Unsubscribe from the TracePublisher.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.TraceSubscriber.OnPublish(IdeaBlade.Core.TraceMessage)">
            <summary>
            Receive trace messages from the TracePublisher.
            </summary>
            <param name="pTraceMessage"></param>
            <remarks>
            Raises the <see cref="E:IdeaBlade.Core.TraceSubscriber.Publish"/> event.
            </remarks>
        </member>
        <member name="E:IdeaBlade.Core.TraceSubscriber.Publish">
            <summary>
            Event fired when a message is published.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.TraceSubscriber.IsSubscribed">
            <summary>
            Returns whether the subscriber is currently subscribed to a publisher.
            </summary>
        </member>
        <member name="T:IdeaBlade.Core.PublishEventArgs">
            <summary>
            Event arguments for the <b>Publish</b> event fired when handling tracing messages.  Internal use only.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.PublishEventArgs.TraceMessage">
            <summary>
            Gets the published TraceMessage.
            </summary>
        </member>
        <member name="T:IdeaBlade.Core.WrapperFns">
            <summary>
            Internal use only.  
            </summary>  
            Use the appropriate wrapper (data contract) based on the
            serializer in use.
            We have two wrapper data contracts - one for use when types can be serialized,
            the other when types cannot be serialized.  The contracts are orthogonal.
        </member>
        <member name="T:IdeaBlade.Core.ITypeWrapper">
            <summary>
            Internal use only.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.ITypeWrapper.Type">
            <summary>
            Type wrapped.
            </summary>
        </member>
        <member name="T:IdeaBlade.Core.TypeWrapper">
            <summary>
            Wrapper used with the <see cref="T:System.Runtime.Serialization.DataContractSerializer"/> to allow <see cref="T:System.Type"/> data members to be transmitted across tiers.
            </summary>
            <remarks>
            The <b>TypeWrapper</b> is used internally by the framework whenever a serializable data member of System.Type is needed.
            You can use the <b>TypeWrapper</b> in your own code if you also need to send a System.Type member between tiers.  For instance if a
            remote service method should accept a System.Type argument you should instead use a <b>TypeWrapper</b> to ensure the argument can be
            transmitted between tiers.
            <para>
            The <b>TypeWrapper</b> also supplies automatic type "mapping" between Silverlight and .NET.  This allows the assembly-qualified type names
            to differ between the different environments:  for example the type name of an Entity is "IdeaBlade.EntityModel.Entity, IdeaBlade.EntityModel" in .NET, while
            it's "IdeaBlade.EntityModel.Entity, IdeaBlade.EntityModel.SL" in Silverlight.  This mapping applies to standard .NET types too, entities in your models,
            and to other custom types transmitted across tiers.  For the entities in your model, type mapping allows you to place your "Customer" entity, for example, in
            assemblies having different names on client and server, e.g., "MyModel.Customer, DomainModel.SL" vs. "MyModel.Customer, MyWebApp".  If the type cannot be resolved
            an explanatory exception will be thrown.
            </para>
            </remarks>
        </member>
        <member name="M:IdeaBlade.Core.TypeWrapper.GetTypeWrapper(System.Type)">
            <summary>
            Returns a <b>TypeWrapper</b> for the specified <see cref="T:System.Type"/>.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.TypeWrapper.#ctor(System.Type)">
            <summary>
            Create a <b>TypeWrapper</b> from the specified <see cref="T:System.Type"/>.
            </summary>
            <param name="type"></param>
        </member>
        <member name="M:IdeaBlade.Core.TypeWrapper.Equals(System.Object)">
            <summary>
            Provides value equality.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.TypeWrapper.GetHashCode">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:IdeaBlade.Core.TypeWrapper.Type">
            <summary>
            The <see cref="T:System.Type"/> wrapped for serialization.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.TypeWrapper.IsNull">
            <summary>
            If the <see cref="P:IdeaBlade.Core.TypeWrapper.Type"/> value is null.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.TypeWrapper.AssemblyQualifiedName">
            <summary>
            The assembly-qualified type name.
            </summary>
        </member>
        <member name="T:IdeaBlade.Core.UsingBlock">
            <summary>
             For use with a using (Using in Visual Basic) statement to perform pre- and post- actions. 
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.UsingBlock.Create``1(``0,``0,System.Action{``0})">
            <summary>
            Create a <b>UsingBlock</b>.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="origValue"></param>
            <param name="tempValue"></param>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.UsingBlock.#ctor(System.Action,System.Action)">
            <summary>
            Create a new instance with the specified actions.
            </summary>
            <param name="preAction"></param>
            <param name="postAction"></param>
        </member>
        <member name="M:IdeaBlade.Core.UsingBlock.Dispose">
            <summary>
            The postAction is performed at disposal of the UsingBlock instance.
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.UsingBlock.PostAction">
            <summary>
            For internal use only.
            </summary>
        </member>
        <member name="T:IdeaBlade.Core.BooleanUsingBlock">
            <summary>
            A <see cref="T:IdeaBlade.Core.UsingBlock"/> for boolean values.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.BooleanUsingBlock.#ctor(System.Action{System.Boolean})">
            <summary>
            Create an instance with the specified action, defaulting the initial value to True.
            </summary>
            <param name="action"></param>
        </member>
        <member name="M:IdeaBlade.Core.BooleanUsingBlock.#ctor(System.Action{System.Boolean},System.Boolean)">
            <summary>
            Create an instance with the specified action and initial value.
            </summary>
            <param name="action"></param>
            <param name="initialValue"></param>
            <remarks>
            The action is performed with the initial value provided and its inverse.
            </remarks>
        </member>
        <member name="M:IdeaBlade.Core.BooleanUsingBlock.#ctor(System.Action{System.Boolean},System.Boolean,System.Boolean)">
            <summary>
             Create an instance with the specified action, initial value and revert value.
            </summary>
            <param name="action"></param>
            <param name="initialValue"></param>
            <param name="revertValue"></param>
        </member>
        <member name="M:IdeaBlade.Core.BooleanUsingBlock.Dispose">
            <summary>
            Performs the specified action again, with the revert value.
            </summary>
        </member>
        <member name="T:IdeaBlade.Core.UnregisterCallback`1">
            <summary>
            For internal use only.
            </summary>
        </member>
        <member name="T:IdeaBlade.Core.IWeakEventHandler`1">
            <summary>
            For internal use only.
            </summary>
            <typeparam name="E"></typeparam>
        </member>
        <member name="P:IdeaBlade.Core.IWeakEventHandler`1.Handler">
            <summary/>
        </member>
        <member name="T:IdeaBlade.Core.WeakEventHandler`2">
            <summary>
            Event handler to be used in those cases where a publisher should not hold references to its subscribers, 
            as implicitly occurs in the regular event model.
            </summary>
            <remarks>
            In the .NET event model, when subscribing to an event as follows:
            <code>Publisher.Event += new xxxEventHandler(subscriberMethod)</code>     
            the publisher will have a reference to the subscriber. The alternative is to create
            a weak eventHandler using the following syntax.
            
              Example:
            provider.MyEvent += new EventHandler&lt;EventArgs>(MyWeakEventHandler).MakeWeak(eh => provider.MyEvent -= eh);
            
            private void MyWeakEventHandler(object sender, EventArgs e) { ... }
            </remarks>
            <typeparam name="T"></typeparam>
            <typeparam name="E"></typeparam>
        </member>
        <member name="M:IdeaBlade.Core.WeakEventHandler`2.#ctor(System.EventHandler{`1},IdeaBlade.Core.UnregisterCallback{`1})">
            <summary/>
        </member>
        <member name="M:IdeaBlade.Core.WeakEventHandler`2.Invoke(System.Object,`1)">
            <summary/>
        </member>
        <member name="M:IdeaBlade.Core.WeakEventHandler`2.op_Implicit(IdeaBlade.Core.WeakEventHandler{`0,`1})~System.EventHandler{`1}">
            <summary/>
        </member>
        <member name="P:IdeaBlade.Core.WeakEventHandler`2.Handler">
            <summary/>
        </member>
        <member name="T:IdeaBlade.Core.EventHandlerUtils">
            <summary>
            
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.EventHandlerUtils.MakeWeak``1(System.EventHandler{``0},IdeaBlade.Core.UnregisterCallback{``0})">
            <summary/>
        </member>
        <member name="T:IdeaBlade.Core.WeakRefDictionary`2">
            <summary>
            Represents a dictionary which stores the values as weak references instead of strong
            references. Null values are supported.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:IdeaBlade.Core.WeakRefDictionary`2.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:IdeaBlade.Core.WeakRefDictionary`2"/> class.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.WeakRefDictionary`2.Add(`0,`1)">
            <summary>
            Adds a new item to the dictionary.
            </summary>
            <param name="key">The key.</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:IdeaBlade.Core.WeakRefDictionary`2.ContainsKey(`0)">
            <summary>
            Determines if the dictionary contains a value for the key.
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.WeakRefDictionary`2.GetEnumerator">
            <summary>
            Gets an enumerator over the values in the dictionary.
            </summary>
            <returns>The enumerator.</returns>
            <remarks>As objects are discovered and returned from the enumerator, a strong reference
            is temporarily held on the object so that it will continue to exist for the duration of
            the enumeration. Once the enumeration of that object is over, the strong reference is
            removed. If you wish to keep values alive for use after enumeration, to ensure that they
            stay alive, you should store strong references to them during enumeration.</remarks>
        </member>
        <member name="M:IdeaBlade.Core.WeakRefDictionary`2.Remove(`0)">
            <summary>
            Removes an item from the dictionary.
            </summary>
            <param name="key">The key of the item to be removed.</param>
            <returns>Returns true if the key was in the dictionary; return false otherwise.</returns>
        </member>
        <member name="M:IdeaBlade.Core.WeakRefDictionary`2.TryGet(`0,`1@)">
            <summary>
            Attempts to get a value from the dictionary.
            </summary>
            <param name="key">The key</param>
            <param name="value">The value</param>
            <returns>Returns true if the value was present; false otherwise.</returns>
        </member>
        <member name="M:IdeaBlade.Core.WeakRefDictionary`2.CleanIfNeeded">
            <summary>
            Perform cleanup if GC occurred
            </summary>
        </member>
        <member name="F:IdeaBlade.Core.WeakRefDictionary`2._gcSentinal">
            <summary>
            Serves as a simple "GC Monitor" that indicates whether cleanup is needed. 
            If _gcSentinal.IsAlive is false, GC has occurred and we should perform cleanup
            </summary>
        </member>
        <member name="P:IdeaBlade.Core.WeakRefDictionary`2.Item(`0)">
            <summary>
            Retrieves a value from the dictionary.
            </summary>
            <param name="key">The key to look for.</param>
            <returns>The value in the dictionary.</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown when the key does exist in the dictionary.
            Since the dictionary contains weak references, the key may have been removed by the
            garbage collection of the object.</exception>
        </member>
        <member name="P:IdeaBlade.Core.WeakRefDictionary`2.Count">
            <summary>
            Returns a count of the number of items in the dictionary.
            </summary>
            <remarks>Since the items in the dictionary are held by weak reference, the count value
            cannot be relied upon to guarantee the number of objects that would be discovered via
            enumeration. Treat the Count as an estimate only.  This property also has the side effect 
            of clearing out any GC'd refs.</remarks>
        </member>
        <member name="T:IdeaBlade.Core.XapFns">
            <summary>
            A collection of static methods used to provide Silverlight XAP file features.
            </summary>
        </member>
        <member name="F:IdeaBlade.Core.XapFns.Current">
            <summary>
            Returns the current deployment package.
            </summary>
        </member>
        <member name="M:IdeaBlade.Core.XapFns.LoadXapAssemblies(IdeaBlade.Core.Xap)">
            <summary>
            Loads the assemblies in the deployment package.
            </summary>
            <param name="xap">Will use the current deployment package if not specified</param>
            <returns></returns>
            <remarks>
            
            </remarks>
        </member>
        <member name="M:IdeaBlade.Core.XapFns.LoadAssemblyFromXap(System.String,IdeaBlade.Core.Xap)">
            <summary>
            Loads an assembly of the specified name from a deployment package.
            </summary>
            <param name="name"></param>
            <param name="xap">Will use the current deployment package if not specified</param>
            <returns></returns>
        </member>
        <member name="M:IdeaBlade.Core.XapFns.GetConfigFileAsString">
            <summary>
            The app.config can be marked as 'Content' in the project, which will
            place it in the XAP file.
            </summary>
            <returns></returns>
        </member>
        <member name="P:IdeaBlade.Core.XapFns.IsClientConfigPresent">
            <summary>
            Determines if a ClientConfig file is present in XAP.
            </summary>
            <remarks>
            WCF will use the settings in ServiceReferences.ClientConfig if the file is present.
            </remarks>
        </member>
        <member name="T:System.ComponentModel.DataAnnotations.MetadataTypeAttribute">
            <summary>
               Specifies the metadata class to associate with a data model class.
            </summary>
        </member>
        <member name="M:System.ComponentModel.DataAnnotations.MetadataTypeAttribute.#ctor(System.Type)">
            <summary>
              Initializes a new instance of the IdeaBlade.Core.DataAnnotations.MetadataTypeAttribute
               class.
            </summary>
            <remarks>
            /// (Same purpose as similar attribute, which is not available for Silverlight, in the System.ComponentModel.DataAnnotation namespace)
            </remarks>
            <param name="metadataClassType"></param>
        </member>
        <member name="P:System.ComponentModel.DataAnnotations.MetadataTypeAttribute.MetadataClassType">
            <summary>
               Gets the metadata class that is associated with a data-model partial class.
            </summary>
        </member>
    </members>
</doc>
